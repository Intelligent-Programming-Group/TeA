extern int printf(const char*restrict  __format, ...); 
void* peek (int id, void *ptr) { 
        printf("peek %d %ld\n", id, (long) ptr); 
        return ptr; 
}

typedef unsigned long size_t;
struct commandtag
{
    char* cmd_name;
    void (*func)(int);
    int param;
};
typedef struct commandtag CommandArray;
struct _acroEntry
{
    char* acDef;
    char* acShort;
    char* acLong;
    char* acShortPlural;
    char* acLongPlural;
    int used;
    int printable;
};
typedef struct _acroEntry acroEntry;
typedef long __off_t;
typedef long __off64_t;
struct _IO_FILE;
typedef struct _IO_FILE FILE;
typedef void _IO_lock_t;
struct _IO_marker
{
    struct _IO_marker* _next;
    struct _IO_FILE* _sbuf;
    int _pos;
};
struct _IO_FILE
{
    int _flags;
    char* _IO_read_ptr;
    char* _IO_read_end;
    char* _IO_read_base;
    char* _IO_write_base;
    char* _IO_write_ptr;
    char* _IO_write_end;
    char* _IO_buf_base;
    char* _IO_buf_end;
    char* _IO_save_base;
    char* _IO_backup_base;
    char* _IO_save_end;
    struct _IO_marker* _markers;
    struct _IO_FILE* _chain;
    int _fileno;
    int _flags2;
    __off_t _old_offset;
    unsigned short _cur_column;
    signed char _vtable_offset;
    char _shortbuf[1];
    _IO_lock_t* _lock;
    __off64_t _offset;
    void* __pad1;
    void* __pad2;
    void* __pad3;
    void* __pad4;
    size_t __pad5;
    int _mode;
    char _unused2[(15UL * sizeof (int) - 4UL * sizeof (void*)) - sizeof (size_t)];
};
enum __anonenum_BiblioType_189467978{ BIBLIO_BIBCITE = 0, BIBLIO_HARVARD = 1, BIBLIO_NATBIB = 2};
typedef enum __anonenum_BiblioType_189467978 BiblioType;
struct _biblioElem
{
    char* biblioKey;
    char* biblioN;
    char* biblioFull;
    char* biblioAbbr;
    char* biblioYear;
    BiblioType biblioType;
};
typedef struct _biblioElem biblioElem;
struct _labelElem
{
    char* labelName;
    char* labelDef;
};
typedef struct _labelElem labelElem;
typedef short __int16_t;
typedef unsigned short __uint16_t;
typedef int __int32_t;
typedef unsigned int __uint32_t;
typedef __int16_t int16_t;
typedef __int32_t int32_t;
typedef struct _IO_FILE _IO_FILE;
typedef __uint16_t uint16_t;
typedef __uint32_t uint32_t;
typedef void PutFileFnc(char*, double, double, double, double);
struct __anonstruct_GraphConvertElement_786864549
{
    char* extension;
    PutFileFnc* encoder;
};
typedef struct __anonstruct_GraphConvertElement_786864549 GraphConvertElement;
struct __anonstruct_definition_type_358942459
{
    char* name;
    char* opt_param;
    char* def;
    int params;
};
typedef struct __anonstruct_definition_type_358942459 definition_type;
struct __anonstruct_environment_type_541553710
{
    char* name;
    char* opt_param;
    char* begname;
    char* endname;
    char* begdef;
    char* enddef;
    int params;
};
typedef struct __anonstruct_environment_type_541553710 environment_type;
struct __anonstruct_theorem_type_343724373
{
    char* name;
    char* numbered_like;
    char* caption;
    char* within;
};
typedef struct __anonstruct_theorem_type_343724373 theorem_type;
struct citekey_type
{
    char* key;
    int number;
};
typedef struct citekey_type citekey_type;
typedef unsigned char __uint8_t;
typedef __uint8_t uint8_t;
typedef long __time_t;
typedef __time_t time_t;
struct ConfigEntryT
{
    const char* TexCommand;
    const char* RtfCommand;
    int original_id;
};
typedef struct ConfigEntryT ConfigEntryT;
struct __anonstruct_counter_type_951761807
{
    char* name;
    int number;
};
typedef struct __anonstruct_counter_type_951761807 counter_type;
struct __anonstruct_length_type_951761807
{
    char* name;
    int distance;
};
typedef struct __anonstruct_length_type_951761807 length_type;
struct InputStackType
{
    char* string;
    char* string_start;
    FILE* file;
    char* file_name;
    int file_line;
};
typedef struct InputStackType InputStackType;
typedef unsigned long __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long __ino_t;
typedef unsigned int __mode_t;
typedef unsigned long __nlink_t;
typedef long __blksize_t;
typedef long __blkcnt_t;
typedef long __syscall_slong_t;
struct timespec
{
    __time_t tv_sec;
    __syscall_slong_t tv_nsec;
};
struct stat
{
    __dev_t st_dev;
    __ino_t st_ino;
    __nlink_t st_nlink;
    __mode_t st_mode;
    __uid_t st_uid;
    __gid_t st_gid;
    int __pad0;
    __dev_t st_rdev;
    __off_t st_size;
    __blksize_t st_blksize;
    __blkcnt_t st_blocks;
    struct timespec st_atim;
    struct timespec st_mtim;
    struct timespec st_ctim;
    __syscall_slong_t __glibc_reserved[3];
};
typedef __builtin_va_list __gnuc_va_list;
typedef __gnuc_va_list va_list;
struct ConfigInfoT
{
    char* filename;
    ConfigEntryT** config_info;
    int config_info_size;
    int remove_leading_backslash;
};
typedef struct ConfigInfoT ConfigInfoT;
struct TabularT
{
    int n;
    int i;
    char* align;
    int* chars;
    int* vert;
    int* width;
    int* cline;
    char** before;
    char** after;
};
typedef struct TabularT TabularT;
struct iftag
{
    char* if_name;
    int is_true;
    int did_push_env;
};
typedef struct iftag IfName;
struct RtfFontInfoType
{
    int family;
    int shape;
    int series;
    int size;
    int encoding;
};
typedef struct RtfFontInfoType RtfFontInfoType;
extern void* (malloc)(size_t __size);
extern void* (realloc)(void* __ptr, size_t __size);
extern void (free)(void* __ptr);
extern char* (strcpy)(char*restrict  __dest, const char*restrict  __src);
extern int (strcmp)(const char* __s1, const char* __s2);
extern char* (strdup)(const char* __s);
extern char* (strchr)(const char* __s, int __c);
extern char* (strtok)(char*restrict  __s, const char*restrict  __delim);
extern size_t (strlen)(const char* __s);
extern int sprintf(char*restrict  __s, const char*restrict  __format, ...);
void diagnostics(int level, char* format, ...);
void fprintRTF(char* format, ...);
char* getBraceParam(void);
char* getBracketParam(void);
char* getTexUntil(char* target, int raw);

inline static void ignoreBraceParam(void)
{
    char* p;
    char* tmp;
    {
        {
            tmp = getBraceParam();
            p = tmp;
        }
        if ((unsigned long )((void*)0) != (unsigned long )p){
            {
                free((void*)p);
            }
        }
        return;
    }
}

inline static int streq(const char* s1, const char* s2)
{
    int tmp;
    {
        {
            tmp = strcmp(s1, s2);
        }
        return (tmp == 0);
    }
}

inline static int strHasChar(const char* s1, const char c)
{
    char* tmp;
    {
        {
            tmp = strchr(s1, (int)c);
        }
        return ((unsigned long )((void*)0) != (unsigned long )tmp);
    }
}

inline static void safe_free(char* s)
{
    {
        if (s){
            {
                free((void*)s);
            }
        }
        return;
    }
}

void ConvertString(const char* string);
void PushEnvironment(int code);
int getLength(char* s);
void CmdEndParagraph(int code);
void startParagraph(const char* style___0, int indenting);
void setVspace(int space);
void LoadAuxFile(void);
int acroPrintWithPage;
int acroPrintOnlyUsed;
void UsePackageAcronym(char* options);
void CmdBeginAcronym(int code);
void CmdAcrodef(int code);
void CmdAcroExtra(int code);
void CmdAc(int code);
void CmdAcResetAll(int code);
void CmdAcUsed(int code);
void CmdAC(int code);
int acronymHint(int maxWidth);
CommandArray acronymCommands[31];
char* getLabelPage(char* name);
CommandArray acronymCommands[31] = {{(char*)"acrodef", &CmdAcrodef, 5}, {(char*)"acrodefplural", &CmdAcrodef, 6}, {(char*)"acro", &CmdAcrodef, 3}, {(char*)"acroplural", &CmdAcrodef, 4}, {(char*)"acresetall", &CmdAcResetAll, 0}, {(char*)"AC", &CmdAC, 0}, {(char*)"acused", &CmdAcUsed, 0}, {(char*)"acroextra", &CmdAcroExtra, 0}, {(char*)"ac", &CmdAc, 1}, {(char*)"acl", &CmdAc, 2}, {(char*)"acs", &CmdAc, 3}, {(char*)"acf", &CmdAc, 4}, {(char*)"acfi", &CmdAc, 5}, {(char*)"acp", &CmdAc, 257}, {(char*)"aclp", &CmdAc, 258}, {(char*)"acsp", &CmdAc, 259}, {(char*)"acfp", &CmdAc, 260}, {(char*)"acsu", &CmdAc, 1027}, {(char*)"aclu", &CmdAc, 1026}, {(char*)"ac*", &CmdAc, 513}, {(char*)"acs*", &CmdAc, 515}, {(char*)"acl*", &CmdAc, 514}, {(char*)"acf*", &CmdAc, 516}, {(char*)"acp*", &CmdAc, 769}, {(char*)"acsp*", &CmdAc, 771}, {(char*)"aclp*", &CmdAc, 770}, {(char*)"acfp*", &CmdAc, 772}, {(char*)"acfi*", &CmdAc, 513}, {(char*)"acsu*", &CmdAc, 1539}, {(char*)"aclu*", &CmdAc, 1538}, {(char*)"", (void(*)(int))((void*)0), 0}};

void UsePackageAcronym(char* options)
{
    char* acroOptions;
    char* tmp;
    char* opt;
    int tmp___1;
    int tmp___2;
    int tmp___3;
    int tmp___4;
    {
        {
            diagnostics(1, (char*)"acronym package support: almost v1.35");
            LoadAuxFile();
            PushEnvironment(27);
        }
        if ((unsigned long )options != (unsigned long )((void*)0)){
            {
                tmp = strdup((const char*)options);
                acroOptions = tmp;
                tmp___2 = strHasChar((const char*)options, (const char)',');
            }
            if (tmp___2){
                tmp___1 = 's';
            }else{
                tmp___1 = ' ';
            }
            {
                diagnostics(1, (char*)"acronym package with option%c %s", tmp___1, options);
                opt = strtok((char*)acroOptions, (const char*)",");
            }
            {
                while (1){
                    while_continue:
                    ;
                    if (!((unsigned long )((void*)0) != (unsigned long )opt)){
                        goto while_break;
                    }
                    {
                        tmp___4 = streq((const char*)opt, "printonlyused");
                    }
                    if (tmp___4){
                        acroPrintOnlyUsed = 1;
                    }else{
                        {
                            tmp___3 = streq((const char*)opt, "withpage");
                        }
                        if (tmp___3){
                            acroPrintWithPage = 1;
                        }else{
                            {
                                diagnostics(1, (char*)"acronym package: option %s unknown", opt);
                            }
                        }
                    }
                    {
                        opt = strtok((char*)((void*)0), (const char*)",");
                    }
                }
                while_break:
                ;
            }
            {
                free((void*)acroOptions);
            }
        }
        return;
    }
}

static int inAcroEnvironment = 0;

void CmdBeginAcronym(int code)
{
    char* longest;
    char* tmp;
    {
        if (16384 == (code & 16384)){
            {
                tmp = getBracketParam();
                longest = tmp;
            }
            if ((unsigned long )((void*)0) != (unsigned long )longest){
                {
                    diagnostics(1, (char*)"Ignoring longest acronym hint \'[%s]\'", longest);
                    free((void*)longest);
                }
            }
            inAcroEnvironment = 1;
        }else{
            inAcroEnvironment = 0;
        }
        return;
    }
}

static acroEntry* acroTable = (acroEntry*)((void*)0);
static int acroNum = 0;
int acroPrintOnlyUsed = 0;
int acroPrintWithPage = 0;

acroEntry* searchEntry(char* acDef)
{
    int i;
    int tmp;
    {
        if ((unsigned long )acDef != (unsigned long )((void*)0)){
            i = 0;
            {
                while (1){
                    while_continue:
                    ;
                    if (!(i < acroNum)){
                        goto while_break;
                    }
                    {
                        tmp = strcmp((const char*)acDef, (const char*)(acroTable + i)->acDef);
                    }
                    if (0 == tmp){
                        return (acroTable + i);
                    }
                    i++;
                }
                while_break:
                ;
            }
        }
        return ((acroEntry*)((void*)0));
    }
}

static void ConvertFmtString(char* fmt, char* str)
{
    char* buffer___0;
    size_t tmp;
    size_t tmp___0;
    void* tmp___1;
    {
        {
            tmp = strlen((const char*)fmt);
            tmp___0 = strlen((const char*)str);
            tmp___1 = malloc((tmp + tmp___0) + 1UL);
            buffer___0 = (char*)tmp___1;
            sprintf((char*)buffer___0, (const char*)fmt, str);
            ConvertString((const char*)buffer___0);
        }
        return;
    }
}

static void ConvertFmt2String(char* fmt, char* s1, char* s2)
{
    char* buffer___0;
    size_t tmp;
    size_t tmp___0;
    size_t tmp___1;
    void* tmp___2;
    {
        {
            tmp = strlen((const char*)fmt);
            tmp___0 = strlen((const char*)s1);
            tmp___1 = strlen((const char*)s2);
            tmp___2 = malloc(((tmp + tmp___0) + tmp___1) + 1UL);
            buffer___0 = (char*)tmp___2;
            sprintf((char*)buffer___0, (const char*)fmt, s1, s2);
            ConvertString((const char*)buffer___0);
        }
        return;
    }
}

static void printLong(acroEntry* entry, int plural)
{
    {
        if (0 == plural){
            {
                ConvertString((const char*)entry->acLong);
            }
        }else
            if ((unsigned long )((void*)0) != (unsigned long )entry->acLongPlural){
                {
                    ConvertString((const char*)entry->acLongPlural);
                }
            }else{
                {
                    ConvertString((const char*)entry->acLong);
                    ConvertString("s");
                }
            }

        return;
    }
}

static void printShort(acroEntry* entry, int plural)
{
    {
        if (0 == plural){
            {
                ConvertString((const char*)entry->acShort);
            }
        }else
            if ((unsigned long )((void*)0) != (unsigned long )entry->acShortPlural){
                {
                    ConvertString((const char*)entry->acShortPlural);
                }
            }else{
                {
                    ConvertString((const char*)entry->acShort);
                    ConvertString("s");
                }
            }

        return;
    }
}

static char* regularPlural(char* singular)
{
    int singularLength;
    size_t tmp;
    char* result;
    void* tmp___0;
    {
        {
            tmp = strlen((const char*)singular);
            singularLength = (int)tmp;
            tmp___0 = malloc((size_t)(singularLength + 2));
            result = (char*)tmp___0;
        }
        if ((unsigned long )((void*)0) != (unsigned long )result){
            {
                strcpy((char*)result, (const char*)singular);
                *(result + singularLength) = (char)'s';
                *(result + (singularLength + 1)) = (char)'\000';
            }
        }
        return (result);
    }
}

static acroEntry* createEntry(char* acDef)
{
    acroEntry* result;
    acroEntry* tmp;
    void* ptr;
    {
        {
            tmp = searchEntry(acDef);
            result = tmp;
        }
        if ((unsigned long )((void*)0) == (unsigned long )result){
            {
                ptr = (void*)acroTable;
                acroNum++;
                ptr = realloc(ptr, (unsigned long )acroNum * sizeof (acroEntry));
                acroTable = (acroEntry*)ptr;
            }
            if ((unsigned long )((void*)0) != (unsigned long )acroTable){
                result = acroTable + (acroNum - 1);
                result->acDef = acDef;
                result->acShort = (char*)((void*)0);
                result->acLong = (char*)((void*)0);
                result->acShortPlural = (char*)((void*)0);
                result->acLongPlural = (char*)((void*)0);
                result->used = 0;
                result->printable = 0;
            }
        }
        return (result);
    }
}

static void acroDiag(acroEntry* thisEntry)
{
    register int diagLevel;
    int entry;
    {
        {
            diagLevel = 5;
            entry = (int)(thisEntry - acroTable);
            diagnostics(diagLevel, (char*)"defining acronym");
            diagnostics(diagLevel, (char*)" acroTable[%d].acDef         = %s", entry, thisEntry->acDef);
        }
        if ((unsigned long )((void*)0) != (unsigned long )thisEntry->acShort){
            {
                diagnostics(diagLevel, (char*)" acroTable[%d].acShort       = %s", entry, thisEntry->acShort);
            }
        }
        if ((unsigned long )((void*)0) != (unsigned long )thisEntry->acLong){
            {
                diagnostics(diagLevel, (char*)" acroTable[%d].acLong        = %s", entry, thisEntry->acLong);
            }
        }
        if ((unsigned long )((void*)0) != (unsigned long )thisEntry->acShortPlural){
            {
                diagnostics(diagLevel, (char*)" acroTable[%d].acShortPlural = %s", entry, thisEntry->acShortPlural);
            }
        }
        if ((unsigned long )((void*)0) != (unsigned long )thisEntry->acLongPlural){
            {
                diagnostics(diagLevel, (char*)" acroTable[%d].acLongPlural  = %s", entry, thisEntry->acLongPlural);
            }
        }
        return;
    }
}

void CmdAcrodef(int code)
{
    char* acDef;
    char* acShort;
    char* acLong;
    acroEntry* thisEntry;
    char* tmp;
    int doPrint;
    int tmp___0;
    int vspace;
    int tmp___1;
    int tmp___2;
    char* tmp___3;
    char* acroLabel;
    size_t tmp___4;
    void* tmp___5;
    char* acroPage;
    {
        {
            acDef = (char*)((void*)0);
            acShort = (char*)((void*)0);
            acLong = (char*)((void*)0);
            thisEntry = (acroEntry*)((void*)0);
            acDef = getBraceParam();
            acShort = getBracketParam();
            acLong = getBraceParam();
        }
        {
            if (code == 1){
                goto case_1;
            }
            if (code == 2){
                goto case_2;
            }
            if (code == 3){
                goto case_3;
            }
            goto switch_default;
            case_1:
            {
                thisEntry = createEntry(acDef);
            }
            if ((unsigned long )acShort == (unsigned long )((void*)0)){
                acShort = acDef;
            }
            if ((unsigned long )((void*)0) != (unsigned long )thisEntry){
                {
                    thisEntry->acShort = acShort;
                    thisEntry->acLong = acLong;
                    acroDiag(thisEntry);
                }
            }else{
                {
                    diagnostics(0, (char*)"Out of memory!");
                }
            }
            goto switch_break;
            case_2:
            {
                thisEntry = createEntry(acDef);
            }
            if ((unsigned long )((void*)0) != (unsigned long )thisEntry){
                if ((unsigned long )acShort == (unsigned long )((void*)0)){
                    {
                        tmp = regularPlural(acDef);
                        thisEntry->acShortPlural = tmp;
                    }
                }else{
                    thisEntry->acShortPlural = acShort;
                }
                {
                    thisEntry->acLongPlural = acLong;
                    acroDiag(thisEntry);
                }
            }else{
                {
                    diagnostics(0, (char*)"Out of memory!");
                }
            }
            goto switch_break;
            case_3:
            {
                thisEntry = searchEntry(acDef);
            }
            if ((unsigned long )((void*)0) != (unsigned long )thisEntry){
                if (thisEntry->used == 1){
                    tmp___0 = 1;
                }else
                    if (acroPrintOnlyUsed == 0){
                        tmp___0 = 1;
                    }else{
                        tmp___0 = 0;
                    }

                doPrint = tmp___0;
                if (doPrint){
                    {
                        tmp___1 = getLength((char*)"itemsep");
                        tmp___2 = getLength((char*)"parsep");
                        vspace = tmp___1 + tmp___2;
                        CmdEndParagraph(0);
                        setVspace(vspace);
                        startParagraph("acronym", 1);
                        fprintRTF((char*)"{\\b ");
                    }
                    if ((unsigned long )((void*)0) != (unsigned long )acShort){
                        tmp___3 = acShort;
                    }else{
                        tmp___3 = acDef;
                    }
                    {
                        ConvertString((const char*)tmp___3);
                        fprintRTF((char*)"}\\tab\n");
                        ConvertString((const char*)acLong);
                    }
                    if (1 == acroPrintWithPage){
                        {
                            tmp___4 = strlen((const char*)acDef);
                            tmp___5 = malloc(tmp___4 + 8UL);
                            acroLabel = (char*)tmp___5;
                        }
                        if ((unsigned long )((void*)0) != (unsigned long )acroLabel){
                            {
                                sprintf((char*)acroLabel, (const char*)"acro:%s", acDef);
                                acroPage = getLabelPage(acroLabel);
                            }
                            if ((unsigned long )((void*)0) != (unsigned long )acroPage){
                                {
                                    fprintRTF((char*)" \\tab ");
                                    ConvertString((const char*)acroPage);
                                }
                            }
                            {
                                safe_free(acroPage);
                            }
                        }
                        {
                            safe_free(acroLabel);
                        }
                    }
                    {
                        CmdEndParagraph(0);
                    }
                }
                switch_default:
                {
                    safe_free(acDef);
                    safe_free(acShort);
                    safe_free(acLong);
                }
                goto switch_break;
            }
            switch_break:
            ;
        }
        return;
    }
}

int acronymHint(int maxWidth)
{
    {
        return ((int)((double)maxWidth / 6.00));
    }
}

void CmdAC(int code)
{
    char* shortAc;
    {
        {
            shortAc = getTexUntil((char*)"hyperlink", 0);
            safe_free(shortAc);
            ignoreBraceParam();
            shortAc = getBraceParam();
            ConvertString((const char*)shortAc);
            safe_free(shortAc);
        }
        return;
    }
}

void CmdAc(int code)
{
    char* ac;
    acroEntry* found;
    int basecode;
    int plural;
    int star;
    int markUsed;
    {
        {
            found = (acroEntry*)((void*)0);
            basecode = code & 255;
            plural = (code & 3840) == 256;
            star = (code & 3840) == 512;
            markUsed = (code & 3840) == 1024;
            ac = getBraceParam();
            found = searchEntry(ac);
        }
        if ((unsigned long )found == (unsigned long )((void*)0)){
            if (basecode == 1){
                {
                    ConvertFmt2String((char*)"\\textsf{\\textbf{%s! (%s!)}}", ac, ac);
                }
            }else{
                {
                    ConvertFmtString((char*)"\\textsf{\\textbf{%s!}}", ac);
                }
            }
            {
                diagnostics(1, (char*)"Undefined acronym \'%s\'", ac);
            }
            return;
        }
        if (basecode == 1){
            if (found->used == 1){
                basecode = 3;
            }else{
                found->used = star == 0;
                basecode = 4;
            }
        }
        if (markUsed == 1){
            if (star == 0){
                found->used = 1;
            }
        }
        {
            if (basecode == 4){
                goto case_4;
            }
            if (basecode == 3){
                goto case_3;
            }
            if (basecode == 2){
                goto case_2;
            }
            if (basecode == 5){
                goto case_5;
            }
            goto switch_default;
            case_4:
            {
                printLong(found, plural);
                ConvertString(" (");
                printShort(found, plural);
                ConvertString(")");
            }
            goto switch_break;
            case_3:
            {
                printShort(found, plural);
            }
            goto switch_break;
            case_2:
            {
                printLong(found, plural);
            }
            goto switch_break;
            case_5:
            {
                ConvertFmt2String((char*)"\\textit{%s} (%s)", found->acLong, found->acShort);
            }
            goto switch_break;
            switch_default:
            {
                diagnostics(1, (char*)"Fell through CmdAc()!");
            }
            goto switch_break;
            switch_break:
            ;
        }
        {
            safe_free(ac);
        }
        return;
    }
}

void CmdAcUsed(int code)
{
    acroEntry* acronym;
    char* ac;
    char* tmp;
    {
        {
            acronym = (acroEntry*)((void*)0);
            tmp = getBraceParam();
            ac = tmp;
            acronym = searchEntry(ac);
        }
        if ((unsigned long )acronym != (unsigned long )((void*)0)){
            acronym->used = 1;
        }
        {
            safe_free(ac);
        }
        return;
    }
}

void CmdAcResetAll(int code)
{
    int i;
    {
        i = 0;
        {
            while (1){
                while_continue:
                ;
                if (!(i < acroNum)){
                    goto while_break;
                }
                (acroTable + i)->used = 0;
                i++;
            }
            while_break:
            ;
        }
        return;
    }
}

void CmdAcroExtra(int code)
{
    char* ac;
    char* tmp;
    {
        {
            tmp = getBraceParam();
            ac = tmp;
        }
        if ((unsigned long )ac != (unsigned long )((void*)0)){
            {
                ConvertString((const char*)ac);
            }
        }
        {
            safe_free(ac);
        }
        return;
    }
}

extern char* (strstr)(const char* __haystack, const char* __needle);
extern int fclose(FILE* __stream);
extern FILE* fopen(const char*restrict  __filename, const char*restrict  __modes);
char* g_aux_name;
FILE* my_fopen(char* path, char* mode);
char* my_fgets(char* buffer___0, int maxBuffer, FILE* f);

inline static int strstarts(const char* s1, const char* s2)
{
    char* tmp;
    {
        {
            tmp = strstr(s1, s2);
        }
        return ((unsigned long )s1 == (unsigned long )tmp);
    }
}

char* acronymAux[6] = {(char*)"\\newlabel", (char*)"\\newacro", (char*)"\\newacroplural", (char*)"\\harvardcite", (char*)"\\bibcite", (char*)((void*)0)};

static void FilterAuxFile(FILE* auxFile)
{
    char linebuffer[1024];
    char** candidate;
    int tosFStack;
    FILE* fStack[16];
    size_t tmp;
    char* fname;
    char* tmp___0;
    char* p;
    char* tmp___1;
    FILE* tmp___2;
    int tmp___3;
    char c1;
    size_t tmp___4;
    char c2;
    size_t tmp___5;
    char* tmp___6;
    int tmp___7;
    char* tmp___8;
    {
        if ((unsigned long )auxFile == (unsigned long )((void*)0)){
            return;
        }
        tosFStack = 0;
        fStack[tosFStack] = auxFile;
        {
            while (1){
                while_continue:
                ;
                if (!(tosFStack != -1)){
                    goto while_break;
                }
                {
                    while (1){
                        while_continue___0:
                        ;
                        {
                            tmp___8 = my_fgets(linebuffer, 1023, fStack[tosFStack]);
                        }
                        if (!((unsigned long )tmp___8 != (unsigned long )((void*)0))){
                            goto while_break___0;
                        }
                        {
                            tmp = strlen((const char*)(linebuffer));
                        }
                        if (tmp == 0UL){
                            goto while_continue___0;
                        }
                        {
                            tmp___3 = strstarts((const char*)(linebuffer), "\\@input{");
                        }
                        if (tmp___3){
                            {
                                tmp___0 = strchr((const char*)(linebuffer), '{');
                                fname = tmp___0;
                                tmp___1 = strchr((const char*)fname, '}');
                                p = tmp___1;
                                fname++;
                                *p = (char)'\000';
                            }
                            if (tosFStack >= 15){
                                {
                                    diagnostics(1, (char*)"AUX File stack overflow for <%s>", fname);
                                }
                            }else{
                                {
                                    tosFStack++;
                                    tmp___2 = fopen((const char*)fname, (const char*)"r");
                                    fStack[tosFStack] = tmp___2;
                                }
                                if ((unsigned long )((void*)0) == (unsigned long )tmp___2){
                                    {
                                        diagnostics(1, (char*)"File not found: %s", fname);
                                        tosFStack--;
                                    }
                                }else{
                                    {
                                        diagnostics(1, (char*)"([%d] %s)", tosFStack, fname);
                                    }
                                }
                            }
                            goto while_continue___0;
                        }
                        candidate = acronymAux;
                        {
                            while (1){
                                while_continue___1:
                                ;
                                if (!((unsigned long )*candidate != (unsigned long )((void*)0))){
                                    goto while_break___1;
                                }
                                {
                                    tmp___7 = strstarts((const char*)(linebuffer), (const char*)*candidate);
                                }
                                if (tmp___7){
                                    {
                                        tmp___4 = strlen((const char*)*candidate);
                                        c1 = linebuffer[tmp___4];
                                    }
                                    if ((int)c1 != 0){
                                        {
                                            tmp___5 = strlen((const char*)*candidate);
                                            c2 = linebuffer[tmp___5 + 1UL];
                                        }
                                        if ((int)c1 == 123){
                                            {
                                                tmp___6 = strdup((const char*)(linebuffer));
                                                ConvertString((const char*)tmp___6);
                                            }
                                        }else
                                            if ((int)c1 == 32){
                                                if ((int)c2 == 123){
                                                    {
                                                        tmp___6 = strdup((const char*)(linebuffer));
                                                        ConvertString((const char*)tmp___6);
                                                    }
                                                }
                                            }
                                    }
                                }
                                candidate++;
                            }
                            while_break___1:
                            ;
                        }
                    }
                    while_break___0:
                    ;
                }
                if (tosFStack > 0){
                    {
                        fclose(fStack[tosFStack]);
                    }
                }
                tosFStack--;
            }
            while_break:
            ;
        }
        return;
    }
}

static int alreadyLoaded = 0;

void LoadAuxFile(void)
{
    FILE* auxFile;
    {
        if (alreadyLoaded == 1){
            return;
        }
        {
            alreadyLoaded = 1;
            auxFile = my_fopen(g_aux_name, (char*)"rb");
        }
        if ((unsigned long )((void*)0) == (unsigned long )auxFile){
            {
                diagnostics(1, (char*)"%s not found.  Run LaTeX to create it.", g_aux_name);
            }
        }else{
            {
                diagnostics(1, (char*)"(%s)", g_aux_name);
                FilterAuxFile(auxFile);
            }
        }
        return;
    }
}

int PushSource(const char* filename, const char* string);
void PopSource(void);
biblioElem* getBiblio(char* key);
biblioElem* newBibCite(char* cite, char* tag);
biblioElem* newHarvardCite(char* cite, char* full, char* abbr, char* year);
biblioElem* newNatBibCite(char* cite, char* full, char* abbr, char* year, char* n);
char* getBiblioRef(char* key);
char* getBiblioFirst(char* key);
void CmdBibCite(int code);
void CmdAuxHarvardCite(int code);
static biblioElem* biblioTable = (biblioElem*)((void*)0);
static int biblioCount = 0;

static biblioElem* newBiblio(char* newKey)
{
    biblioElem* result;
    void* tmp;
    int tmp___0;
    {
        {
            tmp = realloc((void*)biblioTable, sizeof (biblioElem) * (unsigned long )(biblioCount + 1));
            result = (biblioElem*)tmp;
        }
        if ((unsigned long )((void*)0) != (unsigned long )result){
            biblioTable = result;
            tmp___0 = biblioCount;
            biblioCount++;
            result += tmp___0;
            result->biblioKey = newKey;
            result->biblioN = (char*)((void*)0);
            result->biblioFull = (char*)((void*)0);
            result->biblioAbbr = (char*)((void*)0);
            result->biblioYear = (char*)((void*)0);
        }
        return (result);
    }
}

static void printTable(void)
{
    {
        return;
    }
}

biblioElem* getBiblio(char* key)
{
    int i;
    int tmp;
    {
        {
            LoadAuxFile();
            i = 0;
        }
        {
            while (1){
                while_continue:
                ;
                if (!(i < biblioCount)){
                    goto while_break;
                }
                {
                    tmp = streq((const char*)(biblioTable + i)->biblioKey, (const char*)key);
                }
                if (tmp){
                    return (biblioTable + i);
                }
                i++;
            }
            while_break:
            ;
        }
        return ((biblioElem*)((void*)0));
    }
}

char* getBiblioRef(char* key)
{
    biblioElem* result;
    biblioElem* tmp;
    char* tmp___0;
    {
        {
            tmp = getBiblio(key);
            result = tmp;
        }
        if ((unsigned long )result != (unsigned long )((void*)0)){
            {
                tmp___0 = strdup((const char*)result->biblioN);
            }
            return (tmp___0);
        }
        return ((char*)((void*)0));
    }
}

char* getBiblioFirst(char* key)
{
    biblioElem* result;
    biblioElem* tmp;
    char* ref;
    char* tmp___0;
    char* res;
    {
        {
            tmp = getBiblio(key);
            result = tmp;
        }
        if ((unsigned long )result != (unsigned long )((void*)0)){
            {
                tmp___0 = strdup((const char*)result->biblioN);
                ref = tmp___0;
                res = (char*)((void*)0);
            }
            if ((unsigned long )((void*)0) != (unsigned long )ref){
                {
                    PushSource((const char*)((void*)0), (const char*)ref);
                    res = getBraceParam();
                    PopSource();
                }
            }
            {
                safe_free(ref);
            }
            return (res);
        }
        return ((char*)((void*)0));
    }
}

biblioElem* newBibCite(char* cite, char* tag)
{
    biblioElem* newCite;
    biblioElem* tmp;
    {
        {
            tmp = newBiblio(cite);
            newCite = tmp;
        }
        if ((unsigned long )((void*)0) != (unsigned long )newCite){
            {
                newCite->biblioN = tag;
                newCite->biblioType = (BiblioType)0;
                printTable();
            }
        }
        return (newCite);
    }
}

biblioElem* newHarvardCite(char* cite, char* full, char* abbr, char* year)
{
    biblioElem* newCite;
    biblioElem* tmp;
    {
        {
            tmp = newBiblio(cite);
            newCite = tmp;
        }
        if ((unsigned long )((void*)0) != (unsigned long )newCite){
            newCite->biblioFull = full;
            newCite->biblioAbbr = abbr;
            newCite->biblioYear = year;
            newCite->biblioType = (BiblioType)1;
        }
        return (newCite);
    }
}

biblioElem* newNatBibCite(char* cite, char* full, char* abbr, char* year, char* n)
{
    biblioElem* newCite;
    biblioElem* tmp;
    {
        {
            tmp = newBiblio(cite);
            newCite = tmp;
        }
        if ((unsigned long )((void*)0) != (unsigned long )newCite){
            newCite->biblioFull = full;
            newCite->biblioAbbr = abbr;
            newCite->biblioYear = year;
            newCite->biblioN = n;
            newCite->biblioType = (BiblioType)2;
        }
        return (newCite);
    }
}

void CmdBibCite(int code)
{
    char* p1;
    char* tmp;
    char* p2;
    char* tmp___0;
    biblioElem* tmp___1;
    {
        {
            tmp = getBraceParam();
            p1 = tmp;
            tmp___0 = getBraceParam();
            p2 = tmp___0;
            tmp___1 = newBibCite(p1, p2);
        }
        if ((unsigned long )((void*)0) == (unsigned long )tmp___1){
            {
                diagnostics(1, (char*)"memory exhausted for \\bibcite{%s}{%s}", p1, p2);
                free((void*)p1);
                free((void*)p2);
            }
        }
        return;
    }
}

void CmdAuxHarvardCite(int code)
{
    char* key;
    char* tmp;
    char* full;
    char* tmp___0;
    char* abbr;
    char* tmp___1;
    char* year;
    char* tmp___2;
    biblioElem* tmp___3;
    {
        {
            tmp = getBraceParam();
            key = tmp;
            tmp___0 = getBraceParam();
            full = tmp___0;
            tmp___1 = getBraceParam();
            abbr = tmp___1;
            tmp___2 = getBraceParam();
            year = tmp___2;
            tmp___3 = newHarvardCite(key, full, abbr, year);
        }
        if ((unsigned long )((void*)0) == (unsigned long )tmp___3){
            {
                diagnostics(0, (char*)"Memory overflow defining \\harvardcite(%s)", key);
            }
        }
        return;
    }
}

labelElem* getLabel(char* name);
char* getLabelDefinition(char* name);
char* getLabelSection(char* name);
char* getLabelNameref(char* name);
void CmdNewLabel(int code);
static labelElem* labelTable = (labelElem*)((void*)0);
static int labelCount = 0;
static int labelReserved = 0;

static labelElem* newLabel(char* name, char* def)
{
    labelElem* result;
    void* tmp;
    int tmp___0;
    {
        result = labelTable;
        if (labelCount == labelReserved){
            {
                tmp = realloc((void*)labelTable, (unsigned long )(labelReserved + 8) * sizeof (labelElem));
                result = (labelElem*)tmp;
            }
            if ((unsigned long )((void*)0) != (unsigned long )result){
                labelTable = result;
                labelReserved += 8;
            }
        }
        if ((unsigned long )((void*)0) != (unsigned long )result){
            tmp___0 = labelCount;
            labelCount++;
            result = labelTable + tmp___0;
            result->labelName = name;
            result->labelDef = def;
        }
        return (result);
    }
}

labelElem* getLabel(char* name)
{
    labelElem* result;
    int label;
    int tmp;
    {
        {
            result = (labelElem*)((void*)0);
            LoadAuxFile();
            label = 0;
        }
        {
            while (1){
                while_continue:
                ;
                if (!(label < labelCount)){
                    goto while_break;
                }
                {
                    tmp = streq((const char*)name, (const char*)(labelTable + label)->labelName);
                }
                if (tmp){
                    result = labelTable + label;
                    goto while_break;
                }
                label++;
            }
            while_break:
            ;
        }
        return (result);
    }
}

char* getLabelNameref(char* name)
{
    char* result;
    labelElem* label;
    labelElem* tmp;
    char* fullDef;
    char* tmp___0;
    {
        {
            result = (char*)((void*)0);
            tmp = getLabel(name);
            label = tmp;
        }
        if ((unsigned long )((void*)0) != (unsigned long )label){
            {
                tmp___0 = strdup((const char*)label->labelDef);
                fullDef = tmp___0;
                PushSource((const char*)((void*)0), (const char*)fullDef);
                ignoreBraceParam();
                ignoreBraceParam();
                result = getBraceParam();
                PopSource();
                free((void*)fullDef);
            }
        }
        return (result);
    }
}

char* getLabelSection(char* name)
{
    char* result;
    labelElem* label;
    labelElem* tmp;
    char* fullDef;
    char* tmp___0;
    {
        {
            result = (char*)((void*)0);
            tmp = getLabel(name);
            label = tmp;
        }
        if ((unsigned long )((void*)0) != (unsigned long )label){
            {
                tmp___0 = strdup((const char*)label->labelDef);
                fullDef = tmp___0;
                PushSource((const char*)((void*)0), (const char*)fullDef);
                result = getBraceParam();
                PopSource();
                free((void*)fullDef);
            }
        }
        return (result);
    }
}

char* getLabelPage(char* name)
{
    char* result;
    labelElem* label;
    labelElem* tmp;
    char* fullDef;
    char* tmp___0;
    {
        {
            result = (char*)((void*)0);
            tmp = getLabel(name);
            label = tmp;
        }
        if ((unsigned long )((void*)0) != (unsigned long )label){
            {
                tmp___0 = strdup((const char*)label->labelDef);
                fullDef = tmp___0;
                PushSource((const char*)((void*)0), (const char*)fullDef);
                ignoreBraceParam();
                result = getBraceParam();
                PopSource();
                free((void*)fullDef);
            }
        }
        return (result);
    }
}

char* getLabelDefinition(char* name)
{
    char* result;
    labelElem* label;
    labelElem* tmp;
    {
        {
            result = (char*)((void*)0);
            tmp = getLabel(name);
            label = tmp;
        }
        if ((unsigned long )((void*)0) != (unsigned long )label){
            {
                result = strdup((const char*)label->labelDef);
            }
        }
        return (result);
    }
}

void CmdNewLabel(int code)
{
    char* p;
    char* tmp;
    char* p1;
    char* tmp___0;
    char* p2;
    char* tmp___1;
    labelElem* tmp___2;
    {
        if (1 == code){
            {
                tmp = getBraceParam();
                p = tmp;
                diagnostics(1, (char*)"undoing label \'%s\'", p);
                free((void*)p);
            }
        }else{
            {
                tmp___0 = getBraceParam();
                p1 = tmp___0;
                tmp___1 = getBraceParam();
                p2 = tmp___1;
                tmp___2 = newLabel(p1, p2);
            }
            if ((unsigned long )((void*)0) == (unsigned long )tmp___2){
                {
                    diagnostics(1, (char*)"memory overflow defining label \'%s\' as \'%s\'", p1, p2);
                    free((void*)p1);
                    free((void*)p2);
                }
            }
        }
        return;
    }
}

char g_field_separator;
void startField(int type);
void endCurrentField(void);
void endAllFields(void);
void fprintfRTF_field_separator(void);
void set_field_separator(char c);
void set_fields_use_REF(int i);
int fields_use_REF(void);
void set_fields_use_EQ(int i);
int fields_use_EQ(void);
int processing_fields(void);
int EQ_field_active(void);
int g_equation_field_EQ_in_effect = 0;
int g_fields_use_EQ = 1;
int g_fields_use_REF = 1;
int g_fields_use_SYMBOL = 1;
int g_fields_use_PAGE = 1;
int g_fields_use_PAGE_REF = 1;
int g_fields_use_COMMENT = 1;
int g_fields_allowed = 1;
char g_field_separator = (char)',';
int g_field_depth = -1;
int g_field[20];

int EQ_field_active(void)
{
    int i;
    {
        i = 0;
        {
            while (1){
                while_continue:
                ;
                if (!(i <= g_field_depth)){
                    goto while_break;
                }
                if (g_field[i] == 1){
                    return (1);
                }
                i++;
            }
            while_break:
            ;
        }
        return (0);
    }
}

void startField(int type)
{
    int tmp;
    {
        if (!g_fields_allowed){
            return;
        }
        {
            if (type == 1){
                goto case_1;
            }
            if (type == 2){
                goto case_2;
            }
            if (type == 3){
                goto case_3;
            }
            if (type == 4){
                goto case_4;
            }
            if (type == 5){
                goto case_5;
            }
            if (type == 6){
                goto case_6;
            }
            goto switch_break;
            case_1:
            {
                diagnostics(4, (char*)"starting EQ field");
                diagnostics(6, (char*)"EQ fields allowed = %d", g_fields_use_EQ);
            }
            if (!g_fields_use_EQ){
                return;
            }
            {
                tmp = EQ_field_active();
            }
            if (tmp){
                {
                    diagnostics(1, (char*)"nested EQ fields ???");
                }
            }
            {
                fprintRTF((char*)"{\\field{\\*\\fldinst{ EQ ");
            }
            goto switch_break;
            case_2:
            {
                diagnostics(4, (char*)"starting REF field");
            }
            if (!g_fields_use_REF){
                return;
            }
            goto switch_break;
            case_3:
            {
                diagnostics(4, (char*)"starting SYMBOL field");
            }
            if (!g_fields_use_SYMBOL){
                return;
            }
            goto switch_break;
            case_4:
            {
                diagnostics(4, (char*)"starting PAGE field");
            }
            if (!g_fields_use_PAGE){
                return;
            }
            goto switch_break;
            case_5:
            {
                diagnostics(4, (char*)"starting PAGE_REF field");
            }
            if (!g_fields_use_PAGE_REF){
                return;
            }
            goto switch_break;
            case_6:
            {
                diagnostics(4, (char*)"starting COMMENT field");
            }
            if (!g_fields_use_COMMENT){
                return;
            }
            {
                fprintRTF((char*)"{\\field{\\*\\fldinst{ COMMENTS \" ");
            }
            goto switch_break;
            switch_break:
            ;
        }
        g_field_depth++;
        g_field[g_field_depth] = type;
        if (g_field_depth >= 20){
            {
                diagnostics(0, (char*)"Nesting of fields is excessive!");
            }
        }
        return;
    }
}

void endCurrentField(void)
{
    {
        {
            diagnostics(4, (char*)"end Field");
        }
        if (!g_fields_allowed){
            return;
        }
        if (g_field_depth < 0){
            {
                diagnostics(1, (char*)"oops, looks like fields are too shallow!");
            }
            return;
        }
        {
            if (g_field[g_field_depth] == 1){
                goto case_1;
            }
            if (g_field[g_field_depth] == 2){
                goto case_2;
            }
            if (g_field[g_field_depth] == 3){
                goto case_3;
            }
            if (g_field[g_field_depth] == 4){
                goto case_4;
            }
            if (g_field[g_field_depth] == 5){
                goto case_5;
            }
            if (g_field[g_field_depth] == 6){
                goto case_6;
            }
            goto switch_break;
            case_1:
            if (!g_fields_use_EQ){
                return;
            }
            {
                fprintRTF((char*)"}}{\\fldrslt }}\n");
            }
            goto switch_break;
            case_2:
            if (!g_fields_use_REF){
                return;
            }
            goto switch_break;
            case_3:
            if (!g_fields_use_SYMBOL){
                return;
            }
            goto switch_break;
            case_4:
            if (!g_fields_use_PAGE){
                return;
            }
            goto switch_break;
            case_5:
            if (!g_fields_use_PAGE_REF){
                return;
            }
            goto switch_break;
            case_6:
            if (!g_fields_use_COMMENT){
                return;
            }
            {
                fprintRTF((char*)"\" }}{\\fldrslt }}\n");
            }
            goto switch_break;
            switch_break:
            ;
        }
        g_field_depth--;
        return;
    }
}

void endAllFields(void)
{
    {
        if (!g_fields_allowed){
            return;
        }
        {
            while (1){
                while_continue:
                ;
                if (!(g_field_depth >= 0)){
                    goto while_break;
                }
                {
                    endCurrentField();
                }
            }
            while_break:
            ;
        }
        return;
    }
}

void fprintfRTF_field_separator(void)
{
    {
        {
            fprintRTF((char*)"%c", (int)g_field_separator);
        }
        return;
    }
}

void set_field_separator(char c)
{
    {
        g_field_separator = c;
        return;
    }
}

void set_fields_use_REF(int i)
{
    {
        g_fields_use_REF = i;
        return;
    }
}

int fields_use_REF(void)
{
    {
        return (g_fields_use_REF);
    }
}

void set_fields_use_EQ(int i)
{
    {
        g_fields_use_EQ = i;
        return;
    }
}

int fields_use_EQ(void)
{
    {
        return (g_fields_use_EQ);
    }
}

int processing_fields(void)
{
    {
        if (g_field_depth >= 0){
            return (1);
        }else{
            return (0);
        }
    }
}

int FrenchMode;
int g_processing_preamble;
int g_processing_list_environment;
int getStringDimension(char* s);
int getDimension(void);
char TexModeName[7][25];
void CmdIndent(int code);
void CmdVspace(int code);
void CmdDoubleSpacing(int code);
void CmdNewPage(int code);
void CmdAlign(int code);
void CmdHfill(int code);
void setLeftMarginIndent(int indent___0);
void setRightMarginIndent(int indent___0);
int getLeftMarginIndent(void);
int getRightMarginIndent(void);
void setAlignment(int align);
int getAlignment(void);
int getTexMode(void);
void setTexMode(int mode);
void changeTexMode(int mode);
int getVspace(void);
void Convert(void);
void InsertStyle(const char* the_style___0);
int CurrentFontFamily(void);
void CmdFontShape(int code);
int CurrentFontShape(void);
void CmdFontSeries(int code);
int CurrentFontSeries(void);
int CurrentFontSize(void);
static int g_TeX_mode = 6;
static int g_line_spacing = 240;
static int g_paragraph_no_indent = 0;
static int g_paragraph_inhibit_indent = 0;
static int g_vertical_space_to_add = 0;
static int g_right_margin_indent;
static int g_left_margin_indent;
static int g_page_new = 0;
static int g_column_new = 0;
static int g_alignment = 'j';
static int g_par_brace = 0;
char TexModeName[7][25] = {{(char)'b', (char)'a', (char)'d', (char)'\000'}, {(char)'i', (char)'n', (char)'t', (char)'e', (char)'r', (char)'n', (char)'a', (char)'l', (char)' ', (char)'v', (char)'e', (char)'r', (char)'t', (char)'i', (char)'c', (char)'a', (char)'l', (char)'\000'}, {(char)'h', (char)'o', (char)'r', (char)'i', (char)'z', (char)'o', (char)'n', (char)'t', (char)'a', (char)'l', (char)'\000'}, {(char)'r', (char)'e', (char)'s', (char)'t', (char)'r', (char)'i', (char)'c', (char)'t', (char)'e', (char)'d', (char)' ', (char)'h', (char)'o', (char)'r', (char)'i', (char)'z', (char)'o', (char)'n', (char)'t', (char)'a', (char)'l', (char)'\000'}, {(char)'m', (char)'a', (char)'t', (char)'h', (char)'\000'}, {(char)'d', (char)'i', (char)'s', (char)'p', (char)'l', (char)'a', (char)'y', (char)'m', (char)'a', (char)'t', (char)'h', (char)'\000'}, {(char)'v', (char)'e', (char)'r', (char)'t', (char)'i', (char)'c', (char)'a', (char)'l', (char)'\000'}};
char ParOptionName[4][10] = {{(char)'b', (char)'a', (char)'d', (char)'\000'}, {(char)'F', (char)'I', (char)'R', (char)'S', (char)'T', (char)'\000'}, {(char)'G', (char)'E', (char)'N', (char)'E', (char)'R', (char)'I', (char)'C', (char)'\000'}, {(char)'S', (char)'E', (char)'C', (char)'T', (char)'I', (char)'O', (char)'N', (char)'\000'}};

void setLeftMarginIndent(int indent___0)
{
    {
        g_left_margin_indent = indent___0;
        return;
    }
}

void setRightMarginIndent(int indent___0)
{
    {
        g_right_margin_indent = indent___0;
        return;
    }
}

int getLeftMarginIndent(void)
{
    {
        return (g_left_margin_indent);
    }
}

int getRightMarginIndent(void)
{
    {
        return (g_right_margin_indent);
    }
}

void setAlignment(int align)
{
    {
        g_alignment = align;
        return;
    }
}

int getAlignment(void)
{
    {
        return (g_alignment);
    }
}

void setVspace(int space)
{
    {
        g_vertical_space_to_add = space;
        return;
    }
}

int getVspace(void)
{
    {
        return (g_vertical_space_to_add);
    }
}

static void setLineSpacing(int spacing)
{
    {
        g_line_spacing = spacing;
        return;
    }
}

static int getLineSpacing(void)
{
    {
        return (g_line_spacing);
    }
}

void setTexMode(int mode)
{
    {
        {
            diagnostics(6, (char*)"TeX mode setting from [%s] -> [%s]", TexModeName[g_TeX_mode], TexModeName[mode]);
            g_TeX_mode = mode;
        }
        return;
    }
}

int getTexMode(void)
{
    {
        return (g_TeX_mode);
    }
}

void changeTexMode(int mode)
{
    {
        {
            diagnostics(6, (char*)"TeX mode changing from [%s] -> [%s]", TexModeName[g_TeX_mode], TexModeName[mode]);
        }
        if (g_TeX_mode == 6){
            if (mode == 2){
                {
                    startParagraph("Normal", 2);
                }
            }
        }
        if (g_TeX_mode == 2){
            if (mode == 6){
                {
                    CmdEndParagraph(0);
                }
            }
        }
        g_TeX_mode = mode;
        return;
    }
}

static char last_style[50] = {(char)'N', (char)'o', (char)'r', (char)'m', (char)'a', (char)'l', (char)'\000'};
static char the_style[50] = {(char)'N', (char)'o', (char)'r', (char)'m', (char)'a', (char)'l', (char)'\000'};
static int last_indent = 0;
static int status = 0;

void startParagraph(const char* style___0, int indenting)
{
    int width;
    int a;
    int b;
    int c;
    int parindent;
    int parskip;
    int orig_font_family;
    int tmp;
    int orig_font_size;
    int tmp___0;
    int orig_font_series;
    int tmp___1;
    int orig_font_shape;
    int tmp___2;
    int tmp___3;
    int tmp___4;
    const char* tmp___5;
    const char* tmp___6;
    int tmp___7;
    int tmp___8;
    int tmp___9;
    int tmp___10;
    int tmp___11;
    int tmp___12;
    int tmp___13;
    int tmp___14;
    int tmp___15;
    int tmp___16;
    int tmp___17;
    int tmp___18;
    int tmp___19;
    int tmp___20;
    int tmp___21;
    int tmp___22;
    int tmp___23;
    int tmp___24;
    int tmp___25;
    int tmp___26;
    int tmp___27;
    char* tmp___28;
    char* tmp___29;
    char* tmp___30;
    char* tmp___31;
    {
        {
            tmp = CurrentFontFamily();
            orig_font_family = tmp;
            tmp___0 = CurrentFontSize();
            orig_font_size = tmp___0;
            tmp___1 = CurrentFontSeries();
            orig_font_series = tmp___1;
            tmp___2 = CurrentFontShape();
            orig_font_shape = tmp___2;
            tmp___3 = strcmp(style___0, "last");
        }
        if (tmp___3 == 0){
            {
                diagnostics(4, (char*)"using last style = \'%s\'", last_style);
                indenting = last_indent;
                strcpy((char*)(the_style), (const char*)(last_style));
            }
        }else{
            {
                diagnostics(4, (char*)"using style = \'%s\'", style___0);
                last_indent = indenting;
                strcpy((char*)(last_style), (const char*)style___0);
                strcpy((char*)(the_style), (const char*)style___0);
            }
        }
        {
            parindent = getLength((char*)"parindent");
            parskip = getLength((char*)"parskip");
        }
        if (g_par_brace != 0){
            {
                diagnostics(5, (char*)"******************* starting %s paragraph with braces = %d", style___0, g_par_brace);
            }
        }
        if (g_par_brace == 1){
            {
                CmdEndParagraph(0);
            }
        }
        {
            width = getLength((char*)"textwidth");
            a = (int)(0.45 * (double)width);
            b = (int)(0.50 * (double)width);
            c = (int)(0.55 * (double)width);
        }
        {
            if (indenting == 3){
                goto case_3;
            }
            if (indenting == 1){
                goto case_1;
            }
            if (indenting == 4){
                goto case_4;
            }
            goto switch_default;
            case_3:
            {
                diagnostics(5, (char*)"SECTION_TITLE_PARAGRAPH");
                parindent = 0;
                status = 1;
            }
            goto switch_break;
            case_1:
            {
                diagnostics(5, (char*)"FIRST_PARAGRAPH");
                status = 1;
            }
            if (!FrenchMode){
                if (!g_processing_list_environment){
                    parindent = 0;
                }
            }
            goto switch_break;
            case_4:
            {
                diagnostics(5, (char*)"EQUATION_PARAGRAPH");
                parindent = 0;
            }
            goto switch_break;
            switch_default:
            {
                diagnostics(5, (char*)"GENERIC_PARAGRAPH");
            }
            if (g_paragraph_no_indent){
                parindent = 0;
            }else
                if (g_paragraph_inhibit_indent){
                    parindent = 0;
                }else
                    if (status > 0){
                        parindent = 0;
                    }

            status--;
            goto switch_break;
            switch_break:
            ;
        }
        if (g_processing_preamble){
            {
                diagnostics(5, (char*)"Encountered StartParagraph() in preamble");
            }
            return;
        }
        if (g_par_brace != 0){
            {
                diagnostics(5, (char*)"starting paragraph with braces = %d", g_par_brace);
            }
        }
        {
            g_par_brace++;
            tmp___4 = getTexMode();
            diagnostics(5, (char*)"Paragraph mode    %s", TexModeName[tmp___4]);
            diagnostics(5, (char*)"Paragraph option  %s", ParOptionName[indenting]);
        }
        if (g_paragraph_no_indent){
            tmp___5 = "TRUE";
        }else{
            tmp___5 = "FALSE";
        }
        {
            diagnostics(5, (char*)"Noindent is       %s", tmp___5);
        }
        if (g_paragraph_inhibit_indent){
            tmp___6 = "TRUE";
        }else{
            tmp___6 = "FALSE";
        }
        {
            diagnostics(5, (char*)"Inhibit is        %s", tmp___6);
            diagnostics(5, (char*)"left indent is    %d", g_left_margin_indent);
            diagnostics(5, (char*)"right indent is   %d", g_right_margin_indent);
            tmp___7 = getLength((char*)"parindent");
            diagnostics(5, (char*)"current parindent %d", tmp___7);
            diagnostics(5, (char*)"this parindent    %d", parindent);
            tmp___8 = CurrentFontFamily();
            diagnostics(5, (char*)"current family      %d", tmp___8);
            tmp___9 = CurrentFontSize();
            diagnostics(5, (char*)"current font size   %d", tmp___9);
            tmp___10 = CurrentFontSeries();
            diagnostics(5, (char*)"current font series %d", tmp___10);
            tmp___11 = CurrentFontShape();
            diagnostics(5, (char*)"current font shape  %d", tmp___11);
        }
        if (g_page_new){
            {
                fprintRTF((char*)"\\page\n");
                g_page_new = 0;
                g_column_new = 0;
            }
        }
        if (g_column_new){
            {
                fprintRTF((char*)"\\column\n");
                g_column_new = 0;
            }
        }
        {
            fprintRTF((char*)"\\pard\\plain");
            InsertStyle((const char*)(the_style));
            tmp___12 = strcmp((const char*)(the_style), "equation");
        }
        if (tmp___12 == 0){
            {
                fprintRTF((char*)"\\tqc\\tx%d", b);
            }
        }
        {
            tmp___13 = strcmp((const char*)(the_style), "equationNum");
        }
        if (tmp___13 == 0){
            {
                fprintRTF((char*)"\\tqc\\tx%d\\tqr\\tx%d", b, width);
            }
        }
        {
            tmp___14 = strcmp((const char*)(the_style), "equationAlign");
        }
        if (tmp___14 == 0){
            {
                fprintRTF((char*)"\\tqr\\tx%d\\tql\\tx%d", a, b);
            }
        }
        {
            tmp___15 = strcmp((const char*)(the_style), "equationAlignNum");
        }
        if (tmp___15 == 0){
            {
                fprintRTF((char*)"\\tqr\\tx%d\\tql\\tx%d\\tqr\\tx%d", a, b, width);
            }
        }
        {
            tmp___16 = strcmp((const char*)(the_style), "equationArray");
        }
        if (tmp___16 == 0){
            {
                fprintRTF((char*)"\\tqr\\tx%d\\tqc\\tx%d\\tql\\tx%d", a, b, c);
            }
        }
        {
            tmp___17 = strcmp((const char*)(the_style), "equationArrayNum");
        }
        if (tmp___17 == 0){
            {
                fprintRTF((char*)"\\tqr\\tx%d\\tqc\\tx%d\\tql\\tx%d\\tqr\\tx%d", a, b, c, width);
            }
        }
        {
            tmp___18 = strcmp((const char*)(the_style), "bitmapCenter");
        }
        if (tmp___18 == 0){
            {
                fprintRTF((char*)"\\tqc\\tx%d\\tqr\\tx%d", b, width);
            }
        }
        {
            tmp___20 = strcmp((const char*)(the_style), "acronym");
        }
        if (tmp___20 == 0){
            {
                tmp___19 = acronymHint(width);
                fprintRTF((char*)"\\tx%d\\tqr\\tldot\\tx%d", tmp___19, width);
            }
        }
        {
            tmp___21 = getLineSpacing();
            fprintRTF((char*)"\\sl%i\\slmult1 ", tmp___21);
            tmp___23 = getVspace();
        }
        if (tmp___23 > 0){
            {
                tmp___22 = getVspace();
                fprintRTF((char*)"\\sb%d ", tmp___22);
            }
        }
        {
            setVspace(parskip);
        }
        if (g_left_margin_indent != 0){
            {
                fprintRTF((char*)"\\li%d", g_left_margin_indent);
            }
        }
        if (g_right_margin_indent != 0){
            {
                fprintRTF((char*)"\\ri%d", g_right_margin_indent);
            }
        }
        {
            fprintRTF((char*)"\\fi%d ", parindent);
            tmp___28 = strstr("part", (const char*)(the_style));
        }
        if ((unsigned long )tmp___28 == (unsigned long )((void*)0)){
            {
                tmp___29 = strstr("title", (const char*)(the_style));
            }
            if ((unsigned long )tmp___29 == (unsigned long )((void*)0)){
                {
                    tmp___30 = strstr("chapter", (const char*)(the_style));
                }
                if ((unsigned long )tmp___30 == (unsigned long )((void*)0)){
                    {
                        tmp___31 = strstr("section", (const char*)(the_style));
                    }
                    if ((unsigned long )tmp___31 == (unsigned long )((void*)0)){
                        {
                            tmp___24 = CurrentFontFamily();
                        }
                        if (tmp___24 != orig_font_family){
                            {
                                fprintRTF((char*)"\\f%d ", orig_font_family);
                            }
                        }
                        {
                            tmp___25 = CurrentFontSize();
                        }
                        if (tmp___25 != orig_font_size){
                            {
                                fprintRTF((char*)"\\fs%d ", orig_font_size);
                            }
                        }
                        {
                            tmp___26 = CurrentFontSeries();
                        }
                        if (tmp___26 != orig_font_series){
                            {
                                CmdFontSeries(orig_font_series);
                            }
                        }
                        {
                            tmp___27 = CurrentFontShape();
                        }
                        if (tmp___27 != orig_font_shape){
                            {
                                CmdFontShape(orig_font_shape);
                            }
                        }
                    }
                }
            }
        }
        {
            setTexMode(2);
        }
        if (!g_processing_list_environment){
            g_paragraph_no_indent = 0;
            if (indenting == 3){
                g_paragraph_inhibit_indent = 1;
            }else{
                g_paragraph_inhibit_indent = 0;
            }
        }
        return;
    }
}

void CmdEndParagraph(int code)
{
    int mode;
    int tmp;
    int tmp___0;
    {
        {
            tmp = getTexMode();
            mode = tmp;
            diagnostics(5, (char*)"CmdEndParagraph mode = %s", TexModeName[mode]);
        }
        if (g_par_brace == 1){
            {
                endAllFields();
                fprintRTF((char*)"\\par\n");
                setTexMode(6);
                g_par_brace = 0;
                g_paragraph_inhibit_indent = 0;
            }
        }else{
            {
                tmp___0 = getTexMode();
            }
            if (tmp___0 != 6){
                {
                    diagnostics(5, (char*)"*********************** ending paragraph with braces = %d", g_par_brace);
                }
            }
        }
        return;
    }
}

void CmdHfill(int code)
{
    int tmp;
    {
        {
            tmp = getTexMode();
        }
        if (tmp == 6){
            {
                changeTexMode(2);
            }
        }
        return;
    }
}

void CmdVspace(int code)
{
    int vspace;
    char* s;
    int tmp;
    int tmp___0;
    {
        vspace = 0;
        {
            if (code == -1){
                goto case_neg_1;
            }
            if (code == 0){
                goto case_0;
            }
            if (code == 1){
                goto case_1;
            }
            if (code == 2){
                goto case_2;
            }
            if (code == 3){
                goto case_3;
            }
            goto switch_break;
            case_neg_1:
            {
                s = getBraceParam();
                vspace = getStringDimension(s);
                free((void*)s);
            }
            goto switch_break;
            case_0:
            {
                vspace = getDimension();
                setTexMode(6);
                CmdEndParagraph(0);
            }
            goto switch_break;
            case_1:
            {
                vspace = getLength((char*)"smallskipamount");
            }
            goto switch_break;
            case_2:
            {
                vspace = getLength((char*)"medskipamount");
            }
            goto switch_break;
            case_3:
            {
                vspace = getLength((char*)"bigskipamount");
            }
            goto switch_break;
            switch_break:
            ;
        }
        {
            tmp___0 = getTexMode();
        }
        if (tmp___0 == 6){
            {
                tmp = getVspace();
                setVspace(tmp + vspace);
            }
        }
        return;
    }
}

void CmdIndent(int code)
{
    int tmp;
    {
        {
            tmp = getTexMode();
            diagnostics(5, (char*)"CmdIndent mode = %d", tmp);
        }
        if (code == 1){
            g_paragraph_no_indent = 1;
        }else
            if (code == 2){
                g_paragraph_inhibit_indent = 1;
            }else
                if (code == 3){
                    g_paragraph_no_indent = 0;
                    g_paragraph_inhibit_indent = 0;
                }

        {
            diagnostics(5, (char*)"Noindent is %d", g_paragraph_no_indent);
            diagnostics(5, (char*)"Inhibit  is %d", g_paragraph_inhibit_indent);
        }
        return;
    }
}

void CmdNewPage(int code)
{
    int tmp;
    {
        {
            tmp = getTexMode();
            diagnostics(5, (char*)"CmdNewPage mode = %d", tmp);
        }
        {
            if (code == 1){
                goto case_1;
            }
            if (code == 2){
                goto case_2;
            }
            goto switch_break;
            case_1:
            g_page_new = 1;
            goto switch_break;
            case_2:
            g_column_new = 1;
            goto switch_break;
            switch_break:
            ;
        }
        return;
    }
}

void CmdDoubleSpacing(int code)
{
    {
        {
            setLineSpacing(480);
        }
        return;
    }
}

static char old_alignment_before_center = (char)'j';
static char old_alignment_before_right = (char)'j';
static char old_alignment_before_left = (char)'j';
static char old_alignment_before_centerline = (char)'j';

void CmdAlign(int code)
{
    char* s;
    int restart_field;
    int tmp;
    int tmp___0;
    int tmp___1;
    int tmp___2;
    int tmp___3;
    int tmp___4;
    int tmp___5;
    {
        if (code == 5){
            {
                restart_field = 0;
                tmp = EQ_field_active();
            }
            if (tmp){
                {
                    diagnostics(4, (char*)"ending field due to \\vcenter");
                    restart_field = 1;
                    endCurrentField();
                }
            }
            {
                s = getBraceParam();
                ConvertString((const char*)s);
                free((void*)s);
            }
            if (restart_field){
                {
                    startField(1);
                }
            }
            return;
        }
        {
            CmdEndParagraph(0);
        }
        {
            if (code == 4){
                goto case_4;
            }
            if (code == 6){
                goto case_6;
            }
            if (code == 16385){
                goto case_16385;
            }
            if (code == 1){
                goto case_1;
            }
            if (code == 16386){
                goto case_16386;
            }
            if (code == 2){
                goto case_2;
            }
            if (code == 16387){
                goto case_16387;
            }
            if (code == 3){
                goto case_3;
            }
            if (code == 7){
                goto case_7;
            }
            goto switch_break;
            case_4:
            {
                tmp___0 = getAlignment();
                old_alignment_before_centerline = (char)tmp___0;
                setAlignment('c');
                fprintRTF((char*)"{");
                diagnostics(4, (char*)"Entering Convert from CmdAlign (centerline)");
                Convert();
                diagnostics(4, (char*)"Exiting Convert from CmdAlign (centerline)");
                setAlignment((int)old_alignment_before_centerline);
                CmdEndParagraph(0);
                fprintRTF((char*)"}");
            }
            goto switch_break;
            case_6:
            {
                tmp___1 = getAlignment();
                old_alignment_before_centerline = (char)tmp___1;
                setAlignment('l');
                diagnostics(4, (char*)"Entering Convert from CmdAlign (raggedright)");
                Convert();
                diagnostics(4, (char*)"Exiting Convert from CmdAlign (raggedright)");
                setAlignment((int)old_alignment_before_centerline);
                CmdEndParagraph(0);
            }
            goto switch_break;
            case_16385:
            {
                CmdIndent(1);
                tmp___2 = getAlignment();
                old_alignment_before_center = (char)tmp___2;
                setAlignment('c');
            }
            goto switch_break;
            case_1:
            {
                setAlignment((int)old_alignment_before_center);
                CmdEndParagraph(0);
                CmdIndent(2);
            }
            goto switch_break;
            case_16386:
            {
                tmp___3 = getAlignment();
                old_alignment_before_right = (char)tmp___3;
                setAlignment('r');
                CmdIndent(1);
            }
            goto switch_break;
            case_2:
            {
                setAlignment((int)old_alignment_before_right);
                CmdIndent(2);
            }
            goto switch_break;
            case_16387:
            {
                tmp___4 = getAlignment();
                old_alignment_before_left = (char)tmp___4;
                setAlignment('l');
                CmdIndent(1);
            }
            goto switch_break;
            case_3:
            {
                setAlignment((int)old_alignment_before_left);
                CmdIndent(2);
            }
            goto switch_break;
            case_7:
            {
                CmdIndent(1);
                tmp___5 = getAlignment();
                old_alignment_before_center = (char)tmp___5;
                setAlignment('c');
            }
            goto switch_break;
            switch_break:
            ;
        }
        return;
    }
}

extern void* (memmove)(void* __dest, const void* __src, size_t __n);
extern int (strncmp)(const char* __s1, const char* __s2, size_t __n);
extern const unsigned short **(__ctype_b_loc)(void);
void preParse(char** body, char** header, char** label);
int odd(long  n);
int even(long  n);
char* strdup_together4(const char* s, const char* t, const char* u, const char* v);
char* strdup_nobadchars(const char* text);
int maybeDefinition(char* s, size_t n);
int existsDefinition(char* s);
char* expandDefinition(int thedef);
int maybeEnvironment(char* s, size_t n);
int existsEnvironment(char* s);
char* expandEnvironment(int thedef, int code);
char getRawTexChar(void);
char getNonSpace(void);
void ungetTexChar(char c);
void CmdInclude(int code);
void PushTrackLineNumber(int flag);
void PopTrackLineNumber(void);
int getParserDepth(void);
void CmdNewDef(int code);
static char* section_buffer = (char*)((void*)0);
static long section_buffer_size = 2048L;
static long section_buffer_end = 0L;

static void increase_buffer_size(void)
{
    char* new_section_buffer;
    void* tmp;
    {
        {
            tmp = malloc((size_t)(2L * section_buffer_size + 1L));
            new_section_buffer = (char*)tmp;
        }
        if ((unsigned long )new_section_buffer == (unsigned long )((void*)0)){
            {
                diagnostics(0, (char*)"Could not allocate enough memory to process file. Sorry.");
            }
        }
        {
            memmove((void*)new_section_buffer, (const void*)section_buffer, (size_t)section_buffer_size);
            section_buffer_size *= 2L;
            free((void*)section_buffer);
            section_buffer = new_section_buffer;
            diagnostics(4, (char*)"Expanded buffer size is now %ld", section_buffer_size);
        }
        return;
    }
}

static void add_chr_to_buffer(char c)
{
    void* tmp;
    {
        if ((unsigned long )section_buffer == (unsigned long )((void*)0)){
            {
                tmp = malloc((size_t)(section_buffer_size + 1L));
                section_buffer = (char*)tmp;
            }
            if ((unsigned long )section_buffer == (unsigned long )((void*)0)){
                {
                    diagnostics(0, (char*)"Could not allocate enough memory to process file. Sorry.");
                }
            }
        }
        section_buffer_end++;
        *(section_buffer + section_buffer_end) = c;
        if (section_buffer_end + 2L >= section_buffer_size){
            {
                increase_buffer_size();
            }
        }
        return;
    }
}

static void add_str_to_buffer(const char* s)
{
    {
        {
            while (1){
                while_continue:
                ;
                if (s){
                    if (!*s){
                        goto while_break;
                    }
                }else{
                    goto while_break;
                }
                {
                    add_chr_to_buffer((char)*s);
                    s++;
                }
            }
            while_break:
            ;
        }
        return;
    }
}

static int matches_buffer_tail(const char* s)
{
    long len;
    size_t tmp;
    int tmp___0;
    {
        if ((unsigned long )s == (unsigned long )((void*)0)){
            return (0);
        }
        {
            tmp = strlen(s);
            len = (long )tmp;
        }
        if (len > section_buffer_end + 1L){
            return (0);
        }
        {
            tmp___0 = strncmp(s, (const char*)((section_buffer + section_buffer_end) - len), (size_t)len);
        }
        if (tmp___0 == 0){
            return (1);
        }else{
            return (0);
        }
    }
}

static void reset_buffer(void)
{
    {
        section_buffer_end = -1L;
        return;
    }
}

static void move_end_of_buffer(long  n)
{
    {
        section_buffer_end += n;
        return;
    }
}

void preParse(char** body, char** header, char** label)
{
    int any_possible_match;
    int found;
    char cNext;
    char cThis;
    char* s;
    char* text;
    char* next_header;
    char* str;
    char* p;
    int i;
    int possible_match[43];
    char* command[43];
    int ncommands;
    int b_verbatim_item;
    int b_figure_item;
    int b_figure_item2;
    int b_equation_item;
    int b_equation_item2;
    int b_eqnarray_item;
    int b_eqnarray_item2;
    int b_table_item;
    int b_table_item2;
    int b_description_item;
    int b_comment_item;
    int e_verbatim_item;
    int e_figure_item;
    int e_figure_item2;
    int e_equation_item;
    int e_equation_item2;
    int e_eqnarray_item;
    int e_eqnarray_item2;
    int e_table_item;
    int e_table_item2;
    int e_description_item;
    int e_comment_item;
    int label_item;
    int input_item;
    int include_item;
    int verb_item;
    int url_item;
    int nolinkurl_item;
    int new_item;
    int def_item;
    int renew_item;
    int endinput_item;
    int e_document_item;
    int bs_count;
    size_t cmd_pos;
    int label_depth;
    int i_match;
    int tmp;
    int tmp___0;
    int n;
    int tmp___1;
    int tmp___2;
    int tmp___3;
    int tmp___4;
    int tmp___5;
    int tmp___6;
    const unsigned short **tmp___7;
    char* pp;
    char* ss;
    size_t tmp___8;
    size_t tmp___9;
    size_t tmp___10;
    const unsigned short **tmp___11;
    size_t tmp___12;
    size_t tmp___13;
    char cc;
    char cc___0;
    size_t tmp___14;
    size_t tmp___15;
    char* tag;
    size_t tmp___16;
    const unsigned short **tmp___17;
    size_t tmp___18;
    size_t tmp___19;
    {
        {
            command[0] = (char*)"";
            command[1] = (char*)"";
            command[2] = (char*)"\\begin{verbatim}";
            command[3] = (char*)"\\begin{figure}";
            command[4] = (char*)"\\begin{figure*}";
            command[5] = (char*)"\\begin{equation}";
            command[6] = (char*)"\\begin{equation*}";
            command[7] = (char*)"\\begin{eqnarray}";
            command[8] = (char*)"\\begin{eqnarray*}";
            command[9] = (char*)"\\begin{table}";
            command[10] = (char*)"\\begin{table*}";
            command[11] = (char*)"\\begin{description}";
            command[12] = (char*)"\\begin{comment}";
            command[13] = (char*)"\\end{verbatim}";
            command[14] = (char*)"\\end{figure}";
            command[15] = (char*)"\\end{figure*}";
            command[16] = (char*)"\\end{equation}";
            command[17] = (char*)"\\end{equation*}";
            command[18] = (char*)"\\end{eqnarray}";
            command[19] = (char*)"\\end{eqnarray*}";
            command[20] = (char*)"\\end{table}";
            command[21] = (char*)"\\end{table*}";
            command[22] = (char*)"\\end{description}";
            command[23] = (char*)"\\end{comment}";
            command[24] = (char*)"\\part";
            command[25] = (char*)"\\chapter";
            command[26] = (char*)"\\section";
            command[27] = (char*)"\\subsection";
            command[28] = (char*)"\\subsubsection";
            command[29] = (char*)"\\section*";
            command[30] = (char*)"\\subsection*";
            command[31] = (char*)"\\subsubsection*";
            command[32] = (char*)"\\label";
            command[33] = (char*)"\\input";
            command[34] = (char*)"\\include";
            command[35] = (char*)"\\verb";
            command[36] = (char*)"\\url";
            command[37] = (char*)"\\nolinkurl";
            command[38] = (char*)"\\newcommand";
            command[39] = (char*)"\\def";
            command[40] = (char*)"\\renewcommand";
            command[41] = (char*)"\\endinput";
            command[42] = (char*)"\\end{document}";
            ncommands = 43;
            b_verbatim_item = 2;
            b_figure_item = 3;
            b_figure_item2 = 4;
            b_equation_item = 5;
            b_equation_item2 = 6;
            b_eqnarray_item = 7;
            b_eqnarray_item2 = 8;
            b_table_item = 9;
            b_table_item2 = 10;
            b_description_item = 11;
            b_comment_item = 12;
            e_verbatim_item = 13;
            e_figure_item = 14;
            e_figure_item2 = 15;
            e_equation_item = 16;
            e_equation_item2 = 17;
            e_eqnarray_item = 18;
            e_eqnarray_item2 = 19;
            e_table_item = 20;
            e_table_item2 = 21;
            e_description_item = 22;
            e_comment_item = 23;
            label_item = 32;
            input_item = 33;
            include_item = 34;
            verb_item = 35;
            url_item = 36;
            nolinkurl_item = 37;
            new_item = 38;
            def_item = 39;
            renew_item = 40;
            endinput_item = 41;
            e_document_item = 42;
            bs_count = 0;
            cmd_pos = (size_t)0;
            label_depth = 0;
            i_match = 0;
            text = (char*)((void*)0);
            next_header = (char*)((void*)0);
            *body = (char*)((void*)0);
            *header = (char*)((void*)0);
            *label = (char*)((void*)0);
            PushTrackLineNumber(0);
            reset_buffer();
        }
        {
            while (1){
                while_continue:
                ;
                {
                    cThis = getRawTexChar();
                }
                {
                    while (1){
                        while_continue___0:
                        ;
                        if ((int)cThis == 0){
                            {
                                tmp___0 = getParserDepth();
                            }
                            if (!(tmp___0 > 0)){
                                goto while_break___0;
                            }
                        }else{
                            goto while_break___0;
                        }
                        {
                            PopSource();
                            tmp = getParserDepth();
                            diagnostics(4, (char*)"parser depth is now %d", tmp);
                            cThis = getRawTexChar();
                        }
                    }
                    while_break___0:
                    ;
                }
                if ((int)cThis == 0){
                    {
                        diagnostics(6, (char*)"[%ld] xchar=000 \'\\0\' (backslash count=%d)", section_buffer_end, bs_count);
                    }
                }else
                    if ((int)cThis == 10){
                        {
                            diagnostics(6, (char*)"[%ld] xchar=012 \'\\n\' (backslash count=%d)", section_buffer_end, bs_count);
                        }
                    }else{
                        {
                            diagnostics(6, (char*)"[%ld] xchar=%03d \'%c\' (backslash count=%d)", section_buffer_end, (int)cThis, (int)cThis, bs_count);
                        }
                    }

                {
                    add_chr_to_buffer(cThis);
                }
                if ((int)cThis == 0){
                    goto while_break;
                }
                if ((int)cThis == 37){
                    {
                        tmp___1 = even((long )bs_count);
                    }
                    if (tmp___1){
                        n = 1;
                        {
                            while (1){
                                while_continue___1:
                                ;
                                {
                                    cNext = getRawTexChar();
                                    add_chr_to_buffer(cNext);
                                    n++;
                                }
                                if ((int)cNext != 10){
                                    if (!((int)cNext != 0)){
                                        goto while_break___1;
                                    }
                                }else{
                                    goto while_break___1;
                                }
                            }
                            while_break___1:
                            ;
                        }
                        {
                            move_end_of_buffer((long )(-n));
                        }
                        goto while_continue;
                    }
                }
                if ((int)cThis == 92){
                    {
                        bs_count++;
                        tmp___2 = odd((long )bs_count);
                    }
                    if (tmp___2){
                        i = 0;
                        {
                            while (1){
                                while_continue___2:
                                ;
                                if (!(i < ncommands)){
                                    goto while_break___2;
                                }
                                possible_match[i] = 1;
                                i++;
                            }
                            while_break___2:
                            ;
                        }
                        cmd_pos = (size_t)1;
                        goto while_continue;
                    }
                }else{
                    bs_count = 0;
                }
                if (cmd_pos == 0UL){
                    goto while_continue;
                }
                if (cmd_pos == 1UL){
                    if ((int)cThis == 10){
                        {
                            move_end_of_buffer(-1L);
                            add_chr_to_buffer((char)' ');
                            cmd_pos = (size_t)0;
                        }
                        goto while_continue;
                    }else
                        if ((int)cThis == 32){
                            {
                                move_end_of_buffer(-1L);
                                add_chr_to_buffer((char)' ');
                                cmd_pos = (size_t)0;
                            }
                            goto while_continue;
                        }
                }
                if ((int)cThis == 32){
                    {
                        tmp___3 = matches_buffer_tail("\\begin");
                    }
                    if (tmp___3){
                        goto _L;
                    }else{
                        {
                            tmp___4 = matches_buffer_tail("\\end");
                        }
                        if (tmp___4){
                            _L:
                            {
                                diagnostics(5, (char*)"matched \'\\begin \' or \'\\end \'");
                            }
                            {
                                while (1){
                                    while_continue___3:
                                    ;
                                    {
                                        cThis = getRawTexChar();
                                    }
                                    if (!((int)cThis == 32)){
                                        goto while_break___3;
                                    }
                                }
                                while_break___3:
                                ;
                            }
                        }
                    }
                }
                if ((int)cThis == 32){
                    {
                        tmp___5 = matches_buffer_tail("\\begin{");
                    }
                    if (tmp___5){
                        goto _L___0;
                    }else{
                        {
                            tmp___6 = matches_buffer_tail("\\end{");
                        }
                        if (tmp___6){
                            _L___0:
                            {
                                diagnostics(5, (char*)"matched \'\\begin{ \' or \'\\end{ \'");
                            }
                            {
                                while (1){
                                    while_continue___4:
                                    ;
                                    {
                                        cThis = getRawTexChar();
                                    }
                                    if (!((int)cThis == 32)){
                                        goto while_break___4;
                                    }
                                }
                                while_break___4:
                                ;
                            }
                        }
                    }
                }
                any_possible_match = 0;
                found = 0;
                if (possible_match[0]){
                    {
                        possible_match[0] = maybeDefinition(((section_buffer + section_buffer_end) - cmd_pos) + 1, cmd_pos - 1UL);
                    }
                    if (possible_match[0]){
                        {
                            any_possible_match = 1;
                            cNext = getRawTexChar();
                            ungetTexChar(cNext);
                            tmp___7 = __ctype_b_loc();
                        }
                        if (!((const int)*(*tmp___7 + (int)cNext) & 1024)){
                            {
                                *((section_buffer + section_buffer_end) + 1) = (char)'\000';
                                i = existsDefinition(((section_buffer + section_buffer_end) - cmd_pos) + 1);
                            }
                            if (i > -1){
                                {
                                    diagnostics(4, (char*)"matched <%s> ", (section_buffer + section_buffer_end) - cmd_pos);
                                }
                                if ((int)cNext == 32){
                                    {
                                        cNext = getNonSpace();
                                        ungetTexChar(cNext);
                                    }
                                }
                                {
                                    move_end_of_buffer((long )(-cmd_pos - 1UL));
                                    str = expandDefinition(i);
                                    PushSource((const char*)((void*)0), (const char*)str);
                                    free((void*)str);
                                    cmd_pos = (size_t)0;
                                    bs_count = 0;
                                }
                                goto while_continue;
                            }
                        }
                    }
                }
                if (possible_match[1]){
                    {
                        pp = (section_buffer + section_buffer_end) - cmd_pos;
                        possible_match[1] = maybeEnvironment(pp, cmd_pos);
                    }
                    if (possible_match[1] == 1){
                        {
                            any_possible_match = 1;
                            cNext = getRawTexChar();
                        }
                        if ((int)cNext == 125){
                            ss = (char*)((void*)0);
                            *((pp + cmd_pos) + 1) = (char)'\000';
                            if ((int)*(pp + 1) == 101){
                                {
                                    tmp___8 = strlen("\\end{");
                                    i = existsEnvironment(pp + tmp___8);
                                    ss = expandEnvironment(i, 2);
                                }
                            }else{
                                {
                                    tmp___9 = strlen("\\begin{");
                                    i = existsEnvironment(pp + tmp___9);
                                    ss = expandEnvironment(i, 1);
                                }
                            }
                            if (ss){
                                {
                                    diagnostics(5, (char*)"matched <%s}>", pp);
                                    diagnostics(5, (char*)"expanded to <%s>", ss);
                                    PushSource((const char*)((void*)0), (const char*)ss);
                                    move_end_of_buffer((long )(-cmd_pos - 1UL));
                                    free((void*)ss);
                                    cmd_pos = (size_t)0;
                                }
                                goto while_continue;
                            }
                        }
                        {
                            ungetTexChar(cNext);
                        }
                    }
                }
                i = 2;
                {
                    while (1){
                        while_continue___5:
                        ;
                        if (!(i < ncommands)){
                            goto while_break___5;
                        }
                        if (possible_match[i]){
                            if ((int)cThis == (int)*(command[i] + cmd_pos)){
                                any_possible_match = 1;
                            }else{
                                possible_match[i] = 0;
                            }
                            {
                                tmp___10 = strlen((const char*)command[i]);
                                diagnostics(6, (char*)"cmd_pos = %d, char = %c, possible match %s, size=%d, possible=%d", cmd_pos, (int)cThis, command[i], tmp___10, possible_match[i]);
                            }
                        }
                        i++;
                    }
                    while_break___5:
                    ;
                }
                i_match = -1;
                i = 2;
                {
                    while (1){
                        while_continue___6:
                        ;
                        if (!(i < ncommands)){
                            goto while_break___6;
                        }
                        if (possible_match[i]){
                            {
                                diagnostics(6, (char*)"testing for <%s>", command[i]);
                                tmp___12 = strlen((const char*)command[i]);
                            }
                            if (cmd_pos + 1UL == tmp___12){
                                if (i <= e_comment_item){
                                    found = 1;
                                }else
                                    if (i == e_comment_item){
                                        found = 1;
                                    }else{
                                        {
                                            cNext = getRawTexChar();
                                            ungetTexChar(cNext);
                                            tmp___11 = __ctype_b_loc();
                                        }
                                        if (!((const int)*(*tmp___11 + (int)cNext) & 1024)){
                                            if ((int)cNext != 42){
                                                found = 1;
                                            }
                                        }
                                    }
                            }
                        }
                        if (found == 1){
                            {
                                diagnostics(6, (char*)"preparse matched \'%s\'", command[i]);
                                i_match = i;
                            }
                            goto while_break___6;
                        }
                        i++;
                    }
                    while_break___6:
                    ;
                }
                if (any_possible_match){
                    cmd_pos++;
                }else{
                    cmd_pos = (size_t)0;
                }
                if (!found){
                    goto while_continue;
                }
                if (i_match == endinput_item){
                    {
                        diagnostics(6, (char*)"\\endinput");
                        move_end_of_buffer(-9L);
                        PopSource();
                        cmd_pos = (size_t)0;
                    }
                    goto while_continue;
                }
                if (i_match == e_document_item){
                    {
                        diagnostics(6, (char*)"\\end{document}");
                        tmp___13 = strlen((const char*)command[e_document_item]);
                        move_end_of_buffer((long )(-tmp___13));
                        add_chr_to_buffer((char)'\000');
                        safe_free(*header);
                        *header = strdup((const char*)command[e_document_item]);
                        p = section_buffer;
                    }
                    {
                        while (1){
                            while_continue___7:
                            ;
                            if (!((int)*p == 32)){
                                if (!((int)*p == 10)){
                                    goto while_break___7;
                                }
                            }
                            p++;
                        }
                        while_break___7:
                        ;
                    }
                    {
                        *body = strdup((const char*)p);
                        PopTrackLineNumber();
                        diagnostics(6, (char*)"body = %s", section_buffer);
                        diagnostics(6, (char*)"next header = \'%s\'", command[e_document_item]);
                    }
                    return;
                }
                if (i_match == verb_item){
                    {
                        cNext = getRawTexChar();
                        add_chr_to_buffer(cNext);
                        diagnostics(6, (char*)"verb char = %c", (int)cNext);
                    }
                    {
                        while (1){
                            while_continue___8:
                            ;
                            {
                                cc = getRawTexChar();
                                add_chr_to_buffer(cc);
                            }
                            if ((int)cc != (int)cNext){
                                if (!((int)cc != 0)){
                                    goto while_break___8;
                                }
                            }else{
                                goto while_break___8;
                            }
                        }
                        while_break___8:
                        ;
                    }
                    cmd_pos = (size_t)0;
                    goto while_continue;
                }
                if (i_match == url_item){
                    goto _L___1;
                }else
                    if (i_match == nolinkurl_item){
                        _L___1:
                        {
                            while (1){
                                while_continue___9:
                                ;
                                {
                                    cc___0 = getRawTexChar();
                                    add_chr_to_buffer(cc___0);
                                }
                                if ((int)cc___0 != 0){
                                    if (!((int)cc___0 != 125)){
                                        goto while_break___9;
                                    }
                                }else{
                                    goto while_break___9;
                                }
                            }
                            while_break___9:
                            ;
                        }
                        cmd_pos = (size_t)0;
                        goto while_continue;
                    }

                if (i_match == include_item){
                    {
                        CmdInclude(0);
                        tmp___14 = strlen((const char*)command[i]);
                        move_end_of_buffer((long )(-tmp___14));
                        cmd_pos = (size_t)0;
                    }
                    goto while_continue;
                }
                if (i_match == input_item){
                    {
                        CmdInclude(1);
                        tmp___15 = strlen((const char*)command[i]);
                        move_end_of_buffer((long )(-tmp___15));
                        cmd_pos = (size_t)0;
                    }
                    goto while_continue;
                }
                if (i_match == label_item){
                    {
                        tag = getBraceParam();
                        add_chr_to_buffer((char)'{');
                        add_str_to_buffer((const char*)tag);
                        add_chr_to_buffer((char)'}');
                    }
                    if (!*label){
                        {
                            tmp___16 = strlen((const char*)tag);
                        }
                        if (tmp___16){
                            if (label_depth == 0){
                                {
                                    *label = strdup_nobadchars((const char*)tag);
                                }
                            }
                        }
                    }
                    {
                        free((void*)tag);
                        cmd_pos = (size_t)0;
                    }
                    goto while_continue;
                }
                if (i_match == def_item){
                    goto _L___2;
                }else
                    if (i_match == new_item){
                        goto _L___2;
                    }else
                        if (i_match == renew_item){
                            _L___2:
                            {
                                cNext = getRawTexChar();
                                ungetTexChar(cNext);
                                tmp___17 = __ctype_b_loc();
                            }
                            if ((const int)*(*tmp___17 + (int)cNext) & 1024){
                                goto while_continue;
                            }
                            {
                                tmp___18 = strlen((const char*)command[i]);
                                move_end_of_buffer((long )(-tmp___18));
                            }
                            if (i_match == def_item){
                                {
                                    CmdNewDef(3);
                                }
                            }else
                                if (i_match == new_item){
                                    {
                                        CmdNewDef(1);
                                    }
                                }else{
                                    {
                                        CmdNewDef(2);
                                    }
                                }

                            cmd_pos = (size_t)0;
                            goto while_continue;
                        }

                if (i_match == b_figure_item){
                    label_depth++;
                    cmd_pos = (size_t)0;
                    goto while_continue;
                }else
                    if (i_match == b_figure_item2){
                        label_depth++;
                        cmd_pos = (size_t)0;
                        goto while_continue;
                    }else
                        if (i_match == b_equation_item){
                            label_depth++;
                            cmd_pos = (size_t)0;
                            goto while_continue;
                        }else
                            if (i_match == b_equation_item2){
                                label_depth++;
                                cmd_pos = (size_t)0;
                                goto while_continue;
                            }else
                                if (i_match == b_eqnarray_item){
                                    label_depth++;
                                    cmd_pos = (size_t)0;
                                    goto while_continue;
                                }else
                                    if (i_match == b_eqnarray_item2){
                                        label_depth++;
                                        cmd_pos = (size_t)0;
                                        goto while_continue;
                                    }else
                                        if (i_match == b_table_item){
                                            label_depth++;
                                            cmd_pos = (size_t)0;
                                            goto while_continue;
                                        }else
                                            if (i_match == b_table_item2){
                                                label_depth++;
                                                cmd_pos = (size_t)0;
                                                goto while_continue;
                                            }else
                                                if (i_match == b_description_item){
                                                    label_depth++;
                                                    cmd_pos = (size_t)0;
                                                    goto while_continue;
                                                }

                if (i_match == e_figure_item){
                    label_depth--;
                    cmd_pos = (size_t)0;
                    goto while_continue;
                }else
                    if (i_match == e_figure_item2){
                        label_depth--;
                        cmd_pos = (size_t)0;
                        goto while_continue;
                    }else
                        if (i_match == e_equation_item){
                            label_depth--;
                            cmd_pos = (size_t)0;
                            goto while_continue;
                        }else
                            if (i_match == e_equation_item2){
                                label_depth--;
                                cmd_pos = (size_t)0;
                                goto while_continue;
                            }else
                                if (i_match == e_eqnarray_item){
                                    label_depth--;
                                    cmd_pos = (size_t)0;
                                    goto while_continue;
                                }else
                                    if (i_match == e_eqnarray_item2){
                                        label_depth--;
                                        cmd_pos = (size_t)0;
                                        goto while_continue;
                                    }else
                                        if (i_match == e_table_item){
                                            label_depth--;
                                            cmd_pos = (size_t)0;
                                            goto while_continue;
                                        }else
                                            if (i_match == e_table_item2){
                                                label_depth--;
                                                cmd_pos = (size_t)0;
                                                goto while_continue;
                                            }else
                                                if (i_match == e_description_item){
                                                    label_depth--;
                                                    cmd_pos = (size_t)0;
                                                    goto while_continue;
                                                }

                if (i_match == b_verbatim_item){
                    {
                        s = getTexUntil(command[e_verbatim_item], 1);
                        add_str_to_buffer((const char*)s);
                        free((void*)s);
                        add_str_to_buffer((const char*)command[e_verbatim_item]);
                        diagnostics(4, (char*)"matched \\end{verbatim}");
                        cmd_pos = (size_t)0;
                    }
                    goto while_continue;
                }
                if (i_match == b_comment_item){
                    {
                        s = getTexUntil(command[e_comment_item], 1);
                        add_str_to_buffer((const char*)s);
                        free((void*)s);
                        add_str_to_buffer((const char*)command[e_comment_item]);
                        cmd_pos = (size_t)0;
                    }
                    goto while_continue;
                }
                {
                    diagnostics(4, (char*)"possible end of section");
                    diagnostics(4, (char*)"label_depth = %d", label_depth);
                }
                if (label_depth > 0){
                    goto while_continue;
                }
                {
                    diagnostics(4, (char*)"preParse() found command to end section");
                    s = getBraceParam();
                    next_header = strdup_together4((const char*)command[i], "{", (const char*)s, "}");
                    free((void*)s);
                    tmp___19 = strlen((const char*)command[i]);
                    move_end_of_buffer((long )(-tmp___19));
                    add_chr_to_buffer((char)'\000');
                }
                goto while_break;
            }
            while_break:
            ;
        }
        p = section_buffer;
        {
            while (1){
                while_continue___10:
                ;
                if (!((int)*p == 32)){
                    if (!((int)*p == 10)){
                        goto while_break___10;
                    }
                }
                p++;
            }
            while_break___10:
            ;
        }
        {
            *body = strdup((const char*)p);
            safe_free(*header);
            *header = next_header;
            PopTrackLineNumber();
        }
        return;
    }
}

void WriteCFGFontNumber(char** cfg_stream);
char* SearchCfgRtf(const char* theTexCommand, int WhichCfg);
void InsertBasicStyle(const char* rtf, int how);
void SetCurrentStyle(const char* style___0);
char* GetCurrentStyle(void);
int IsSameAsCurrentStyle(const char* s);
void InsertCurrentStyle(void);
static char* g_current_style = (char*)((void*)0);

void SetCurrentStyle(const char* style___0)
{
    {
        if (g_current_style){
            {
                free((void*)g_current_style);
            }
        }
        {
            g_current_style = strdup(style___0);
        }
        return;
    }
}

char* GetCurrentStyle(void)
{
    {
        return (g_current_style);
    }
}

int IsSameAsCurrentStyle(const char* s)
{
    int tmp;
    {
        if ((unsigned long )g_current_style == (unsigned long )((void*)0)){
            return (0);
        }
        {
            tmp = strcmp(s, (const char*)g_current_style);
        }
        if (tmp == 0){
            return (1);
        }else{
            return (0);
        }
    }
}

void InsertCurrentStyle(void)
{
    {
        if ((unsigned long )g_current_style == (unsigned long )((void*)0)){
            {
                InsertStyle("Normal");
            }
        }else{
            {
                InsertStyle((const char*)g_current_style);
            }
        }
        return;
    }
}

void InsertBasicStyle(const char* rtf, int how)
{
    char* style___0;
    char* comma;
    char* style_end;
    char* tmp;
    size_t tmp___0;
    int tmp___1;
    {
        style_end = (char*)((void*)0);
        if ((unsigned long )rtf == (unsigned long )((void*)0)){
            return;
        }
        {
            tmp = strchr((const char*)((char*)rtf), ',');
            style___0 = tmp + 1;
        }
        if ((unsigned long )style___0 == (unsigned long )((void*)0)){
            return;
        }
        {
            style___0 = strchr((const char*)(style___0 + 1), ',');
        }
        if ((unsigned long )style___0 == (unsigned long )((void*)0)){
            return;
        }
        style___0++;
        {
            while (1){
                while_continue:
                ;
                if (!((int)*style___0 == 32)){
                    goto while_break;
                }
                style___0++;
            }
            while_break:
            ;
        }
        {
            comma = strchr((const char*)style___0, ',');
        }
        if ((unsigned long )comma == (unsigned long )((void*)0)){
            return;
        }
        {
            if (how == 1){
                goto case_1;
            }
            if (how == 2){
                goto case_2;
            }
            if (how == 3){
                goto case_3;
            }
            goto switch_break;
            case_1:
            style_end = comma;
            goto switch_break;
            case_2:
            {
                tmp___0 = strlen((const char*)style___0);
                style_end = style___0 + tmp___0;
            }
            goto switch_break;
            case_3:
            {
                tmp___1 = strstarts((const char*)style___0, "\\s");
            }
            if (tmp___1){
                style___0 += 2;
                {
                    while (1){
                        while_continue___0:
                        ;
                        if ((int)*style___0 >= 48){
                            if (!((int)*style___0 <= 57)){
                                goto while_break___0;
                            }
                        }else{
                            goto while_break___0;
                        }
                        style___0++;
                    }
                    while_break___0:
                    ;
                }
            }
            style_end = comma;
            goto switch_break;
            switch_break:
            ;
        }
        {
            while (1){
                while_continue___1:
                ;
                if (!((unsigned long )style___0 < (unsigned long )style_end)){
                    goto while_break___1;
                }
                if ((unsigned long )style___0 == (unsigned long )comma){
                    {
                        fprintRTF((char*)" ");
                    }
                }else
                    if ((int)*style___0 == 42){
                        {
                            WriteCFGFontNumber(&style___0);
                        }
                    }else{
                        {
                            fprintRTF((char*)"%c", (int)*style___0);
                        }
                    }

                style___0++;
            }
            while_break___1:
            ;
        }
        return;
    }
}

void InsertStyle(const char* the_style___0)
{
    char* rtf;
    char* last_char;
    int how;
    char* style___0;
    char* tmp;
    size_t tmp___0;
    int tmp___1;
    int tmp___2;
    int tmp___3;
    int tmp___4;
    {
        {
            how = 1;
            tmp = strdup(the_style___0);
            style___0 = tmp;
            tmp___0 = strlen((const char*)style___0);
            last_char = (style___0 + tmp___0) - 1;
        }
        if ((int)*last_char == 48){
            how = 3;
            *last_char = (char)'\000';
        }
        {
            tmp___4 = strcmp((const char*)style___0, "Normal");
        }
        if (tmp___4 == 0){
            {
                tmp___1 = getAlignment();
            }
            if (tmp___1 == 99){
                {
                    InsertStyle("centerpar");
                    free((void*)style___0);
                }
                return;
            }
            {
                tmp___2 = getAlignment();
            }
            if (tmp___2 == 114){
                {
                    InsertStyle("rightpar");
                    free((void*)style___0);
                }
                return;
            }
            {
                tmp___3 = getAlignment();
            }
            if (tmp___3 == 108){
                {
                    InsertStyle("leftpar");
                    free((void*)style___0);
                }
                return;
            }
        }
        {
            diagnostics(4, (char*)"InsertStyle(%s)", style___0);
            rtf = SearchCfgRtf((const char*)style___0, 3);
        }
        if ((unsigned long )rtf == (unsigned long )((void*)0)){
            {
                diagnostics(1, (char*)"Cannot find \'%s\' style using \'Normal\' style", style___0);
                SetCurrentStyle("Normal");
                rtf = SearchCfgRtf("Normal", 3);
                InsertBasicStyle((const char*)rtf, 1);
            }
        }else{
            {
                SetCurrentStyle((const char*)style___0);
                InsertBasicStyle((const char*)rtf, how);
            }
        }
        {
            free((void*)style___0);
        }
        return;
    }
}

int my_getopt(int argc, char** argv, char* optstring);
char* optarg = (char*)0;
int optind = 1;
static char* rem = (char*)((void*)0);

int my_getopt(int argc, char** argv, char* optstring)
{
    char* q;
    int c;
    int needarg;
    {
        {
            needarg = 0;
            optarg = (char*)((void*)0);
            diagnostics(4, (char*)"Processing option `%s\'", *(argv + optind));
        }
        if (!rem){
            if (optind < argc){
                if ((int)*(*(argv + optind) + 0) == 45){
                    rem = *(argv + optind) + 1;
                    if ((int)*rem == 0){
                        return (-1);
                    }
                    if ((int)*rem == 45){
                        optind++;
                        return (-1);
                    }
                }else{
                    return (-1);
                }
            }else{
                return (-1);
            }
        }
        {
            c = (int)*rem;
            q = strchr((const char*)optstring, c);
        }
        if (q){
            if (c != 58){
                needarg = (int)*(q + 1) == 58;
                if (needarg){
                    if ((int)*(rem + 1) != 0){
                        optarg = rem + 1;
                    }else{
                        optind++;
                        if (optind < argc){
                            optarg = *(argv + optind);
                        }else{
                            {
                                diagnostics(0, (char*)"Missing argument after -%c\n", c);
                            }
                        }
                    }
                }else{
                    rem++;
                }
            }else{
                {
                    diagnostics(1, (char*)"%s: illegal option -- %c\n", *(argv + 0), c);
                    c = '?';
                    rem++;
                }
            }
        }else{
            {
                diagnostics(1, (char*)"%s: illegal option -- %c\n", *(argv + 0), c);
                c = '?';
                rem++;
            }
        }
        if (needarg){
            rem = (char*)((void*)0);
            optind++;
        }else
            if ((int)*rem == 0){
                rem = (char*)((void*)0);
                optind++;
            }

        return (c);
    }
}

extern int system(const char* __command);
extern int (abs)(int __x);
extern int _IO_getc(_IO_FILE* __fp);
extern int fprintf(FILE*restrict  __stream, const char*restrict  __format, ...);
extern int (snprintf)(char*restrict  __s, size_t __maxlen, const char*restrict  __format, ...);
extern int fscanf(FILE*restrict  __stream, const char*restrict  __format, ...);
extern int (sscanf)(const char*restrict  __s, const char*restrict  __format, ...);
extern int fgetc(FILE* __stream);
extern int ungetc(int __c, FILE* __stream);
extern size_t fread(void*restrict  __ptr, size_t __size, size_t __n, FILE*restrict  __stream);
extern int fseek(FILE* __stream, long  __off, int __whence);
extern void rewind(FILE* __stream);
extern int (feof)(FILE* __stream);
extern int (memcmp)(const void* __s1, const void* __s2, size_t __n);
extern char* (strrchr)(const char* __s, int __c);
extern int (strcasecmp)(const char* __s1, const char* __s2);
extern int (toupper)(int __c);
extern double (fabs)(double __x);
char* g_home_dir;
uint16_t g_dots_per_inch;
int g_graphics_package;
char* g_script_dir;
char* g_preamble;
double g_png_equation_scale;
double g_png_figure_scale;
int g_little_endian;
char* getTmpPath(void);
extern int (unlink)(const char* __name);
void PrepareDisplayedBitmap(char* the_type);
void FinishDisplayedBitmap(void);
void WriteLatexAsBitmap(char* pre, char* eq, char* post);
void PutLatexFile(const char* tex_file_stem, double scale, const char* pre);
void CmdGraphics(int code);
void CmdPicture(int code);
void CmdPsPicture(int code);
void CmdPsGraph(int code);
void CmdMusic(int code);
void CmdPsset(int code);
void CmdNewPsStyle(int code);
void CmdGraphicsPath(int code);
double my_rint(double nr);
char* strdup_together(const char* s, const char* t);
char* strdup_together3(const char* s, const char* t, const char* u);
char* strdup_noendblanks(const char* s);
char* keyvalue_pair(char* s, char** key, char** value);
size_t my_strlcpy(char* dst, const char* src, size_t siz);
size_t my_strlcat(char* dst, const char* src, size_t siz);
int file_exists(char* fname);
int getCounter(char* s);
static void PutPictFile(char* s, double height0, double width0, double scale, double baseline);
static void PutPngFile(char* png, double height_goal, double width_goal, double scale, double baseline);
static void PutJpegFile(char* s, double height0, double width0, double scale, double baseline);
static void PutEmfFile(char* s, double height0, double width0, double scale, double baseline);
static void PutWmfFile(char* s, double height0, double width0, double scale, double baseline);
static void PutPdfFile(char* s, double height0, double width0, double scale, double baseline);
static void PutEpsFile(char* s, double height0, double width0, double scale, double baseline);
static void PutTiffFile(char* s, double height0, double width0, double scale, double baseline);
static void PutGifFile(char* s, double height0, double width0, double scale, double baseline);
static GraphConvertElement GraphConvertTable[13] = {{(char*)".png", &PutPngFile}, {(char*)".pdf", &PutPdfFile}, {(char*)".jpg", &PutJpegFile}, {(char*)".jpeg", &PutJpegFile}, {(char*)".gif", &PutGifFile}, {(char*)".eps", &PutEpsFile}, {(char*)".tiff", &PutTiffFile}, {(char*)".tif", &PutTiffFile}, {(char*)".ps", &PutEpsFile}, {(char*)".pict", &PutPictFile}, {(char*)".emf", &PutEmfFile}, {(char*)".wmf", &PutWmfFile}, {(char*)((void*)0), (PutFileFnc*)((void*)0)}};
static char** graphicsPath = (char**)((void*)0);
static int nGraphicsPathElems = 0;

static void appendGraphicsPath(char* newPath)
{
    int i;
    void* ptr;
    char* add;
    int tmp;
    size_t tmp___0;
    int tmp___1;
    {
        i = 0;
        {
            while (1){
                while_continue:
                ;
                if (!(i < nGraphicsPathElems)){
                    goto while_break;
                }
                {
                    tmp = streq((const char*)*(graphicsPath + i), (const char*)newPath);
                }
                if (tmp){
                    {
                        diagnostics(1, (char*)"Repeated graphics path element {%s}", newPath);
                    }
                    return;
                }
                i++;
            }
            while_break:
            ;
        }
        {
            ptr = (void*)graphicsPath;
            ptr = realloc(ptr, sizeof (char*) * (unsigned long )(nGraphicsPathElems + 1));
            graphicsPath = (char**)ptr;
            tmp___0 = strlen((const char*)newPath);
        }
        if ((int)*((newPath + tmp___0) - 1) == 47){
            {
                add = strdup((const char*)newPath);
            }
        }else{
            {
                add = strdup_together((const char*)newPath, "/");
            }
        }
        {
            tmp___1 = nGraphicsPathElems;
            nGraphicsPathElems++;
            *(graphicsPath + tmp___1) = add;
            diagnostics(1, (char*)"Included %s in graphics search path", add);
        }
        return;
    }
}

void CmdGraphicsPath(int code)
{
    char* directories;
    char* tmp;
    char* candidate;
    char* tmp___0;
    {
        {
            tmp = getBraceParam();
            directories = tmp;
        }
        if ((unsigned long )directories != (unsigned long )((void*)0)){
            {
                tmp___0 = strtok((char*)directories, (const char*)"{}");
                candidate = tmp___0;
            }
            {
                while (1){
                    while_continue:
                    ;
                    if (!((unsigned long )((void*)0) != (unsigned long )candidate)){
                        goto while_break;
                    }
                    {
                        appendGraphicsPath(candidate);
                        candidate = strtok((char*)((void*)0), (const char*)"{}");
                    }
                }
                while_break:
                ;
            }
        }
        {
            safe_free(directories);
        }
        return;
    }
}

static char* g_psset_info = (char*)((void*)0);
static char* g_psstyle_info = (char*)((void*)0);

static void my_unlink(char* filename)
{
    {
        {
            unlink((const char*)filename);
        }
        return;
    }
}

static char* strdup_tmp_path(const char* s)
{
    char* tmp;
    char* p;
    char* fullname;
    {
        if ((unsigned long )s == (unsigned long )((void*)0)){
            return ((char*)((void*)0));
        }
        {
            tmp = getTmpPath();
            p = strrchr(s, '/');
        }
        if (!p){
            {
                fullname = strdup_together((const char*)tmp, s);
            }
        }else{
            {
                fullname = strdup_together((const char*)tmp, (const char*)(p + 1));
            }
        }
        {
            safe_free(tmp);
        }
        return (fullname);
    }
}

static char* SysGraphicsConvert(int opt, int offset, uint16_t dpi, const char* in, const char* out)
{
    char cmd[512];
    char* out_tmp;
    int err;
    int N;
    char* tmp;
    char* tmp___0;
    char format_simple[18];
    char format_crop[65];
    char format_unix[29];
    char format_unix___0[40];
    char format_unix___1[78];
    {
        {
            N = 511;
            diagnostics(4, (char*)"SysGraphicsConvert \'%s\'", in);
            out_tmp = strdup_tmp_path(out);
        }
        if ((unsigned long )in == (unsigned long )((void*)0)){
            return ((char*)((void*)0));
        }else
            if ((unsigned long )out == (unsigned long )((void*)0)){
                return ((char*)((void*)0));
            }else
                if ((unsigned long )out_tmp == (unsigned long )((void*)0)){
                    return ((char*)((void*)0));
                }

        {
            tmp = strchr(in, '\'');
        }
        if (tmp){
            {
                diagnostics(1, (char*)"single quote found in filename \'%s\'.  skipping conversion", in);
                free((void*)out_tmp);
            }
            return ((char*)((void*)0));
        }
        if (out_tmp){
            {
                tmp___0 = strchr((const char*)out_tmp, '\'');
            }
            if (tmp___0){
                {
                    diagnostics(1, (char*)"single quote found in filename \'%s\'.  skipping conversion", out_tmp);
                    free((void*)out_tmp);
                }
                return ((char*)((void*)0));
            }
        }
        if (opt == 1){
            {
                format_simple[0] = (char)'c';
                format_simple[1] = (char)'o';
                format_simple[2] = (char)'n';
                format_simple[3] = (char)'v';
                format_simple[4] = (char)'e';
                format_simple[5] = (char)'r';
                format_simple[6] = (char)'t';
                format_simple[7] = (char)' ';
                format_simple[8] = (char)'\'';
                format_simple[9] = (char)'%';
                format_simple[10] = (char)'s';
                format_simple[11] = (char)'\'';
                format_simple[12] = (char)' ';
                format_simple[13] = (char)'\'';
                format_simple[14] = (char)'%';
                format_simple[15] = (char)'s';
                format_simple[16] = (char)'\'';
                format_simple[17] = (char)'\000';
                snprintf((char*)(cmd), (size_t)N, (const char*)(format_simple), in, out_tmp);
            }
        }
        if (opt == 2){
            {
                format_crop[0] = (char)'c';
                format_crop[1] = (char)'o';
                format_crop[2] = (char)'n';
                format_crop[3] = (char)'v';
                format_crop[4] = (char)'e';
                format_crop[5] = (char)'r';
                format_crop[6] = (char)'t';
                format_crop[7] = (char)' ';
                format_crop[8] = (char)'-';
                format_crop[9] = (char)'t';
                format_crop[10] = (char)'r';
                format_crop[11] = (char)'i';
                format_crop[12] = (char)'m';
                format_crop[13] = (char)' ';
                format_crop[14] = (char)'+';
                format_crop[15] = (char)'r';
                format_crop[16] = (char)'e';
                format_crop[17] = (char)'p';
                format_crop[18] = (char)'a';
                format_crop[19] = (char)'g';
                format_crop[20] = (char)'e';
                format_crop[21] = (char)' ';
                format_crop[22] = (char)'-';
                format_crop[23] = (char)'u';
                format_crop[24] = (char)'n';
                format_crop[25] = (char)'i';
                format_crop[26] = (char)'t';
                format_crop[27] = (char)'s';
                format_crop[28] = (char)' ';
                format_crop[29] = (char)'P';
                format_crop[30] = (char)'i';
                format_crop[31] = (char)'x';
                format_crop[32] = (char)'e';
                format_crop[33] = (char)'l';
                format_crop[34] = (char)'s';
                format_crop[35] = (char)'P';
                format_crop[36] = (char)'e';
                format_crop[37] = (char)'r';
                format_crop[38] = (char)'I';
                format_crop[39] = (char)'n';
                format_crop[40] = (char)'c';
                format_crop[41] = (char)'h';
                format_crop[42] = (char)' ';
                format_crop[43] = (char)'-';
                format_crop[44] = (char)'d';
                format_crop[45] = (char)'e';
                format_crop[46] = (char)'n';
                format_crop[47] = (char)'s';
                format_crop[48] = (char)'i';
                format_crop[49] = (char)'t';
                format_crop[50] = (char)'y';
                format_crop[51] = (char)' ';
                format_crop[52] = (char)'%';
                format_crop[53] = (char)'d';
                format_crop[54] = (char)' ';
                format_crop[55] = (char)'\'';
                format_crop[56] = (char)'%';
                format_crop[57] = (char)'s';
                format_crop[58] = (char)'\'';
                format_crop[59] = (char)' ';
                format_crop[60] = (char)'\'';
                format_crop[61] = (char)'%';
                format_crop[62] = (char)'s';
                format_crop[63] = (char)'\'';
                format_crop[64] = (char)'\000';
                snprintf((char*)(cmd), (size_t)N, (const char*)(format_crop), (int)dpi, in, out_tmp);
            }
        }
        if (opt == 3){
            if ((unsigned long )g_home_dir == (unsigned long )((void*)0)){
                format_unix[0] = (char)'%';
                format_unix[1] = (char)'s';
                format_unix[2] = (char)'l';
                format_unix[3] = (char)'a';
                format_unix[4] = (char)'t';
                format_unix[5] = (char)'e';
                format_unix[6] = (char)'x';
                format_unix[7] = (char)'2';
                format_unix[8] = (char)'p';
                format_unix[9] = (char)'n';
                format_unix[10] = (char)'g';
                format_unix[11] = (char)' ';
                format_unix[12] = (char)'-';
                format_unix[13] = (char)'d';
                format_unix[14] = (char)' ';
                format_unix[15] = (char)'%';
                format_unix[16] = (char)'d';
                format_unix[17] = (char)' ';
                format_unix[18] = (char)'-';
                format_unix[19] = (char)'o';
                format_unix[20] = (char)' ';
                format_unix[21] = (char)'%';
                format_unix[22] = (char)'d';
                format_unix[23] = (char)' ';
                format_unix[24] = (char)'\'';
                format_unix[25] = (char)'%';
                format_unix[26] = (char)'s';
                format_unix[27] = (char)'\'';
                format_unix[28] = (char)'\000';
                if (g_script_dir){
                    {
                        snprintf((char*)(cmd), (size_t)N, (const char*)(format_unix), g_script_dir, (int)dpi, offset, in);
                    }
                }else{
                    {
                        snprintf((char*)(cmd), (size_t)N, (const char*)(format_unix), "", (int)dpi, offset, in);
                    }
                }
            }else{
                format_unix___0[0] = (char)'%';
                format_unix___0[1] = (char)'s';
                format_unix___0[2] = (char)'l';
                format_unix___0[3] = (char)'a';
                format_unix___0[4] = (char)'t';
                format_unix___0[5] = (char)'e';
                format_unix___0[6] = (char)'x';
                format_unix___0[7] = (char)'2';
                format_unix___0[8] = (char)'p';
                format_unix___0[9] = (char)'n';
                format_unix___0[10] = (char)'g';
                format_unix___0[11] = (char)' ';
                format_unix___0[12] = (char)'-';
                format_unix___0[13] = (char)'k';
                format_unix___0[14] = (char)' ';
                format_unix___0[15] = (char)'-';
                format_unix___0[16] = (char)'d';
                format_unix___0[17] = (char)' ';
                format_unix___0[18] = (char)'%';
                format_unix___0[19] = (char)'d';
                format_unix___0[20] = (char)' ';
                format_unix___0[21] = (char)'-';
                format_unix___0[22] = (char)'o';
                format_unix___0[23] = (char)' ';
                format_unix___0[24] = (char)'%';
                format_unix___0[25] = (char)'d';
                format_unix___0[26] = (char)' ';
                format_unix___0[27] = (char)'-';
                format_unix___0[28] = (char)'H';
                format_unix___0[29] = (char)' ';
                format_unix___0[30] = (char)'\'';
                format_unix___0[31] = (char)'%';
                format_unix___0[32] = (char)'s';
                format_unix___0[33] = (char)'\'';
                format_unix___0[34] = (char)' ';
                format_unix___0[35] = (char)'\'';
                format_unix___0[36] = (char)'%';
                format_unix___0[37] = (char)'s';
                format_unix___0[38] = (char)'\'';
                format_unix___0[39] = (char)'\000';
                if (g_script_dir){
                    {
                        snprintf((char*)(cmd), (size_t)N, (const char*)(format_unix___0), g_script_dir, (int)dpi, offset, g_home_dir, in);
                    }
                }else{
                    {
                        snprintf((char*)(cmd), (size_t)N, (const char*)(format_unix___0), "", (int)dpi, offset, g_home_dir, in);
                    }
                }
            }
        }
        if (opt == 4){
            {
                format_unix___1[0] = (char)'g';
                format_unix___1[1] = (char)'s';
                format_unix___1[2] = (char)' ';
                format_unix___1[3] = (char)'-';
                format_unix___1[4] = (char)'q';
                format_unix___1[5] = (char)' ';
                format_unix___1[6] = (char)'-';
                format_unix___1[7] = (char)'d';
                format_unix___1[8] = (char)'N';
                format_unix___1[9] = (char)'O';
                format_unix___1[10] = (char)'P';
                format_unix___1[11] = (char)'A';
                format_unix___1[12] = (char)'U';
                format_unix___1[13] = (char)'S';
                format_unix___1[14] = (char)'E';
                format_unix___1[15] = (char)' ';
                format_unix___1[16] = (char)'-';
                format_unix___1[17] = (char)'d';
                format_unix___1[18] = (char)'S';
                format_unix___1[19] = (char)'A';
                format_unix___1[20] = (char)'F';
                format_unix___1[21] = (char)'E';
                format_unix___1[22] = (char)'R';
                format_unix___1[23] = (char)' ';
                format_unix___1[24] = (char)'-';
                format_unix___1[25] = (char)'d';
                format_unix___1[26] = (char)'B';
                format_unix___1[27] = (char)'A';
                format_unix___1[28] = (char)'T';
                format_unix___1[29] = (char)'C';
                format_unix___1[30] = (char)'H';
                format_unix___1[31] = (char)' ';
                format_unix___1[32] = (char)'-';
                format_unix___1[33] = (char)'s';
                format_unix___1[34] = (char)'D';
                format_unix___1[35] = (char)'E';
                format_unix___1[36] = (char)'V';
                format_unix___1[37] = (char)'I';
                format_unix___1[38] = (char)'C';
                format_unix___1[39] = (char)'E';
                format_unix___1[40] = (char)'=';
                format_unix___1[41] = (char)'p';
                format_unix___1[42] = (char)'n';
                format_unix___1[43] = (char)'g';
                format_unix___1[44] = (char)'a';
                format_unix___1[45] = (char)'l';
                format_unix___1[46] = (char)'p';
                format_unix___1[47] = (char)'h';
                format_unix___1[48] = (char)'a';
                format_unix___1[49] = (char)' ';
                format_unix___1[50] = (char)'-';
                format_unix___1[51] = (char)'r';
                format_unix___1[52] = (char)'%';
                format_unix___1[53] = (char)'d';
                format_unix___1[54] = (char)' ';
                format_unix___1[55] = (char)'-';
                format_unix___1[56] = (char)'s';
                format_unix___1[57] = (char)'O';
                format_unix___1[58] = (char)'u';
                format_unix___1[59] = (char)'t';
                format_unix___1[60] = (char)'p';
                format_unix___1[61] = (char)'u';
                format_unix___1[62] = (char)'t';
                format_unix___1[63] = (char)'F';
                format_unix___1[64] = (char)'i';
                format_unix___1[65] = (char)'l';
                format_unix___1[66] = (char)'e';
                format_unix___1[67] = (char)'=';
                format_unix___1[68] = (char)'\'';
                format_unix___1[69] = (char)'%';
                format_unix___1[70] = (char)'s';
                format_unix___1[71] = (char)'\'';
                format_unix___1[72] = (char)' ';
                format_unix___1[73] = (char)'\'';
                format_unix___1[74] = (char)'%';
                format_unix___1[75] = (char)'s';
                format_unix___1[76] = (char)'\'';
                format_unix___1[77] = (char)'\000';
                snprintf((char*)(cmd), (size_t)N, (const char*)(format_unix___1), (int)dpi, out_tmp, in);
            }
        }
        {
            diagnostics(4, (char*)"`%s`", cmd);
            err = system((const char*)(cmd));
        }
        if (err){
            {
                diagnostics(1, (char*)"\nerror=%d when converting %s", err, in);
                safe_free(out_tmp);
            }
            return ((char*)((void*)0));
        }
        return (out_tmp);
    }
}

static char* strdup_new_extension(const char* s, const char* old_ext, const char* new_ext)
{
    char* new_name;
    char* p;
    int s_len;
    int o_len;
    int n_len;
    int siz;
    size_t tmp;
    size_t tmp___0;
    size_t tmp___1;
    void* tmp___2;
    {
        if ((unsigned long )s == (unsigned long )((void*)0)){
            return ((char*)((void*)0));
        }else
            if ((unsigned long )old_ext == (unsigned long )((void*)0)){
                return ((char*)((void*)0));
            }else
                if ((unsigned long )new_ext == (unsigned long )((void*)0)){
                    return ((char*)((void*)0));
                }

        {
            tmp = strlen(s);
            s_len = (int)tmp;
            tmp___0 = strlen(old_ext);
            o_len = (int)tmp___0;
            tmp___1 = strlen(new_ext);
            n_len = (int)tmp___1;
            p = (char*)s;
        }
        {
            while (1){
                while_continue:
                ;
                {
                    p = strstr((const char*)p, old_ext);
                }
                if (p){
                    if (!(p - (char*)s > (long )(s_len - o_len))){
                        goto while_break;
                    }
                }else{
                    goto while_break;
                }
            }
            while_break:
            ;
        }
        if ((unsigned long )p == (unsigned long )((void*)0)){
            return ((char*)((void*)0));
        }
        {
            siz = ((s_len - o_len) + n_len) + 1;
            tmp___2 = malloc((size_t)siz);
            new_name = (char*)tmp___2;
            my_strlcpy(new_name, s, (size_t)((s_len - o_len) + 1));
            my_strlcat(new_name, new_ext, (size_t)siz);
        }
        return (new_name);
    }
}

static int has_extension(const char* s, const char* ext)
{
    char* t;
    size_t tmp;
    size_t tmp___0;
    int tmp___1;
    {
        {
            tmp = strlen(s);
            tmp___0 = strlen(ext);
            t = ((char*)s + tmp) - tmp___0;
            tmp___1 = strcasecmp((const char*)t, ext);
        }
        if (tmp___1 == 0){
            return (1);
        }
        return (0);
    }
}

static char* has_graphic_extension(const char* s)
{
    GraphConvertElement* thisFormat;
    char* tmp;
    int tmp___0;
    {
        {
            diagnostics(4, (char*)"testing for graphics extension \'%s\'", s);
            thisFormat = GraphConvertTable;
        }
        {
            while (1){
                while_continue:
                ;
                if (!((unsigned long )thisFormat->extension != (unsigned long )((void*)0))){
                    goto while_break;
                }
                {
                    tmp___0 = has_extension(s, (const char*)thisFormat->extension);
                }
                if (tmp___0){
                    {
                        tmp = strdup((const char*)thisFormat->extension);
                    }
                    return (tmp);
                }
                thisFormat++;
            }
            while_break:
            ;
        }
        return ((char*)((void*)0));
    }
}

static void split_filename(const char* f, char** dir, char** name, char** ext)
{
    char* s;
    char* t;
    char* x;
    char* tmp;
    size_t tmp___0;
    size_t tmp___1;
    {
        *dir = (char*)((void*)0);
        *name = (char*)((void*)0);
        *ext = (char*)((void*)0);
        if ((unsigned long )f == (unsigned long )((void*)0)){
            return;
        }
        {
            s = strrchr(f, '/');
        }
        if (s){
            {
                t = strdup(f);
                tmp = strrchr((const char*)t, '/');
                x = tmp + 1;
                *x = (char)'\000';
            }
            if ((const int)*f == 47){
                *dir = t;
            }else
                if (g_home_dir){
                    {
                        *dir = strdup_together((const char*)g_home_dir, (const char*)t);
                        safe_free(t);
                    }
                }else{
                    *dir = t;
                }

            s++;
        }else{
            if (g_home_dir){
                {
                    *dir = strdup((const char*)g_home_dir);
                }
            }
            s = (char*)f;
        }
        {
            *name = strdup((const char*)s);
            *ext = has_graphic_extension((const char*)s);
        }
        if (*ext){
            {
                tmp___0 = strlen((const char*)*name);
                tmp___1 = strlen((const char*)*ext);
                t = (*name + tmp___0) - tmp___1;
                *t = (char)'\000';
            }
        }
        {
            diagnostics(5, (char*)"filename=\'%s\', dir=\'%s\', name=\'%s\', ext=\'%s\'", f, *dir, *name, *ext);
        }
        return;
    }
}

static char* eps_to_png(char* name)
{
    char* png;
    char* out;
    char* tmp;
    char* tmp___0;
    char* tmp___1;
    char* tmp___2;
    {
        if ((unsigned long )name == (unsigned long )((void*)0)){
            return ((char*)((void*)0));
        }
        {
            diagnostics(3, (char*)" eps_to_png \'%s\'", name);
            tmp___2 = strstr((const char*)name, ".eps");
        }
        if ((unsigned long )tmp___2 != (unsigned long )((void*)0)){
            {
                png = strdup_new_extension((const char*)name, ".eps", ".png");
            }
        }else{
            {
                tmp___1 = strstr((const char*)name, ".EPS");
            }
            if ((unsigned long )tmp___1 != (unsigned long )((void*)0)){
                {
                    png = strdup_new_extension((const char*)name, ".EPS", ".png");
                }
            }else{
                {
                    tmp___0 = strstr((const char*)name, ".ps");
                }
                if ((unsigned long )tmp___0 != (unsigned long )((void*)0)){
                    {
                        png = strdup_new_extension((const char*)name, ".ps", ".png");
                    }
                }else{
                    {
                        tmp = strstr((const char*)name, ".PS");
                    }
                    if ((unsigned long )tmp != (unsigned long )((void*)0)){
                        {
                            png = strdup_new_extension((const char*)name, ".PS", ".png");
                        }
                    }else{
                        return ((char*)((void*)0));
                    }
                }
            }
        }
        {
            out = SysGraphicsConvert(2, 0, g_dots_per_inch, (const char*)name, (const char*)png);
            free((void*)png);
        }
        return (out);
    }
}

static char* pdf_to_png(char* pdf)
{
    char* png;
    char* out;
    char* tmp;
    char* tmp___0;
    {
        if ((unsigned long )pdf == (unsigned long )((void*)0)){
            return ((char*)((void*)0));
        }
        {
            tmp___0 = strstr((const char*)pdf, ".pdf");
        }
        if ((unsigned long )tmp___0 != (unsigned long )((void*)0)){
            {
                png = strdup_new_extension((const char*)pdf, ".pdf", ".png");
            }
        }else{
            {
                tmp = strstr((const char*)pdf, ".PDF");
            }
            if ((unsigned long )tmp != (unsigned long )((void*)0)){
                {
                    png = strdup_new_extension((const char*)pdf, ".PDF", ".png");
                }
            }else{
                return ((char*)((void*)0));
            }
        }
        {
            out = SysGraphicsConvert(4, 0, g_dots_per_inch, (const char*)pdf, (const char*)png);
            safe_free(png);
        }
        return (out);
    }
}

static void AdjustScaling(double h, double w, double target_h, double target_w, double s, uint16_t* sx, uint16_t* sy)
{
    double tmp;
    double tmp___0;
    double tmp___1;
    {
        {
            diagnostics(5, (char*)"AdjustScaling h       =%f w       =%f s=%f", h, w, s);
            diagnostics(5, (char*)"AdjustScaling target_h=%f target_w=%f", target_h, target_w);
        }
        if (target_h != (double)0){
            if (h != (double)0){
                {
                    tmp = my_rint((100.0 * target_h) / h);
                    *sy = (uint16_t)tmp;
                }
            }else{
                {
                    tmp___0 = my_rint(s * (double)100);
                    *sy = (uint16_t)tmp___0;
                }
            }
        }else{
            {
                tmp___0 = my_rint(s * (double)100);
                *sy = (uint16_t)tmp___0;
            }
        }
        if (target_w == (double)0){
            *sx = *sy;
        }else
            if (w == (double)0){
                *sx = *sy;
            }else{
                {
                    tmp___1 = my_rint((100.0 * target_w) / w);
                    *sx = (uint16_t)tmp___1;
                }
            }

        if (target_h == (double)0){
            if (target_w != (double)0){
                *sy = *sx;
            }
        }
        {
            diagnostics(5, (char*)"AdjustScaling xscale=%d yscale=%d", (int)*sx, (int)*sy);
        }
        return;
    }
}

static void PutHexFile(FILE* fp)
{
    int i;
    int c;
    {
        i = 0;
        {
            while (1){
                while_continue:
                ;
                {
                    c = fgetc(fp);
                }
                if (!(c != -1)){
                    goto while_break;
                }
                {
                    fprintRTF((char*)"%.2x", c);
                    i++;
                }
                if (i > 126){
                    {
                        i = 0;
                        fprintRTF((char*)"\n");
                    }
                }
            }
            while_break:
            ;
        }
        return;
    }
}

static void PutPictFile(char* s, double height0, double width0, double scale, double baseline)
{
    FILE* fp;
    char* pict;
    int16_t buffer___0[5];
    int16_t top___0;
    int16_t left;
    int16_t bottom;
    int16_t right;
    int16_t width;
    int16_t height;
    uint16_t sx;
    uint16_t sy;
    int tmp;
    size_t tmp___0;
    {
        {
            pict = strdup((const char*)s);
            diagnostics(2, (char*)"PutPictFile \'%s\'", pict);
            fp = fopen((const char*)pict, (const char*)"rb");
            free((void*)pict);
        }
        if ((unsigned long )fp == (unsigned long )((void*)0)){
            return;
        }
        {
            tmp = fseek(fp, 514L, 0);
        }
        if (tmp){
            {
                diagnostics(1, (char*)"Cannot read graphics file \'%s\'", s);
                fclose(fp);
            }
            return;
        }else{
            {
                tmp___0 = fread((void*)(buffer___0), (size_t)2, (size_t)4, (FILE*)fp);
            }
            if (tmp___0 != 4UL){
                {
                    diagnostics(1, (char*)"Cannot read graphics file \'%s\'", s);
                    fclose(fp);
                }
                return;
            }
        }
        top___0 = buffer___0[0];
        left = buffer___0[1];
        bottom = buffer___0[2];
        right = buffer___0[3];
        width = (int16_t)((int)right - (int)left);
        height = (int16_t)((int)bottom - (int)top___0);
        if (g_little_endian){
            top___0 = (int16_t)((((int)top___0 & 65280) >> 8) | (((int)top___0 & 255) << 8));
            bottom = (int16_t)((((int)bottom & 65280) >> 8) | (((int)bottom & 255) << 8));
            left = (int16_t)((((int)left & 65280) >> 8) | (((int)left & 255) << 8));
            right = (int16_t)((((int)right & 65280) >> 8) | (((int)right & 255) << 8));
        }
        {
            diagnostics(4, (char*)"top = %d, bottom = %d", (int)top___0, (int)bottom);
            diagnostics(4, (char*)"left = %d, right = %d", (int)left, (int)right);
            diagnostics(4, (char*)"width = %d, height = %d", (int)width, (int)height);
            fprintRTF((char*)"\n{\\pict\\macpict\\picw%d\\pich%d\n", (int)width, (int)height);
            AdjustScaling((double)((int)height * 20), (double)((int)width * 20), height0, width0, scale, &sx, &sy);
        }
        if ((int)sx != 100){
            if ((int)sy != 100){
                {
                    fprintRTF((char*)"\\picscalex%d\\picscaley%d", (int)sx, (int)sy);
                }
            }
        }
        {
            fseek(fp, -10L, 1);
            PutHexFile(fp);
            fprintRTF((char*)"}\n");
            fclose(fp);
        }
        return;
    }
}

static unsigned char* getPngChunk(FILE* fp, char* s)
{
    uint32_t crc;
    uint32_t DataLength;
    char Type[5];
    unsigned char* data;
    int tmp;
    void* tmp___0;
    int tmp___1;
    {
        {
            Type[4] = (char)'\000';
            diagnostics(6, (char*)"getPngChunk ... seeking \'%s\'", s);
            data = (unsigned char*)((void*)0);
        }
        {
            while (1){
                while_continue:
                ;
                if (data){
                    {
                        free((void*)data);
                    }
                }
                {
                    fread((void*)(&DataLength), (size_t)4, (size_t)1, (FILE*)fp);
                }
                if (g_little_endian){
                    DataLength = ((((DataLength & 4278190080U) >> 24) | ((DataLength & 16711680U) >> 8)) | ((DataLength & 65280U) << 8)) | ((DataLength & 255U) << 24);
                }
                {
                    fread((void*)(Type), (size_t)1, (size_t)4, (FILE*)fp);
                    tmp = strcmp((const char*)(Type), "IEND");
                }
                if (tmp == 0){
                    return ((unsigned char*)((void*)0));
                }
                {
                    diagnostics(6, (char*)"found chunk \'%s\' size %u bytes", Type, DataLength);
                    tmp___0 = malloc((size_t)DataLength);
                    data = (unsigned char*)tmp___0;
                }
                if ((unsigned long )data == (unsigned long )((void*)0)){
                    return ((unsigned char*)((void*)0));
                }
                {
                    fread((void*)data, (size_t)DataLength, (size_t)1, (FILE*)fp);
                    fread((void*)(&crc), (size_t)4, (size_t)1, (FILE*)fp);
                    crc++;
                    tmp___1 = strcmp((const char*)s, (const char*)(Type));
                }
                if (!(tmp___1 != 0)){
                    goto while_break;
                }
            }
            while_break:
            ;
        }
        return (data);
    }
}

static void GetPngSize(char* s, uint32_t* w_pixels, uint32_t* h_pixels, double* xres, double* yres, int* bad_res)
{
    FILE* fp;
    uint32_t* p;
    unsigned char buffer___0[16];
    char reftag[9];
    unsigned char* data;
    size_t tmp;
    int tmp___0;
    double tmp___1;
    double tmp___2;
    {
        {
            reftag[0] = (char)'\211';
            reftag[1] = (char)'P';
            reftag[2] = (char)'N';
            reftag[3] = (char)'G';
            reftag[4] = (char)'\r';
            reftag[5] = (char)'\n';
            reftag[6] = (char)'\032';
            reftag[7] = (char)'\n';
            reftag[8] = (char)'\000';
            data = (unsigned char*)((void*)0);
            diagnostics(4, (char*)"GetPngSize of \'%s\'", s);
            *xres = 2834.65;
            *yres = 2834.65;
            *bad_res = 1;
            fp = fopen((const char*)s, (const char*)"rb");
        }
        if ((unsigned long )fp == (unsigned long )((void*)0)){
            return;
        }
        {
            tmp = fread((void*)(buffer___0), (size_t)1, (size_t)8, (FILE*)fp);
        }
        if (tmp < 8UL){
            {
                diagnostics(1, (char*)"Cannot read graphics file \'%s\'", s);
                fclose(fp);
            }
            return;
        }
        {
            tmp___0 = memcmp((const void*)(buffer___0), (const void*)(reftag), (size_t)8);
        }
        if (tmp___0 != 0){
            {
                diagnostics(1, (char*)"Graphics file \'%s\' is not a PNG file!", s);
                fclose(fp);
            }
            return;
        }
        {
            data = getPngChunk(fp, (char*)"IHDR");
        }
        if ((unsigned long )data == (unsigned long )((void*)0)){
            {
                diagnostics(1, (char*)"Graphics file \'%s\': could not locate IHDR chunk!", s);
                fclose(fp);
            }
            return;
        }
        p = (uint32_t*)data;
        if (g_little_endian){
            *w_pixels = ((((*p & 4278190080U) >> 24) | ((*p & 16711680U) >> 8)) | ((*p & 65280U) << 8)) | ((*p & 255U) << 24);
        }else{
            *w_pixels = *p;
        }
        p++;
        if (g_little_endian){
            *h_pixels = ((((*p & 4278190080U) >> 24) | ((*p & 16711680U) >> 8)) | ((*p & 65280U) << 8)) | ((*p & 255U) << 24);
        }else{
            *h_pixels = *p;
        }
        {
            free((void*)data);
            data = getPngChunk(fp, (char*)"pHYs");
        }
        if ((unsigned long )data == (unsigned long )((void*)0)){
            {
                diagnostics(2, (char*)"Graphics file \'%s\': could not locate pHYs chunk!", s);
                diagnostics(2, (char*)"defaulting to 72 pixels/inch for resolution");
                fclose(fp);
            }
            return;
        }
        p = (uint32_t*)data;
        if (g_little_endian){
            *xres = (double)(((((*p & 4278190080U) >> 24) | ((*p & 16711680U) >> 8)) | ((*p & 65280U) << 8)) | ((*p & 255U) << 24));
        }else{
            *xres = (double)*p;
        }
        p++;
        if (g_little_endian){
            *yres = (double)(((((*p & 4278190080U) >> 24) | ((*p & 16711680U) >> 8)) | ((*p & 65280U) << 8)) | ((*p & 255U) << 24));
        }else{
            *yres = (double)*p;
        }
        {
            free((void*)data);
            tmp___1 = fabs(*xres - 2834.65);
        }
        if (tmp___1 < (double)2){
            *xres = 2834.65;
        }
        {
            tmp___2 = fabs(*yres - 2834.65);
        }
        if (tmp___2 < (double)2){
            *yres = 2834.65;
        }
        if (*xres < 2834.65){
            {
                *bad_res = 1;
                diagnostics(5, (char*)"bogus resolution in png image! ");
                diagnostics(5, (char*)"xres = %g, yres = %g, pixels/meter", *xres, *yres);
                diagnostics(5, (char*)"xres = %g, yres = %g, pixels/in", (*xres * 72.0) / 2834.65, (*yres * 72.0) / 2834.65);
                *xres *= 2834.65 / 72.0;
                *yres *= 2834.65 / 72.0;
            }
        }else{
            *bad_res = 0;
        }
        {
            diagnostics(5, (char*)"xres = %g, yres = %g, pixels/meter", *xres, *yres);
            diagnostics(5, (char*)"xres = %g, yres = %g, pixels/in", (*xres * 72.0) / 2834.65, (*yres * 72.0) / 2834.65);
            fclose(fp);
        }
        return;
    }
}

static void PutPngFile(char* png, double height_goal, double width_goal, double scale, double baseline)
{
    FILE* fp;
    double xres;
    double yres;
    uint32_t w_pixels;
    uint32_t h_pixels;
    uint32_t b;
    uint32_t w_twips;
    uint32_t h_twips;
    uint16_t sx;
    uint16_t sy;
    int bad_res;
    {
        {
            diagnostics(1, (char*)"Encoding  \'%s\'", png);
            GetPngSize(png, &w_pixels, &h_pixels, &xres, &yres, &bad_res);
        }
        if (w_pixels == 0U){
            return;
        }else
            if (h_pixels == 0U){
                return;
            }

        {
            fp = fopen((const char*)png, (const char*)"rb");
        }
        if ((unsigned long )fp == (unsigned long )((void*)0)){
            return;
        }
        {
            w_twips = (uint32_t)((int)((((double)w_pixels / xres) * 2834.65) * 20.0 + 0.5));
            h_twips = (uint32_t)((int)((((double)h_pixels / yres) * 2834.65) * 20.0 + 0.5));
            b = (uint32_t)baseline * 2U;
            AdjustScaling((double)h_twips, (double)w_twips, height_goal, width_goal, scale, &sx, &sy);
        }
        if (bad_res){
            sx = (uint16_t)(((double)sx * 2834.65) / xres);
            sy = (uint16_t)(((double)sy * 2834.65) / yres);
        }
        {
            diagnostics(4, (char*)"picw       = %8lu pixels,     pich        = %8lu pixels", w_pixels, h_pixels);
            diagnostics(4, (char*)"picwgoal   = %8lu twips,      pichgoal    = %8lu twips", w_twips, h_twips);
            diagnostics(4, (char*)"xres       = %8.2f pix/meter, yres        = %8.2f pix/meter", xres, yres);
            diagnostics(4, (char*)"xres       = %8.2f pix/inch,   yres        = %8.2f pix/inch", (xres * 72.0) / 2834.65, (yres * 72.0) / 2834.65);
            diagnostics(4, (char*)"scale      = %8.3f", scale);
            diagnostics(4, (char*)"width_goal = %8d twips,      height_goal = %8d twips", (int)width_goal, (int)height_goal);
            diagnostics(4, (char*)"baseline   = %8.3g twips", baseline);
            diagnostics(4, (char*)"sx         = %8lu percent,    sy          = %8lu percent", (int)sx, (int)sy);
            fprintRTF((char*)"\n{");
        }
        if (b){
            {
                fprintRTF((char*)"\\dn%lu", b + 1U);
            }
        }
        {
            fprintRTF((char*)"\\pict");
        }
        if ((int)sx != 100){
            if ((int)sy != 100){
                {
                    fprintRTF((char*)"\\picscalex%u\\picscaley%u", (int)sx, (int)sy);
                }
            }
        }
        {
            fprintRTF((char*)"\\picw%lu\\pich%lu", w_pixels, h_pixels);
            fprintRTF((char*)"\\picwgoal%lu\\pichgoal%lu", w_twips, h_twips);
            fprintRTF((char*)"\\pngblip\n");
            rewind(fp);
            PutHexFile(fp);
            fprintRTF((char*)"}\n");
            fclose(fp);
        }
        return;
    }
}

static void PutJpegFile(char* s, double height0, double width0, double scale, double baseline)
{
    FILE* fp;
    char* jpg;
    uint16_t buffer___0[2];
    int m;
    uint16_t width;
    uint16_t height;
    uint32_t w;
    uint32_t h;
    uint16_t sx;
    uint16_t sy;
    int tmp;
    int tmp___0;
    int tmp___1;
    int tmp___2;
    int tmp___3;
    int tmp___4;
    int tmp___5;
    size_t tmp___6;
    {
        {
            m = 0;
            jpg = strdup_together((const char*)g_home_dir, (const char*)s);
            diagnostics(2, (char*)"PutJpegFile \'%s\'", jpg);
            fp = fopen((const char*)jpg, (const char*)"rb");
            free((void*)jpg);
        }
        if ((unsigned long )fp == (unsigned long )((void*)0)){
            return;
        }
        {
            tmp = fgetc(fp);
        }
        if (tmp != 255){
            {
                tmp___0 = fgetc(fp);
            }
            if (tmp___0 != 216){
                {
                    fclose(fp);
                    diagnostics(1, (char*)"\'%s\' is not really a JPEG file --- skipping");
                }
                return;
            }
        }
        {
            while (1){
                while_continue:
                ;
                {
                    while (1){
                        while_continue___0:
                        ;
                        {
                            tmp___1 = feof(fp);
                        }
                        if (tmp___1){
                            goto while_break___0;
                        }else{
                            {
                                tmp___2 = fgetc(fp);
                            }
                            if (!(tmp___2 != 255)){
                                goto while_break___0;
                            }
                        }
                    }
                    while_break___0:
                    ;
                }
                {
                    while (1){
                        while_continue___1:
                        ;
                        {
                            tmp___3 = feof(fp);
                        }
                        if (tmp___3){
                            goto while_break___1;
                        }else{
                            {
                                m = fgetc(fp);
                            }
                            if (!(m == 255)){
                                goto while_break___1;
                            }
                        }
                    }
                    while_break___1:
                    ;
                }
                {
                    tmp___4 = feof(fp);
                }
                if (tmp___4){
                    goto while_break;
                }else
                    if (m != 192){
                        if (m != 193){
                            if (m != 194){
                                if (m != 195){
                                    if (m != 197){
                                        if (m != 198){
                                            if (m != 199){
                                                if (m != 201){
                                                    if (m != 202){
                                                        if (m != 203){
                                                            if (m != 205){
                                                                if (m != 206){
                                                                    if (!(m != 207)){
                                                                        goto while_break;
                                                                    }
                                                                }else{
                                                                    goto while_break;
                                                                }
                                                            }else{
                                                                goto while_break;
                                                            }
                                                        }else{
                                                            goto while_break;
                                                        }
                                                    }else{
                                                        goto while_break;
                                                    }
                                                }else{
                                                    goto while_break;
                                                }
                                            }else{
                                                goto while_break;
                                            }
                                        }else{
                                            goto while_break;
                                        }
                                    }else{
                                        goto while_break;
                                    }
                                }else{
                                    goto while_break;
                                }
                            }else{
                                goto while_break;
                            }
                        }else{
                            goto while_break;
                        }
                    }else{
                        goto while_break;
                    }
            }
            while_break:
            ;
        }
        {
            tmp___5 = fseek(fp, 3L, 1);
        }
        if (tmp___5){
            {
                diagnostics(1, (char*)"Cannot read graphics file \'%s\'", s);
                fclose(fp);
            }
            return;
        }else{
            {
                tmp___6 = fread((void*)(buffer___0), (size_t)2, (size_t)2, (FILE*)fp);
            }
            if (tmp___6 != 2UL){
                {
                    diagnostics(1, (char*)"Cannot read graphics file \'%s\'", s);
                    fclose(fp);
                }
                return;
            }
        }
        width = buffer___0[1];
        height = buffer___0[0];
        if (g_little_endian){
            width = (uint16_t)((((int)width & 65280) >> 8) | (((int)width & 255) << 8));
            height = (uint16_t)((((int)height & 65280) >> 8) | (((int)height & 255) << 8));
        }
        {
            diagnostics(4, (char*)"width = %d, height = %d", (int)width, (int)height);
            w = (uint32_t)((100000.0 * (double)width) / ((double)20 * 2834.65));
            h = (uint32_t)((100000.0 * (double)height) / ((double)20 * 2834.65));
            fprintRTF((char*)"\n{\\pict\\jpegblip\\picw%ld\\pich%ld", w, h);
            fprintRTF((char*)"\\picwgoal%ld\\pichgoal%ld\n", (int)width * 20, (int)height * 20);
            AdjustScaling((double)((int)height * 20), (double)((int)width * 20), height0, width0, scale, &sx, &sy);
        }
        if ((int)sx != 100){
            if ((int)sy != 100){
                {
                    fprintRTF((char*)"\\picscalex%d\\picscaley%d", (int)sx, (int)sy);
                }
            }
        }
        {
            rewind(fp);
            PutHexFile(fp);
            fprintRTF((char*)"}\n");
            fclose(fp);
        }
        return;
    }
}

static void PutEmfFile(char* s, double height0, double width0, double scale, double baseline)
{
    FILE* fp;
    char* emf;
    uint32_t RecordType;
    uint32_t RecordSize;
    int32_t BoundsLeft;
    int32_t BoundsRight;
    int32_t BoundsTop;
    int32_t BoundsBottom;
    int32_t FrameLeft;
    int32_t FrameRight;
    int32_t FrameTop;
    int32_t FrameBottom;
    uint32_t Signature;
    uint32_t w;
    uint32_t h;
    uint32_t width;
    uint32_t height;
    uint16_t sx;
    uint16_t sy;
    size_t tmp;
    size_t tmp___0;
    size_t tmp___1;
    size_t tmp___2;
    size_t tmp___3;
    size_t tmp___4;
    size_t tmp___5;
    size_t tmp___6;
    size_t tmp___7;
    size_t tmp___8;
    size_t tmp___9;
    {
        {
            emf = strdup((const char*)s);
            diagnostics(2, (char*)"PutEmfFile \'%s\'", emf);
            fp = fopen((const char*)emf, (const char*)"rb");
            free((void*)emf);
        }
        if ((unsigned long )fp == (unsigned long )((void*)0)){
            return;
        }
        {
            tmp = fread((void*)(&RecordType), (size_t)4, (size_t)1, (FILE*)fp);
        }
        if (tmp != 1UL){
            goto out;
        }
        {
            tmp___0 = fread((void*)(&RecordSize), (size_t)4, (size_t)1, (FILE*)fp);
        }
        if (tmp___0 != 1UL){
            goto out;
        }
        {
            tmp___1 = fread((void*)(&BoundsLeft), (size_t)4, (size_t)1, (FILE*)fp);
        }
        if (tmp___1 != 1UL){
            goto out;
        }
        {
            tmp___2 = fread((void*)(&BoundsTop), (size_t)4, (size_t)1, (FILE*)fp);
        }
        if (tmp___2 != 1UL){
            goto out;
        }
        {
            tmp___3 = fread((void*)(&BoundsRight), (size_t)4, (size_t)1, (FILE*)fp);
        }
        if (tmp___3 != 1UL){
            goto out;
        }
        {
            tmp___4 = fread((void*)(&BoundsBottom), (size_t)4, (size_t)1, (FILE*)fp);
        }
        if (tmp___4 != 1UL){
            goto out;
        }
        {
            tmp___5 = fread((void*)(&FrameLeft), (size_t)4, (size_t)1, (FILE*)fp);
        }
        if (tmp___5 != 1UL){
            goto out;
        }
        {
            tmp___6 = fread((void*)(&FrameRight), (size_t)4, (size_t)1, (FILE*)fp);
        }
        if (tmp___6 != 1UL){
            goto out;
        }
        {
            tmp___7 = fread((void*)(&FrameTop), (size_t)4, (size_t)1, (FILE*)fp);
        }
        if (tmp___7 != 1UL){
            goto out;
        }
        {
            tmp___8 = fread((void*)(&FrameBottom), (size_t)4, (size_t)1, (FILE*)fp);
        }
        if (tmp___8 != 1UL){
            goto out;
        }
        {
            tmp___9 = fread((void*)(&Signature), (size_t)4, (size_t)1, (FILE*)fp);
        }
        if (tmp___9 != 1UL){
            goto out;
        }
        if (!g_little_endian){
            RecordType = ((((RecordType & 4278190080U) >> 24) | ((RecordType & 16711680U) >> 8)) | ((RecordType & 65280U) << 8)) | ((RecordType & 255U) << 24);
            RecordSize = ((((RecordSize & 4278190080U) >> 24) | ((RecordSize & 16711680U) >> 8)) | ((RecordSize & 65280U) << 8)) | ((RecordSize & 255U) << 24);
            BoundsLeft = (int32_t)((((((unsigned int)BoundsLeft & 4278190080U) >> 24) | (unsigned int)((BoundsLeft & 16711680) >> 8)) | (unsigned int)((BoundsLeft & 65280) << 8)) | (unsigned int)((BoundsLeft & 255) << 24));
            BoundsTop = (int32_t)((((((unsigned int)BoundsTop & 4278190080U) >> 24) | (unsigned int)((BoundsTop & 16711680) >> 8)) | (unsigned int)((BoundsTop & 65280) << 8)) | (unsigned int)((BoundsTop & 255) << 24));
            BoundsRight = (int32_t)((((((unsigned int)BoundsRight & 4278190080U) >> 24) | (unsigned int)((BoundsRight & 16711680) >> 8)) | (unsigned int)((BoundsRight & 65280) << 8)) | (unsigned int)((BoundsRight & 255) << 24));
            BoundsBottom = (int32_t)((((((unsigned int)BoundsBottom & 4278190080U) >> 24) | (unsigned int)((BoundsBottom & 16711680) >> 8)) | (unsigned int)((BoundsBottom & 65280) << 8)) | (unsigned int)((BoundsBottom & 255) << 24));
            FrameLeft = (int32_t)((((((unsigned int)FrameLeft & 4278190080U) >> 24) | (unsigned int)((FrameLeft & 16711680) >> 8)) | (unsigned int)((FrameLeft & 65280) << 8)) | (unsigned int)((FrameLeft & 255) << 24));
            FrameRight = (int32_t)((((((unsigned int)FrameRight & 4278190080U) >> 24) | (unsigned int)((FrameRight & 16711680) >> 8)) | (unsigned int)((FrameRight & 65280) << 8)) | (unsigned int)((FrameRight & 255) << 24));
            FrameTop = (int32_t)((((((unsigned int)FrameTop & 4278190080U) >> 24) | (unsigned int)((FrameTop & 16711680) >> 8)) | (unsigned int)((FrameTop & 65280) << 8)) | (unsigned int)((FrameTop & 255) << 24));
            FrameBottom = (int32_t)((((((unsigned int)FrameBottom & 4278190080U) >> 24) | (unsigned int)((FrameBottom & 16711680) >> 8)) | (unsigned int)((FrameBottom & 65280) << 8)) | (unsigned int)((FrameBottom & 255) << 24));
            Signature = ((((Signature & 4278190080U) >> 24) | ((Signature & 16711680U) >> 8)) | ((Signature & 65280U) << 8)) | ((Signature & 255U) << 24);
        }
        if (RecordType != 1U){
            goto out;
        }else
            if (Signature != 1179469088U){
                goto out;
            }

        {
            height = (uint32_t)(BoundsBottom - BoundsTop);
            width = (uint32_t)(BoundsRight - BoundsLeft);
            w = (uint32_t)((100000.0 * (double)width) / ((double)20 * 2834.65));
            h = (uint32_t)((100000.0 * (double)height) / ((double)20 * 2834.65));
            diagnostics(4, (char*)"width = %ld, height = %ld", width, height);
            fprintRTF((char*)"\n{\\pict\\emfblip\\picw%ld\\pich%ld", w, h);
            fprintRTF((char*)"\\picwgoal%ld\\pichgoal%ld\n", width * 20U, height * 20U);
            AdjustScaling((double)(height * 20U), (double)(width * 20U), height0, width0, scale, &sx, &sy);
        }
        if ((int)sx != 100){
            if ((int)sy != 100){
                {
                    fprintRTF((char*)"\\picscalex%d\\picscaley%d", (int)sx, (int)sy);
                }
            }
        }
        {
            rewind(fp);
            PutHexFile(fp);
            fprintRTF((char*)"}\n");
            fclose(fp);
        }
        return;
        out:
        {
            diagnostics(1, (char*)"Problem with file %s --- not included", s);
            fclose(fp);
        }
        return;
    }
}

static void PutWmfFile(char* s, double height0, double width0, double scale, double baseline)
{
    FILE* fp;
    char* wmf;
    uint32_t Key;
    uint16_t FileType;
    uint16_t HeaderSize;
    uint16_t Handle;
    uint16_t Left;
    uint16_t Top;
    uint16_t Right;
    uint16_t Bottom;
    uint16_t width;
    uint16_t height;
    uint16_t sx;
    uint16_t sy;
    uint32_t magic_number;
    size_t tmp;
    size_t tmp___0;
    size_t tmp___1;
    size_t tmp___2;
    size_t tmp___3;
    size_t tmp___4;
    int tmp___5;
    int tmp___6;
    size_t tmp___7;
    size_t tmp___8;
    {
        {
            magic_number = 2596720087U;
            wmf = strdup_together((const char*)g_home_dir, (const char*)s);
            diagnostics(2, (char*)"PutWmfFile \'%s\'", wmf);
            fp = fopen((const char*)wmf, (const char*)"rb");
            free((void*)wmf);
        }
        if ((unsigned long )fp == (unsigned long )((void*)0)){
            return;
        }
        {
            tmp = fread((void*)(&Key), (size_t)4, (size_t)1, (FILE*)fp);
        }
        if (tmp != 1UL){
            goto out;
        }
        if (!g_little_endian){
            Key = ((((Key & 4278190080U) >> 24) | ((Key & 16711680U) >> 8)) | ((Key & 65280U) << 8)) | ((Key & 255U) << 24);
        }
        if (Key == magic_number){
            {
                tmp___0 = fread((void*)(&Handle), (size_t)2, (size_t)1, (FILE*)fp);
            }
            if (tmp___0 != 1UL){
                goto out;
            }
            {
                tmp___1 = fread((void*)(&Left), (size_t)2, (size_t)1, (FILE*)fp);
            }
            if (tmp___1 != 1UL){
                goto out;
            }
            {
                tmp___2 = fread((void*)(&Top), (size_t)2, (size_t)1, (FILE*)fp);
            }
            if (tmp___2 != 1UL){
                goto out;
            }
            {
                tmp___3 = fread((void*)(&Right), (size_t)2, (size_t)1, (FILE*)fp);
            }
            if (tmp___3 != 1UL){
                goto out;
            }
            {
                tmp___4 = fread((void*)(&Bottom), (size_t)2, (size_t)1, (FILE*)fp);
            }
            if (tmp___4 != 1UL){
                goto out;
            }
            if (!g_little_endian){
                Left = (uint16_t)((((int)Left & 65280) >> 8) | (((int)Left & 255) << 8));
                Top = (uint16_t)((((int)Top & 65280) >> 8) | (((int)Top & 255) << 8));
                Right = (uint16_t)((((int)Right & 65280) >> 8) | (((int)Right & 255) << 8));
                Bottom = (uint16_t)((((int)Bottom & 65280) >> 8) | (((int)Bottom & 255) << 8));
            }
            {
                tmp___5 = abs((int)Right - (int)Left);
                width = (uint16_t)tmp___5;
                tmp___6 = abs((int)Top - (int)Bottom);
                height = (uint16_t)tmp___6;
            }
        }else{
            {
                rewind(fp);
                tmp___7 = fread((void*)(&FileType), (size_t)2, (size_t)1, (FILE*)fp);
            }
            if (tmp___7 != 1UL){
                goto out;
            }
            {
                tmp___8 = fread((void*)(&HeaderSize), (size_t)2, (size_t)1, (FILE*)fp);
            }
            if (tmp___8 != 1UL){
                goto out;
            }
            if (!g_little_endian){
                FileType = (uint16_t)((((int)FileType & 65280) >> 8) | (((int)FileType & 255) << 8));
                HeaderSize = (uint16_t)((((int)HeaderSize & 65280) >> 8) | (((int)HeaderSize & 255) << 8));
            }
            if ((int)FileType != 0){
                if ((int)FileType != 1){
                    goto out;
                }
            }
            if ((int)HeaderSize != 9){
                goto out;
            }
            width = (uint16_t)200;
            height = (uint16_t)200;
        }
        {
            diagnostics(4, (char*)"width = %d, height = %d", (int)width, (int)height);
            fprintRTF((char*)"\n{\\pict\\wmetafile1\\picw%d\\pich%d\n", (int)width, (int)height);
            AdjustScaling((double)height, (double)width, height0, width0, scale, &sx, &sy);
        }
        if ((int)sx != 100){
            if ((int)sy != 100){
                {
                    fprintRTF((char*)"\\picscalex%d\\picscaley%d", (int)sx, (int)sy);
                }
            }
        }
        {
            rewind(fp);
            PutHexFile(fp);
            fprintRTF((char*)"}\n");
            fclose(fp);
        }
        return;
        out:
        {
            diagnostics(1, (char*)"Problem with file %s --- not included", s);
            fclose(fp);
        }
        return;
    }
}

static void PutPdfFile(char* s, double height0, double width0, double scale, double baseline)
{
    char* png;
    {
        {
            diagnostics(1, (char*)"Rendering \'%s\'", s);
            png = pdf_to_png(s);
        }
        if (png){
            {
                PutPngFile(png, height0, width0, scale, baseline);
                my_unlink(png);
                safe_free(png);
            }
        }
        return;
    }
}

static void PutEpsFile(char* s, double height0, double width0, double scale, double baseline)
{
    char* png;
    {
        {
            diagnostics(1, (char*)"Rendering \'%s\'", s);
            png = eps_to_png(s);
        }
        if (png){
            {
                PutPngFile(png, height0, width0, scale, baseline);
                my_unlink(png);
                free((void*)png);
            }
        }
        return;
    }
}

static void PutTiffFile(char* s, double height0, double width0, double scale, double baseline)
{
    char* tiff;
    char* png;
    char* out;
    {
        {
            diagnostics(2, (char*)"PutTiffFile \'%s\'", s);
            png = strdup_new_extension((const char*)s, ".tiff", ".png");
        }
        if ((unsigned long )png == (unsigned long )((void*)0)){
            {
                png = strdup_new_extension((const char*)s, ".TIFF", ".png");
            }
            if ((unsigned long )png == (unsigned long )((void*)0)){
                return;
            }
        }
        {
            tiff = strdup_together((const char*)g_home_dir, (const char*)s);
            out = SysGraphicsConvert(1, 0, g_dots_per_inch, (const char*)tiff, (const char*)png);
        }
        if ((unsigned long )out != (unsigned long )((void*)0)){
            {
                PutPngFile(out, height0, width0, scale, baseline);
                my_unlink(out);
                free((void*)out);
            }
        }
        {
            free((void*)tiff);
            free((void*)png);
        }
        return;
    }
}

static void PutGifFile(char* s, double height0, double width0, double scale, double baseline)
{
    char* gif;
    char* png;
    char* out;
    {
        {
            diagnostics(2, (char*)"PutGifFile \'%s\'", s);
            png = strdup_new_extension((const char*)s, ".gif", ".png");
        }
        if ((unsigned long )png == (unsigned long )((void*)0)){
            {
                png = strdup_new_extension((const char*)s, ".GIF", ".png");
            }
            if ((unsigned long )png == (unsigned long )((void*)0)){
                return;
            }
        }
        {
            gif = strdup_together((const char*)g_home_dir, (const char*)s);
            out = SysGraphicsConvert(1, 0, g_dots_per_inch, (const char*)gif, (const char*)png);
        }
        if ((unsigned long )out != (unsigned long )((void*)0)){
            {
                PutPngFile(out, height0, width0, scale, baseline);
                my_unlink(out);
                free((void*)out);
            }
        }
        {
            free((void*)gif);
            free((void*)png);
        }
        return;
    }
}

static int ReadLine(FILE* fp)
{
    int thechar;
    {
        {
            while (1){
                while_continue:
                ;
                {
                    thechar = _IO_getc(fp);
                }
                if (thechar == -1){
                    {
                        fclose(fp);
                    }
                    return (0);
                }
                if (thechar == 10){
                    return (1);
                }
                if (thechar == 13){
                    {
                        thechar = _IO_getc(fp);
                    }
                    if (thechar == -1){
                        {
                            fclose(fp);
                        }
                        return (0);
                    }
                    if (thechar == 13){
                        return (1);
                    }
                    {
                        ungetc(thechar, fp);
                    }
                    return (1);
                }
            }
            while_break:
            ;
        }
    }
}

static double GetBaseline(const char* tex_file_stem, const char* pre)
{
    FILE* fp;
    int thechar;
    char* pbm_file_name;
    char magic[250];
    int width;
    int height;
    int items;
    int top___0;
    int bottom;
    double baseline;
    int tmp;
    int tmp___0;
    int tmp___1;
    int tmp___2;
    int tmp___3;
    {
        {
            baseline = 3.0;
            tmp = strcmp(pre, "$");
        }
        if (tmp != 0){
            {
                tmp___0 = strcmp(pre, "\\begin{math}");
            }
            if (tmp___0 != 0){
                {
                    tmp___1 = strcmp(pre, "\\(");
                }
                if (tmp___1 != 0){
                    return ((double)0);
                }
            }
        }
        {
            pbm_file_name = strdup_together(tex_file_stem, ".pbm");
            diagnostics(4, (char*)"GetBaseline opening=\'%s\'", pbm_file_name);
            fp = fopen((const char*)pbm_file_name, (const char*)"rb");
            free((void*)pbm_file_name);
        }
        if ((unsigned long )fp == (unsigned long )((void*)0)){
            return (baseline);
        }
        {
            items = fscanf((FILE*)fp, (const char*)"%c%c", &magic[0], &magic[1]);
        }
        if (items != 2){
            {
                diagnostics(1, (char*)"Bad header in PBM file");
                fclose(fp);
            }
            return (baseline);
        }else
            if ((int)magic[0] != 80){
                {
                    diagnostics(1, (char*)"Bad header in PBM file");
                    fclose(fp);
                }
                return (baseline);
            }else
                if ((int)magic[1] != 52){
                    {
                        diagnostics(1, (char*)"Bad header in PBM file");
                        fclose(fp);
                    }
                    return (baseline);
                }

        {
            items = fscanf((FILE*)fp, (const char*)" %s", magic);
        }
        {
            while (1){
                while_continue:
                ;
                if (items == 1){
                    if (!((int)magic[0] == 35)){
                        goto while_break;
                    }
                }else{
                    goto while_break;
                }
                {
                    tmp___2 = ReadLine(fp);
                }
                if (!tmp___2){
                    goto Exit;
                }
                {
                    items = fscanf((FILE*)fp, (const char*)"%s", magic);
                }
            }
            while_break:
            ;
        }
        {
            items = sscanf((const char*)(magic), (const char*)"%d", &width);
        }
        if (items != 1){
            goto Exit;
        }else
            if (width != 1){
                goto Exit;
            }

        {
            items = fscanf((FILE*)fp, (const char*)" %d", &height);
        }
        if (items != 1){
            goto Exit;
        }
        {
            tmp___3 = ReadLine(fp);
        }
        if (!tmp___3){
            goto Exit;
        }
        top___0 = height;
        {
            while (1){
                while_continue___0:
                ;
                if (!(top___0 > 0)){
                    goto while_break___0;
                }
                {
                    thechar = _IO_getc(fp);
                }
                if (thechar == -1){
                    goto Exit;
                }
                if (thechar != 0){
                    goto while_break___0;
                }
                top___0--;
            }
            while_break___0:
            ;
        }
        bottom = top___0 - 1;
        {
            while (1){
                while_continue___1:
                ;
                if (!(bottom > 0)){
                    goto while_break___1;
                }
                {
                    thechar = _IO_getc(fp);
                }
                if (thechar == -1){
                    goto Exit;
                }
                if (thechar == 0){
                    goto while_break___1;
                }
                bottom--;
            }
            while_break___1:
            ;
        }
        {
            baseline = ((double)bottom * 72.0) / (double)g_dots_per_inch;
            diagnostics(4, (char*)"height=%d top=%d bottom=%d baseline=%g", height, top___0, bottom, baseline);
        }
        Exit:
        {
            fclose(fp);
        }
        return (baseline);
    }
}

void PutLatexFile(const char* tex_file_stem, double scale, const char* pre)
{
    char* png_file_name;
    char* tmp_path;
    int bmoffset;
    int bad_res;
    double height_goal;
    double width_goal;
    double baseline;
    double png_xres;
    double png_yres;
    uint32_t png_width;
    uint32_t png_height;
    uint16_t png_resolution;
    double max_fig_size;
    {
        {
            png_file_name = (char*)((void*)0);
            baseline = (double)0;
            png_width = (uint32_t)0;
            png_height = (uint32_t)0;
            png_resolution = (uint16_t)0;
            max_fig_size = 32767.0 / 20.0;
            diagnostics(4, (char*)"Rendering LaTeX as a bitmap...");
            bmoffset = (int)g_dots_per_inch / 60 + 1;
            png_resolution = g_dots_per_inch;
            png_file_name = strdup_together(tex_file_stem, ".png");
            tmp_path = SysGraphicsConvert(3, bmoffset, png_resolution, tex_file_stem, (const char*)png_file_name);
        }
        if ((unsigned long )((void*)0) == (unsigned long )tmp_path){
            {
                diagnostics(1, (char*)"PutLatexFile failed to convert \'%s.tex\' to \'%s\'", tex_file_stem, png_file_name);
                safe_free(png_file_name);
            }
            return;
        }
        {
            GetPngSize(png_file_name, &png_width, &png_height, &png_xres, &png_yres, &bad_res);
        }
        if ((double)png_width > max_fig_size){
            goto _L;
        }else
            if ((double)png_height > max_fig_size){
                _L:
                if (png_height){
                    if (png_height > png_width){
                        png_resolution = (uint16_t)(((double)g_dots_per_inch / (double)png_height) * max_fig_size);
                    }else{
                        png_resolution = (uint16_t)(((double)g_dots_per_inch / (double)png_width) * max_fig_size);
                    }
                }else{
                    png_resolution = (uint16_t)(((double)g_dots_per_inch / (double)png_width) * max_fig_size);
                }
                {
                    safe_free(tmp_path);
                    tmp_path = SysGraphicsConvert(3, bmoffset, png_resolution, tex_file_stem, (const char*)png_file_name);
                }
                if ((unsigned long )tmp_path == (unsigned long )((void*)0)){
                    {
                        safe_free(png_file_name);
                    }
                    return;
                }
                {
                    GetPngSize(png_file_name, &png_width, &png_height, &png_xres, &png_yres, &bad_res);
                }
            }

        {
            baseline = GetBaseline(tex_file_stem, pre);
            diagnostics(4, (char*)"PutLatexFile bitmap has (height=%d,width=%d) baseline=%g  resolution=%u", png_height, png_width, baseline, (int)png_resolution);
            height_goal = (((scale * (double)png_height) * 2834.65) / png_yres) * 20.0 + 0.5;
            width_goal = (((scale * (double)png_width) * 2834.65) / png_xres) * 20.0 + 0.5;
            PutPngFile(png_file_name, height_goal, width_goal, scale * (double)100, baseline);
            safe_free(tmp_path);
            safe_free(png_file_name);
        }
        return;
    }
}

static char* SaveEquationAsFile(const char* post_begin_document, const char* pre, const char* eq_with_spaces, const char* post);
static int file_number = 0;

static char* SaveEquationAsFile(const char* post_begin_document, const char* pre, const char* eq_with_spaces, const char* post)
{
    FILE* f;
    char name[15];
    char* tmp_dir;
    char* tex_file_stem;
    char* tex_file_name;
    char* eq;
    int tmp;
    char* tmp___0;
    int tmp___1;
    int tmp___2;
    int tmp___3;
    {
        if (!pre){
            return ((char*)((void*)0));
        }else
            if (!eq_with_spaces){
                return ((char*)((void*)0));
            }else
                if (!post){
                    return ((char*)((void*)0));
                }

        {
            file_number++;
            tmp_dir = getTmpPath();
            snprintf((char*)(name), (size_t)15, (const char*)"l2r_%04d", file_number);
            tex_file_stem = strdup_together((const char*)tmp_dir, (const char*)(name));
            safe_free(tmp_dir);
            tex_file_name = strdup_together((const char*)tex_file_stem, ".tex");
            diagnostics(2, (char*)"SaveEquationAsFile = %s", tex_file_name);
            f = fopen((const char*)tex_file_name, (const char*)"w");
            safe_free(tex_file_name);
        }
        if ((unsigned long )f == (unsigned long )((void*)0)){
            {
                diagnostics(1, (char*)"Could not open \'%s\' to save equation", tex_file_stem);
                safe_free(tex_file_stem);
            }
            return ((char*)((void*)0));
        }
        {
            eq = strdup_noendblanks(eq_with_spaces);
            fprintf((FILE*)f, (const char*)"%s", g_preamble);
            fprintf((FILE*)f, (const char*)"\\thispagestyle{empty}\n");
            fprintf((FILE*)f, (const char*)"\\begin{document}\n");
        }
        if (post_begin_document){
            {
                fprintf((FILE*)f, (const char*)"%s\n", post_begin_document);
            }
        }
        {
            tmp = getCounter((char*)"equation");
            fprintf((FILE*)f, (const char*)"\\setcounter{equation}{%d}\n", tmp);
            tmp___1 = streq(pre, "$");
        }
        if (tmp___1){
            {
                fprintf((FILE*)f, (const char*)"%%INLINE_DOT_ON_BASELINE\n");
                fprintf((FILE*)f, (const char*)"%s\n.\\quad %s\n%s", pre, eq, post);
            }
        }else{
            {
                tmp___2 = streq(pre, "\\begin{math}");
            }
            if (tmp___2){
                {
                    fprintf((FILE*)f, (const char*)"%%INLINE_DOT_ON_BASELINE\n");
                    fprintf((FILE*)f, (const char*)"%s\n.\\quad %s\n%s", pre, eq, post);
                }
            }else{
                {
                    tmp___3 = streq(pre, "\\(");
                }
                if (tmp___3){
                    {
                        fprintf((FILE*)f, (const char*)"%%INLINE_DOT_ON_BASELINE\n");
                        fprintf((FILE*)f, (const char*)"%s\n.\\quad %s\n%s", pre, eq, post);
                    }
                }else{
                    {
                        tmp___0 = strstr(pre, "equation");
                    }
                    if (tmp___0){
                        {
                            fprintf((FILE*)f, (const char*)"$$%s$$", eq);
                        }
                    }else{
                        {
                            fprintf((FILE*)f, (const char*)"%s\n%s\n%s", pre, eq, post);
                        }
                    }
                }
            }
        }
        {
            fprintf((FILE*)f, (const char*)"\n\\end{document}");
            fclose(f);
            free((void*)eq);
        }
        return (tex_file_stem);
    }
}

void PrepareDisplayedBitmap(char* the_type)
{
    {
        {
            CmdEndParagraph(0);
            CmdVspace(1);
            CmdIndent(1);
            startParagraph((const char*)the_type, 1);
        }
        return;
    }
}

void FinishDisplayedBitmap(void)
{
    {
        {
            CmdEndParagraph(0);
            CmdVspace(1);
            CmdIndent(2);
        }
        return;
    }
}

static char* abbreviate(const char* s, int len)
{
    char* t;
    char* p;
    int i;
    int n;
    int half;
    char* tmp;
    size_t tmp___0;
    void* tmp___1;
    {
        if ((unsigned long )s == (unsigned long )((void*)0)){
            {
                tmp = strdup("< EMPTY >");
            }
            return (tmp);
        }
        {
            tmp___0 = strlen(s);
            n = (int)tmp___0;
        }
        if (n < len){
            {
                t = strdup(s);
            }
        }else{
            {
                tmp___1 = malloc((unsigned long )len * sizeof (char));
                t = (char*)tmp___1;
                half = (len - 6) / 2;
                i = 0;
            }
            {
                while (1){
                    while_continue:
                    ;
                    if (!(i <= half)){
                        goto while_break;
                    }
                    *(t + i) = (char)*(s + i);
                    i++;
                }
                while_break:
                ;
            }
            *(t + (half + 1)) = (char)' ';
            *(t + (half + 2)) = (char)'.';
            *(t + (half + 3)) = (char)'.';
            *(t + (half + 4)) = (char)'.';
            *(t + (half + 5)) = (char)' ';
            i = 0;
            {
                while (1){
                    while_continue___0:
                    ;
                    if (!(i <= half)){
                        goto while_break___0;
                    }
                    *(t + ((half + 6) + i)) = (char)*(s + ((n - half) + i));
                    i++;
                }
                while_break___0:
                ;
            }
        }
        {
            while (1){
                while_continue___1:
                ;
                {
                    p = strchr((const char*)t, '\n');
                }
                if (!p){
                    goto while_break___1;
                }
                *p = (char)' ';
            }
            while_break___1:
            ;
        }
        return (t);
    }
}

void WriteLatexAsBitmap(char* pre, char* eq, char* post)
{
    char* p;
    char* abbrev;
    char* latex_to_convert;
    char* name;
    size_t tmp;
    size_t tmp___0;
    char* tmp___1;
    char* tmp___2;
    int tmp___3;
    int tmp___4;
    char* tmp___5;
    char* tmp___6;
    char* tmp___7;
    char* tmp___8;
    char* tmp___9;
    char* tmp___10;
    char* tmp___11;
    {
        {
            name = (char*)((void*)0);
            latex_to_convert = strdup_together3((const char*)pre, (const char*)eq, (const char*)post);
            abbrev = abbreviate((const char*)latex_to_convert, 50);
            diagnostics(1, (char*)"Rendering \'%s\'", abbrev);
            safe_free(abbrev);
            safe_free(latex_to_convert);
        }
        if ((unsigned long )eq == (unsigned long )((void*)0)){
            return;
        }
        if (pre){
            {
                tmp___4 = streq((const char*)pre, "\\begin{eqnarray}");
            }
            if (tmp___4){
                {
                    p = strstr((const char*)eq, "\\label");
                }
                if (p){
                    {
                        tmp = strlen((const char*)p);
                    }
                    if (tmp > 6UL){
                        {
                            p = strstr((const char*)(p + 6), "\\label");
                        }
                    }
                }
                if ((unsigned long )p == (unsigned long )((void*)0)){
                    {
                        name = SaveEquationAsFile((const char*)((void*)0), "\\begin{eqnarray*}", (const char*)eq, "\\end{eqnarray*}");
                    }
                }else{
                    {
                        name = SaveEquationAsFile((const char*)((void*)0), (const char*)pre, (const char*)eq, (const char*)post);
                    }
                }
            }else{
                goto _L___0;
            }
        }else
            _L___0:
            if (pre){
                {
                    tmp___3 = streq((const char*)pre, "\\begin{align}");
                }
                if (tmp___3){
                    {
                        p = strstr((const char*)eq, "\\label");
                    }
                    if (p){
                        {
                            tmp___0 = strlen((const char*)p);
                        }
                        if (tmp___0 > 6UL){
                            {
                                p = strstr((const char*)(p + 6), "\\label");
                            }
                        }
                    }
                    if (p){
                        {
                            name = SaveEquationAsFile((const char*)((void*)0), (const char*)pre, (const char*)eq, (const char*)post);
                        }
                    }else{
                        {
                            name = SaveEquationAsFile((const char*)((void*)0), "\\begin{align*}", (const char*)eq, "\\end{align*}");
                        }
                    }
                }else{
                    goto _L;
                }
            }else
                _L:
                if (pre){
                    {
                        tmp___1 = strstr((const char*)pre, "psgraph");
                    }
                    if (tmp___1){
                        {
                            p = strdup_together((const char*)g_psset_info, (const char*)g_psstyle_info);
                            name = SaveEquationAsFile((const char*)p, (const char*)pre, (const char*)eq, (const char*)post);
                            safe_free(p);
                        }
                    }else{
                        {
                            tmp___2 = strstr((const char*)pre, "pspicture");
                        }
                        if (tmp___2){
                            {
                                p = strdup_together((const char*)g_psset_info, (const char*)g_psstyle_info);
                                name = SaveEquationAsFile((const char*)p, (const char*)pre, (const char*)eq, (const char*)post);
                                safe_free(p);
                            }
                        }else{
                            {
                                name = SaveEquationAsFile((const char*)((void*)0), (const char*)pre, (const char*)eq, (const char*)post);
                            }
                        }
                    }
                }else{
                    {
                        name = SaveEquationAsFile((const char*)((void*)0), (const char*)pre, (const char*)eq, (const char*)post);
                    }
                }

        if (name){
            {
                tmp___5 = strstr((const char*)pre, "music");
            }
            if (tmp___5){
                {
                    PutLatexFile((const char*)name, g_png_figure_scale, (const char*)pre);
                }
            }else{
                {
                    tmp___6 = strstr((const char*)pre, "figure");
                }
                if (tmp___6){
                    {
                        PutLatexFile((const char*)name, g_png_figure_scale, (const char*)pre);
                    }
                }else{
                    {
                        tmp___7 = strstr((const char*)pre, "picture");
                    }
                    if (tmp___7){
                        {
                            PutLatexFile((const char*)name, g_png_figure_scale, (const char*)pre);
                        }
                    }else{
                        {
                            tmp___8 = strstr((const char*)pre, "tabular");
                        }
                        if (tmp___8){
                            {
                                PutLatexFile((const char*)name, g_png_figure_scale, (const char*)pre);
                            }
                        }else{
                            {
                                tmp___9 = strstr((const char*)pre, "tabbing");
                            }
                            if (tmp___9){
                                {
                                    PutLatexFile((const char*)name, g_png_figure_scale, (const char*)pre);
                                }
                            }else{
                                {
                                    tmp___10 = strstr((const char*)pre, "psgraph");
                                }
                                if (tmp___10){
                                    {
                                        PutLatexFile((const char*)name, g_png_figure_scale, (const char*)pre);
                                    }
                                }else{
                                    {
                                        tmp___11 = strstr((const char*)pre, "pspicture");
                                    }
                                    if (tmp___11){
                                        {
                                            PutLatexFile((const char*)name, g_png_figure_scale, (const char*)pre);
                                        }
                                    }else{
                                        {
                                            PutLatexFile((const char*)name, g_png_equation_scale, (const char*)pre);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            {
                safe_free(name);
            }
        }
        return;
    }
}

static char* upper_case_string(const char* s)
{
    char* t;
    char* x;
    int tmp;
    const unsigned short **tmp___0;
    {
        if (!s){
            return ((char*)((void*)0));
        }
        {
            t = strdup(s);
            x = t;
        }
        {
            while (1){
                while_continue:
                ;
                if (!*x){
                    goto while_break;
                }
                {
                    tmp___0 = __ctype_b_loc();
                }
                if ((const int)*(*tmp___0 + (int)*x) & 512){
                    {
                        tmp = toupper((int)*x);
                        *x = (char)tmp;
                    }
                }
                x++;
            }
            while_break:
            ;
        }
        return (t);
    }
}

static char* exists_with_extension(const char* dir, const char* name, const char* ext)
{
    char* t;
    char* x;
    int tmp;
    int tmp___0;
    {
        {
            t = strdup_together3(dir, name, ext);
            tmp = file_exists(t);
        }
        if (tmp){
            return (t);
        }
        {
            safe_free(t);
            x = upper_case_string(ext);
            t = strdup_together3(dir, name, (const char*)x);
            safe_free(x);
            tmp___0 = file_exists(t);
        }
        if (tmp___0){
            return (t);
        }
        {
            safe_free(t);
        }
        return ((char*)((void*)0));
    }
}

static char* exists_with_any_extension(const char* dir, const char* name, const char* ext)
{
    char* x;
    char* newpath;
    int i;
    char* tmp;
    {
        if (nGraphicsPathElems == 0){
            {
                tmp = exists_with_extension(dir, name, ext);
            }
            return (tmp);
        }
        i = 0;
        {
            while (1){
                while_continue:
                ;
                if (!(i < nGraphicsPathElems)){
                    goto while_break;
                }
                {
                    newpath = strdup_together(dir, (const char*)*(graphicsPath + i));
                    diagnostics(4, (char*)"does \'%s%s%s\' exist?", newpath, name, ext);
                    x = exists_with_extension((const char*)newpath, name, ext);
                    safe_free(newpath);
                }
                if (x){
                    return (x);
                }
                i++;
            }
            while_break:
            ;
        }
        return ((char*)((void*)0));
    }
}

static void HandleGraphicsOptions(char* opt, char* opt2, double* h, double* w, double* s)
{
    char* key;
    char* value;
    double llx;
    double lly;
    double urx;
    double ury;
    int tmp;
    int tmp___0;
    int tmp___1;
    int tmp___2;
    int tmp___3;
    int tmp___4;
    int tmp___5;
    int tmp___6;
    int tmp___7;
    int tmp___8;
    int tmp___9;
    int tmp___10;
    int tmp___11;
    int tmp___12;
    int tmp___13;
    int tmp___14;
    int tmp___15;
    int tmp___16;
    int tmp___17;
    char* tmp___18;
    char* tmp___19;
    char* tmp___20;
    char* tmp___21;
    char* tmp___22;
    char* tmp___23;
    char* tmp___24;
    char* tmp___25;
    char* tmp___26;
    char* tmp___27;
    char* tmp___28;
    {
        {
            llx = (double)0;
            lly = (double)0;
            urx = (double)0;
            ury = (double)0;
            *s = 1.0;
            *h = (double)0;
            *w = (double)0;
            diagnostics(4, (char*)"HandleGraphicsOptions <%s> <%s>", opt, opt2);
        }
        if (opt){
            if (opt2){
                {
                    opt = keyvalue_pair(opt, &key, &value);
                }
                if (!key){
                    return;
                }
                {
                    tmp = getStringDimension(key);
                    llx = (double)tmp;
                    free((void*)key);
                    keyvalue_pair(opt, &key, &value);
                }
                if (!key){
                    return;
                }
                {
                    tmp___0 = getStringDimension(key);
                    lly = (double)tmp___0;
                    free((void*)key);
                    opt2 = keyvalue_pair(opt2, &key, &value);
                }
                if (!key){
                    return;
                }
                {
                    tmp___1 = getStringDimension(key);
                    urx = (double)tmp___1;
                    free((void*)key);
                    keyvalue_pair(opt2, &key, &value);
                }
                if (!key){
                    return;
                }
                {
                    tmp___2 = getStringDimension(key);
                    ury = (double)tmp___2;
                    free((void*)key);
                    *h = ury - lly;
                    *w = urx - llx;
                }
                return;
            }
        }
        if (g_graphics_package == 1){
            if (opt){
                {
                    keyvalue_pair(opt, &key, &value);
                }
                if (!key){
                    return;
                }
                {
                    tmp___3 = getStringDimension(key);
                    *w = (double)tmp___3;
                    free((void*)key);
                    keyvalue_pair(opt, &key, &value);
                }
                if (!key){
                    return;
                }
                {
                    tmp___4 = getStringDimension(key);
                    *h = (double)tmp___4;
                    free((void*)key);
                }
                return;
            }
        }
        {
            while (1){
                while_continue:
                ;
                if (!opt){
                    goto while_break;
                }
                {
                    opt = keyvalue_pair(opt, &key, &value);
                }
                if (key){
                    {
                        diagnostics(5, (char*)"graphicx key=%s, value=%s", key, value);
                        tmp___28 = strstr((const char*)key, "height");
                    }
                    if (tmp___28){
                        {
                            tmp___5 = getStringDimension(value);
                            *h = (double)tmp___5;
                        }
                    }else{
                        {
                            tmp___27 = strstr((const char*)key, "natheight");
                        }
                        if (tmp___27){
                            {
                                tmp___6 = getStringDimension(value);
                                *h = (double)tmp___6;
                            }
                        }else{
                            {
                                tmp___26 = strstr((const char*)key, "totalheight");
                            }
                            if (tmp___26){
                                {
                                    tmp___7 = getStringDimension(value);
                                    *h = (double)tmp___7;
                                }
                            }else{
                                {
                                    tmp___25 = strstr((const char*)key, "width");
                                }
                                if (tmp___25){
                                    {
                                        tmp___8 = getStringDimension(value);
                                        *w = (double)tmp___8;
                                    }
                                }else{
                                    {
                                        tmp___24 = strstr((const char*)key, "natwidth");
                                    }
                                    if (tmp___24){
                                        {
                                            tmp___9 = getStringDimension(value);
                                            *w = (double)tmp___9;
                                        }
                                    }else{
                                        {
                                            tmp___23 = strstr((const char*)key, "bbllx");
                                        }
                                        if (tmp___23){
                                            {
                                                tmp___10 = getStringDimension(value);
                                                llx = (double)tmp___10;
                                            }
                                        }else{
                                            {
                                                tmp___22 = strstr((const char*)key, "bblly");
                                            }
                                            if (tmp___22){
                                                {
                                                    tmp___11 = getStringDimension(value);
                                                    lly = (double)tmp___11;
                                                }
                                            }else{
                                                {
                                                    tmp___21 = strstr((const char*)key, "bburx");
                                                }
                                                if (tmp___21){
                                                    {
                                                        tmp___12 = getStringDimension(value);
                                                        urx = (double)tmp___12;
                                                    }
                                                }else{
                                                    {
                                                        tmp___20 = strstr((const char*)key, "bbury");
                                                    }
                                                    if (tmp___20){
                                                        {
                                                            tmp___13 = getStringDimension(value);
                                                            ury = (double)tmp___13;
                                                        }
                                                    }else{
                                                        {
                                                            tmp___19 = strstr((const char*)key, "bb");
                                                        }
                                                        if (tmp___19){
                                                            {
                                                                tmp___14 = getStringDimension(value);
                                                                llx = (double)tmp___14;
                                                                tmp___15 = getStringDimension(value);
                                                                lly = (double)tmp___15;
                                                                tmp___16 = getStringDimension(value);
                                                                urx = (double)tmp___16;
                                                                tmp___17 = getStringDimension(value);
                                                                ury = (double)tmp___17;
                                                            }
                                                        }else{
                                                            {
                                                                tmp___18 = strstr((const char*)key, "scale");
                                                            }
                                                            if (tmp___18){
                                                                {
                                                                    sscanf((const char*)value, (const char*)"%lf", s);
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    {
                        free((void*)key);
                    }
                }
                if (value){
                    {
                        free((void*)value);
                    }
                }
            }
            while_break:
            ;
        }
        {
            diagnostics(5, (char*)"image scale  = %lf", *s);
            diagnostics(5, (char*)"image height = %lf", *h);
            diagnostics(5, (char*)"image width  = %lf", *w);
        }
        if (urx){
            *w = urx - llx;
        }
        if (ury){
            *h = ury - lly;
        }
        return;
    }
}

static void HandlePsfigOptions(char* opt, char** filename, double* h, double* w, double* s)
{
    char* key;
    char* value;
    int tmp;
    int tmp___0;
    char* tmp___1;
    char* tmp___2;
    char* tmp___3;
    {
        {
            *s = 1.0;
            *h = 0.0;
            *w = 0.0;
            *filename = (char*)((void*)0);
            diagnostics(4, (char*)"HandlePsfigOptions <%s>", opt);
        }
        {
            while (1){
                while_continue:
                ;
                if (!opt){
                    goto while_break;
                }
                {
                    opt = keyvalue_pair(opt, &key, &value);
                }
                if (key){
                    {
                        diagnostics(5, (char*)"psfig key=%s, value=%s", key, value);
                        tmp___3 = strstr((const char*)key, "figure");
                    }
                    if (tmp___3){
                        {
                            *filename = strdup((const char*)value);
                        }
                    }else{
                        {
                            tmp___2 = strstr((const char*)key, "height");
                        }
                        if (tmp___2){
                            {
                                tmp = getStringDimension(value);
                                *h = (double)tmp;
                            }
                        }else{
                            {
                                tmp___1 = strstr((const char*)key, "width");
                            }
                            if (tmp___1){
                                {
                                    tmp___0 = getStringDimension(value);
                                    *w = (double)tmp___0;
                                }
                            }
                        }
                    }
                    {
                        free((void*)key);
                    }
                }
                if (value){
                    {
                        free((void*)value);
                    }
                }
            }
            while_break:
            ;
        }
        return;
    }
}

void CmdGraphics(int code)
{
    char* options;
    char* options2;
    char* filename;
    double scale;
    double baseline;
    double height;
    double width;
    int n;
    int llx;
    int lly;
    int urx;
    int ury;
    char* s;
    GraphConvertElement* thisFormat;
    char* fullpathname;
    char* dir;
    char* name;
    char* ext;
    int tmp;
    {
        filename = (char*)((void*)0);
        scale = 1.0;
        baseline = 0.0;
        height = 0.0;
        width = 0.0;
        if (code == 1){
            {
                options = getBracketParam();
                options2 = getBracketParam();
                filename = getBraceParam();
                HandleGraphicsOptions(options, options2, &height, &width, &scale);
                safe_free(options);
                safe_free(options2);
            }
        }
        if (code == 2){
            {
                filename = getBraceParam();
            }
        }
        if (code == 3){
            {
                options = getBracketParam();
            }
            if (options){
                {
                    n = sscanf((const char*)options, (const char*)"%d %d %d %d", &llx, &lly, &urx, &ury);
                }
                if (n == 4){
                    width = (double)((urx - llx) * 20);
                    height = (double)((ury - lly) * 20);
                }
                {
                    free((void*)options);
                }
            }
            {
                filename = getBraceParam();
            }
        }
        if (code == 4){
            {
                filename = getBraceParam();
                s = strchr((const char*)filename, ' ');
            }
            if (s){
                *s = (char)'\000';
            }
        }
        if (code == 5){
            {
                options = getBraceParam();
                HandlePsfigOptions(options, &filename, &height, &width, &scale);
                diagnostics(4, (char*)"figure=%s, height=%d, width=%d, scale=%d", filename, height, width, scale);
                free((void*)options);
            }
        }
        if (filename){
            {
                fullpathname = (char*)((void*)0);
                dir = (char*)((void*)0);
                name = (char*)((void*)0);
                ext = (char*)((void*)0);
                changeTexMode(2);
                split_filename((const char*)filename, &dir, &name, &ext);
            }
            if (ext){
                {
                    fullpathname = exists_with_any_extension((const char*)dir, (const char*)name, (const char*)ext);
                }
                if (fullpathname){
                    thisFormat = GraphConvertTable;
                    {
                        while (1){
                            while_continue:
                            ;
                            if (!thisFormat->extension){
                                goto while_break;
                            }
                            {
                                tmp = strcasecmp((const char*)ext, (const char*)thisFormat->extension);
                            }
                            if (tmp == 0){
                                goto while_break;
                            }
                            thisFormat++;
                        }
                        while_break:
                        ;
                    }
                }
            }else{
                thisFormat = GraphConvertTable;
                {
                    while (1){
                        while_continue___0:
                        ;
                        if (!thisFormat->extension){
                            goto while_break___0;
                        }
                        {
                            fullpathname = exists_with_any_extension((const char*)dir, (const char*)name, (const char*)thisFormat->extension);
                        }
                        if (fullpathname){
                            goto while_break___0;
                        }
                        thisFormat++;
                    }
                    while_break___0:
                    ;
                }
            }
            if (fullpathname){
                if (thisFormat->extension){
                    {
                        diagnostics(2, (char*)"located graphics file as \'%s\'", fullpathname);
                        (*(thisFormat->encoder))(fullpathname, height, width, scale, baseline);
                    }
                }else{
                    {
                        diagnostics(1, (char*)"The graphics file \'%s\' was not found", filename);
                    }
                }
            }else{
                {
                    diagnostics(1, (char*)"The graphics file \'%s\' was not found", filename);
                }
            }
            {
                safe_free(dir);
                safe_free(name);
                safe_free(ext);
                safe_free(fullpathname);
                safe_free(filename);
            }
        }
        return;
    }
}

void CmdPsPicture(int code)
{
    char* contents;
    char post[16];
    {
        contents = (char*)((void*)0);
        post[0] = (char)'\\';
        post[1] = (char)'e';
        post[2] = (char)'n';
        post[3] = (char)'d';
        post[4] = (char)'{';
        post[5] = (char)'p';
        post[6] = (char)'s';
        post[7] = (char)'p';
        post[8] = (char)'i';
        post[9] = (char)'c';
        post[10] = (char)'t';
        post[11] = (char)'u';
        post[12] = (char)'r';
        post[13] = (char)'e';
        post[14] = (char)'}';
        post[15] = (char)'\000';
        if (!(code & 16384)){
            {
                diagnostics(4, (char*)"exiting CmdPsPicture");
            }
            return;
        }else{
            {
                diagnostics(4, (char*)"entering CmdPsPicture");
            }
        }
        {
            contents = getTexUntil(post, 0);
            PrepareDisplayedBitmap((char*)"PS picture");
            WriteLatexAsBitmap((char*)"\\begin{pspicture}", contents, post);
            FinishDisplayedBitmap();
            ConvertString((const char*)(post));
            safe_free(contents);
        }
        return;
    }
}

void CmdPsGraph(int code)
{
    char* contents;
    char post[14];
    {
        contents = (char*)((void*)0);
        post[0] = (char)'\\';
        post[1] = (char)'e';
        post[2] = (char)'n';
        post[3] = (char)'d';
        post[4] = (char)'{';
        post[5] = (char)'p';
        post[6] = (char)'s';
        post[7] = (char)'g';
        post[8] = (char)'r';
        post[9] = (char)'a';
        post[10] = (char)'p';
        post[11] = (char)'h';
        post[12] = (char)'}';
        post[13] = (char)'\000';
        if (!(code & 16384)){
            {
                diagnostics(4, (char*)"exiting CmdPsGraph");
            }
            return;
        }else{
            {
                diagnostics(4, (char*)"entering CmdPsGraph");
            }
        }
        {
            contents = getTexUntil(post, 0);
            PrepareDisplayedBitmap((char*)"PS Graph");
            WriteLatexAsBitmap((char*)"\\begin{psgraph}", contents, post);
            FinishDisplayedBitmap();
            ConvertString((const char*)(post));
            safe_free(contents);
        }
        return;
    }
}

void CmdPsset(int code)
{
    char* contents;
    char* tmp;
    {
        {
            tmp = getBraceParam();
            contents = tmp;
        }
        if (g_psset_info){
            {
                free((void*)g_psset_info);
            }
        }
        {
            g_psset_info = strdup_together3("\\psset{", (const char*)contents, "}");
            safe_free(contents);
        }
        return;
    }
}

void CmdNewPsStyle(int code)
{
    char* a;
    char* b;
    char* c;
    {
        {
            a = getBraceParam();
            b = getBraceParam();
            c = strdup_together4((const char*)g_psstyle_info, "\\newpsstyle{", (const char*)a, "}{");
        }
        if (g_psstyle_info){
            {
                free((void*)g_psstyle_info);
            }
        }
        {
            g_psstyle_info = strdup_together3((const char*)c, (const char*)b, "} ");
            safe_free(a);
            safe_free(b);
            safe_free(c);
        }
        return;
    }
}

void CmdPicture(int code)
{
    char* picture;
    char post[14];
    {
        picture = (char*)((void*)0);
        post[0] = (char)'\\';
        post[1] = (char)'e';
        post[2] = (char)'n';
        post[3] = (char)'d';
        post[4] = (char)'{';
        post[5] = (char)'p';
        post[6] = (char)'i';
        post[7] = (char)'c';
        post[8] = (char)'t';
        post[9] = (char)'u';
        post[10] = (char)'r';
        post[11] = (char)'e';
        post[12] = (char)'}';
        post[13] = (char)'\000';
        if (!(code & 16384)){
            {
                diagnostics(4, (char*)"exiting CmdPicture");
            }
            return;
        }else{
            {
                diagnostics(4, (char*)"entering CmdPicture");
            }
        }
        {
            picture = getTexUntil(post, 0);
            PrepareDisplayedBitmap((char*)"latex picture");
            WriteLatexAsBitmap((char*)"\\begin{picture}", picture, post);
            FinishDisplayedBitmap();
            ConvertString((const char*)(post));
            safe_free(picture);
        }
        return;
    }
}

void CmdMusic(int code)
{
    char* contents;
    char endmusic[12];
    {
        contents = (char*)((void*)0);
        endmusic[0] = (char)'\\';
        endmusic[1] = (char)'e';
        endmusic[2] = (char)'n';
        endmusic[3] = (char)'d';
        endmusic[4] = (char)'{';
        endmusic[5] = (char)'m';
        endmusic[6] = (char)'u';
        endmusic[7] = (char)'s';
        endmusic[8] = (char)'i';
        endmusic[9] = (char)'c';
        endmusic[10] = (char)'}';
        endmusic[11] = (char)'\000';
        if (!(code & 16384)){
            {
                diagnostics(4, (char*)"exiting CmdMusic");
            }
            return;
        }else{
            {
                diagnostics(4, (char*)"entering CmdMusic");
            }
        }
        {
            diagnostics(4, (char*)"entering CmdMusic");
            contents = getTexUntil(endmusic, 1);
            PrepareDisplayedBitmap((char*)"music");
            WriteLatexAsBitmap((char*)"\\begin{music}", contents, endmusic);
            FinishDisplayedBitmap();
            ConvertString((const char*)(endmusic));
            safe_free(contents);
        }
        return;
    }
}

extern void* (calloc)(size_t __nmemb, size_t __size);
extern void (exit)(int __status);
void newDefinition(char* name, char* opt_param, char* def, int params___0);
void renewDefinition(char* name, char* opt_param, char* def, int params___0);
void newEnvironment(char* name, char* opt_param, char* begdef, char* enddef, int params___0);
void renewEnvironment(char* name, char* opt_param, char* begdef, char* enddef, int params___0);
void newTheorem(char* name, char* caption, char* numbered_like, char* within);
int existsTheorem(char* s);
char* expandTheorem(int i, char* option);
void resetTheoremCounter(char* unit);
char* getBraceRawParam(void);
char* FormatUnitNumber(char* name);
char* my_strcpy(char* dest, const char* src);
void setCounter(char* s, int n);
void incrementCounter(char* s);
definition_type Definitions[2000];
environment_type NewEnvironments[200];
theorem_type NewTheorems[200];
static int iDefinitionCount = 0;
static int iNewEnvironmentCount = 0;
static int iNewTheoremCount = 0;

static int strequal(char* a, char* b)
{
    {
        if ((unsigned long )a == (unsigned long )((void*)0)){
            return (0);
        }else
            if ((unsigned long )b == (unsigned long )((void*)0)){
                return (0);
            }

        {
            while (1){
                while_continue:
                ;
                if (*a){
                    if (*b){
                        if (!((int)*a == (int)*b)){
                            goto while_break;
                        }
                    }else{
                        goto while_break;
                    }
                }else{
                    goto while_break;
                }
                a++;
                b++;
            }
            while_break:
            ;
        }
        if (*a){
            return (0);
        }else
            if (*b){
                return (0);
            }else{
                return (1);
            }
    }
}

static char* expandmacro(char* macro, char* opt_param, int params___0)
{
    int i;
    int param;
    char* args[9];
    char* dmacro;
    char* macro_piece;
    char* next_piece;
    char* expanded;
    char* buffer___0;
    char* cs;
    int buff_size;
    char* tmp;
    size_t tmp___0;
    size_t tmp___1;
    size_t tmp___2;
    void* tmp___3;
    size_t tmp___4;
    size_t tmp___5;
    size_t tmp___6;
    size_t tmp___7;
    size_t tmp___8;
    char c;
    const unsigned short **tmp___9;
    size_t tmp___10;
    size_t tmp___11;
    {
        {
            i = 0;
            buffer___0 = (char*)((void*)0);
            buff_size = 512;
            diagnostics(5, (char*)"expandmacro...");
            diagnostics(5, (char*)"expandmacro: contents \'%s\'", macro);
            diagnostics(5, (char*)"expandmacro: optional \'%s\'", opt_param);
            diagnostics(5, (char*)"expandmacro: num args  %d", params___0);
        }
        if (params___0 <= 0){
            {
                tmp = strdup((const char*)macro);
            }
            return (tmp);
        }
        if (opt_param){
            {
                args[0] = getBracketParam();
            }
            if (!args[0]){
                {
                    args[0] = strdup((const char*)opt_param);
                }
            }
            {
                tmp___0 = strlen((const char*)args[0]);
                buff_size += (int)tmp___0;
                i = 1;
            }
        }
        {
            while (1){
                while_continue:
                ;
                if (!(i < params___0)){
                    goto while_break;
                }
                {
                    args[i] = getBraceRawParam();
                    tmp___1 = strlen((const char*)args[i]);
                    buff_size = (int)((size_t)buff_size + tmp___1);
                    diagnostics(5, (char*)"Macro #%d --> \'%s\'", i + 1, args[i]);
                    i++;
                }
            }
            while_break:
            ;
        }
        {
            dmacro = strdup((const char*)macro);
            macro_piece = dmacro;
            tmp___2 = strlen((const char*)macro_piece);
            buff_size += (int)tmp___2;
            diagnostics(5, (char*)"expandmacro: buff_size = %d\n", buff_size);
        }
        if (buff_size > 0){
            {
                tmp___3 = calloc(sizeof (char) * (unsigned long )buff_size, sizeof (char));
                buffer___0 = (char*)tmp___3;
            }
        }
        expanded = buffer___0;
        {
            while (1){
                while_continue___0:
                ;
                {
                    cs = strstr((const char*)dmacro, "\\csname ");
                }
                if (!((unsigned long )cs != (unsigned long )((void*)0))){
                    goto while_break___0;
                }
                {
                    tmp___4 = strlen("\\csname ");
                    my_strcpy(cs + 1, (const char*)(cs + tmp___4));
                }
            }
            while_break___0:
            ;
        }
        {
            while (1){
                while_continue___1:
                ;
                {
                    cs = strstr((const char*)dmacro, "\\csname");
                }
                if (!((unsigned long )cs != (unsigned long )((void*)0))){
                    goto while_break___1;
                }
                {
                    tmp___5 = strlen("\\csname");
                    my_strcpy(cs + 1, (const char*)(cs + tmp___5));
                }
            }
            while_break___1:
            ;
        }
        {
            while (1){
                while_continue___2:
                ;
                {
                    cs = strstr((const char*)dmacro, "\\endcsname ");
                }
                if (!((unsigned long )cs != (unsigned long )((void*)0))){
                    goto while_break___2;
                }
                {
                    tmp___6 = strlen("\\endcsname ");
                    my_strcpy(cs, (const char*)(cs + tmp___6));
                }
            }
            while_break___2:
            ;
        }
        {
            while (1){
                while_continue___3:
                ;
                {
                    cs = strstr((const char*)dmacro, "\\endcsname");
                }
                if (!((unsigned long )cs != (unsigned long )((void*)0))){
                    goto while_break___3;
                }
                {
                    tmp___7 = strlen("\\endcsname");
                    my_strcpy(cs, (const char*)(cs + tmp___7));
                }
            }
            while_break___3:
            ;
        }
        {
            diagnostics(5, (char*)"expandmacro: after removing cs crap \'%s\'", macro_piece);
        }
        {
            while (1){
                while_continue___4:
                ;
                if (macro_piece){
                    if (!*macro_piece){
                        goto while_break___4;
                    }
                }else{
                    goto while_break___4;
                }
                {
                    param = -1;
                    next_piece = strchr((const char*)macro_piece, '#');
                }
                if (next_piece){
                    *next_piece = (char)'\000';
                    next_piece++;
                    if ((int)*next_piece == 35){
                        param = 9997;
                    }else{
                        param = (int)*next_piece - 49;
                    }
                    next_piece++;
                }
                {
                    diagnostics(5, (char*)"expandmacro: next section of macro before \'#\' is \'%s\'", macro_piece);
                    strcpy((char*)expanded, (const char*)macro_piece);
                    tmp___8 = strlen((const char*)macro_piece);
                    expanded += tmp___8;
                    diagnostics(5, (char*)"expandmacro: before appending next piece \'%s\'", buffer___0);
                }
                if (param > -1){
                    if (param == 9997){
                        {
                            diagnostics(5, (char*)"expandmacro: found ##, appending # to expanded macro");
                        }
                        if ((unsigned long )(expanded + 1) < (unsigned long )(buffer___0 + buff_size)){
                            *expanded = (char)'#';
                            expanded++;
                        }else{
                            {
                                diagnostics(1, (char*)"insufficient buffer to expand macro <%s>", macro);
                            }
                        }
                    }else
                        if (param < params___0){
                            {
                                diagnostics(5, (char*)"expandmacro: found #%d appending \'%s\'", param + 1, args[param]);
                                tmp___11 = strlen((const char*)args[param]);
                            }
                            if ((unsigned long )((expanded + tmp___11) + 1) < (unsigned long )(buffer___0 + buff_size)){
                                {
                                    c = *(expanded - 1);
                                    tmp___9 = __ctype_b_loc();
                                }
                                if ((const int)*(*tmp___9 + (int)c) & 1024){
                                    *expanded = (char)' ';
                                    expanded++;
                                }
                                {
                                    strcpy((char*)expanded, (const char*)args[param]);
                                    tmp___10 = strlen((const char*)args[param]);
                                    expanded += tmp___10;
                                }
                            }else{
                                {
                                    diagnostics(1, (char*)"expandmacro: insufficient buffer to expand macro <%s>", macro);
                                }
                            }
                        }else{
                            {
                                diagnostics(1, (char*)"expandmacro: confusing definition in macro=<%s>", macro);
                            }
                        }
                }
                macro_piece = next_piece;
            }
            while_break___4:
            ;
        }
        {
            expanded = strdup((const char*)buffer___0);
            i = 0;
        }
        {
            while (1){
                while_continue___5:
                ;
                if (!(i < params___0)){
                    goto while_break___5;
                }
                if (args[i]){
                    {
                        free((void*)args[i]);
                    }
                }
                i++;
            }
            while_break___5:
            ;
        }
        if (dmacro){
            {
                free((void*)dmacro);
            }
        }
        if (buffer___0){
            {
                free((void*)buffer___0);
            }
        }
        {
            diagnostics(4, (char*)"expandmacro: result is \'%s\'", expanded);
        }
        return (expanded);
    }
}

int maybeDefinition(char* s, size_t n)
{
    int i;
    int tmp;
    {
        if (n == 0UL){
            return (1);
        }
        i = 0;
        {
            while (1){
                while_continue:
                ;
                if (!(i < iDefinitionCount)){
                    goto while_break;
                }
                {
                    tmp = strncmp((const char*)s, (const char*)Definitions[i].name, n);
                }
                if (tmp == 0){
                    return (1);
                }
                i++;
            }
            while_break:
            ;
        }
        return (0);
    }
}

int existsDefinition(char* s)
{
    int i;
    int tmp;
    {
        i = 0;
        {
            while (1){
                while_continue:
                ;
                if (!(i < iDefinitionCount)){
                    goto while_break;
                }
                {
                    tmp = strcmp((const char*)s, (const char*)Definitions[i].name);
                }
                if (tmp == 0){
                    goto while_break;
                }
                i++;
            }
            while_break:
            ;
        }
        if (i == iDefinitionCount){
            return (-1);
        }else{
            return (i);
        }
    }
}

void newDefinition(char* name, char* opt_param, char* def, int params___0)
{
    int tmp;
    int tmp___0;
    int tmp___1;
    int tmp___2;
    int tmp___3;
    int tmp___4;
    {
        {
            diagnostics(2, (char*)"Adding macro \'%s\' = [%s]", name, def);
            tmp = strcmp((const char*)name, "LaTeX");
        }
        if (tmp == 0){
            return;
        }
        {
            tmp___0 = strcmp((const char*)name, "TeX");
        }
        if (tmp___0 == 0){
            return;
        }
        {
            tmp___1 = strcmp((const char*)name, "AmSTeX");
        }
        if (tmp___1 == 0){
            return;
        }
        {
            tmp___2 = strcmp((const char*)name, "BibTex");
        }
        if (tmp___2 == 0){
            return;
        }
        {
            tmp___3 = strcmp((const char*)name, "LaTeXe");
        }
        if (tmp___3 == 0){
            return;
        }
        {
            tmp___4 = strcmp((const char*)name, "AmSLaTeX");
        }
        if (tmp___4 == 0){
            return;
        }
        if (iDefinitionCount == 2000){
            {
                diagnostics(1, (char*)"Too many definitions, ignoring %s", name);
            }
            return;
        }
        {
            Definitions[iDefinitionCount].params = params___0;
            Definitions[iDefinitionCount].name = strdup((const char*)name);
        }
        if ((unsigned long )Definitions[iDefinitionCount].name == (unsigned long )((void*)0)){
            {
                diagnostics(0, (char*)"\nCannot allocate name for definition \\%s\n", name);
            }
        }
        if (opt_param){
            {
                Definitions[iDefinitionCount].opt_param = strdup((const char*)opt_param);
            }
            if ((unsigned long )Definitions[iDefinitionCount].opt_param == (unsigned long )((void*)0)){
                {
                    diagnostics(0, (char*)"\nCannot allocate opt_param for definition \\%s\n", name);
                }
            }
        }else{
            Definitions[iDefinitionCount].opt_param = (char*)((void*)0);
        }
        {
            Definitions[iDefinitionCount].def = strdup((const char*)def);
        }
        if ((unsigned long )Definitions[iDefinitionCount].def == (unsigned long )((void*)0)){
            {
                diagnostics(0, (char*)"\nCannot allocate def for definition \\%s\n", name);
            }
        }
        {
            iDefinitionCount++;
            diagnostics(3, (char*)"Successfully added macro #%d", iDefinitionCount);
        }
        return;
    }
}

void renewDefinition(char* name, char* opt_param, char* def, int params___0)
{
    int i;
    {
        {
            diagnostics(3, (char*)"renewDefinition seeking \'%s\'\n", name);
            i = existsDefinition(name);
        }
        if (i < 0){
            {
                newDefinition(name, opt_param, def, params___0);
                diagnostics(2, (char*)"No existing definition for \\%s", name);
            }
        }else{
            {
                free((void*)Definitions[i].def);
            }
            if (Definitions[i].opt_param){
                {
                    free((void*)Definitions[i].opt_param);
                }
            }
            Definitions[i].params = params___0;
            if (opt_param){
                {
                    Definitions[i].opt_param = strdup((const char*)opt_param);
                }
                if ((unsigned long )Definitions[i].opt_param == (unsigned long )((void*)0)){
                    {
                        diagnostics(0, (char*)"\nCannot allocate opt_param for definition \\%s\n", name);
                    }
                }
            }else{
                Definitions[i].opt_param = (char*)((void*)0);
            }
            {
                Definitions[i].def = strdup((const char*)def);
            }
            if ((unsigned long )Definitions[i].def == (unsigned long )((void*)0)){
                {
                    diagnostics(1, (char*)"\nCannot allocate def for definition \\%s\n", name);
                    exit(1);
                }
            }
        }
        return;
    }
}

char* expandDefinition(int thedef)
{
    const char* tmp;
    char* tmp___0;
    {
        if (thedef < 0){
            return ((char*)((void*)0));
        }else
            if (thedef >= iDefinitionCount){
                return ((char*)((void*)0));
            }

        {
            diagnostics(4, (char*)"expandDefinition name     =<%s>", Definitions[thedef].name);
        }
        if (Definitions[thedef].opt_param){
            tmp = (const char*)Definitions[thedef].opt_param;
        }else{
            tmp = "";
        }
        {
            diagnostics(5, (char*)"expandDefinition opt_param=<%s>", tmp);
            diagnostics(5, (char*)"expandDefinition def      =<%s>", Definitions[thedef].def);
            diagnostics(5, (char*)"expandDefinition params   =<%d>", Definitions[thedef].params);
            tmp___0 = expandmacro(Definitions[thedef].def, Definitions[thedef].opt_param, Definitions[thedef].params);
        }
        return (tmp___0);
    }
}

int existsEnvironment(char* s)
{
    int i;
    int tmp;
    {
        i = 0;
        {
            while (1){
                while_continue:
                ;
                if (i < iNewEnvironmentCount){
                    {
                        tmp = strequal(s, NewEnvironments[i].name);
                    }
                    if (tmp){
                        goto while_break;
                    }
                }else{
                    goto while_break;
                }
                {
                    diagnostics(6, (char*)"existsEnv seeking=<%s>, i=%d, current=<%s>", s, i, NewEnvironments[i].name);
                    i++;
                }
            }
            while_break:
            ;
        }
        if (i == iNewEnvironmentCount){
            return (-1);
        }else{
            {
                diagnostics(4, (char*)"user env found=<%s>, i=%d, current=<%s>", s, i, NewEnvironments[i].name);
            }
            return (i);
        }
    }
}

int maybeEnvironment(char* s, size_t n)
{
    int i;
    int tmp___1;
    int tmp___3;
    {
        if (n == 0UL){
            return (1);
        }
        i = 0;
        {
            while (1){
                while_continue:
                ;
                if (!(i < iNewEnvironmentCount)){
                    goto while_break;
                }
                {
                    tmp___1 = strncmp((const char*)s, (const char*)NewEnvironments[i].begname, n);
                }
                if (tmp___1 == 0){
                    return (1);
                }
                {
                    tmp___3 = strncmp((const char*)s, (const char*)NewEnvironments[i].endname, n);
                }
                if (tmp___3 == 0){
                    return (1);
                }
                i++;
            }
            while_break:
            ;
        }
        return (0);
    }
}

void newEnvironment(char* name, char* opt_param, char* begdef, char* enddef, int params___0)
{
    {
        if (iNewEnvironmentCount == 200){
            {
                diagnostics(1, (char*)"Too many newenvironments, ignoring %s", name);
            }
            return;
        }
        {
            NewEnvironments[iNewEnvironmentCount].name = strdup((const char*)name);
            NewEnvironments[iNewEnvironmentCount].begname = strdup_together("\\begin{", (const char*)name);
            NewEnvironments[iNewEnvironmentCount].endname = strdup_together("\\end{", (const char*)name);
            NewEnvironments[iNewEnvironmentCount].begdef = strdup((const char*)begdef);
            NewEnvironments[iNewEnvironmentCount].enddef = strdup((const char*)enddef);
            NewEnvironments[iNewEnvironmentCount].params = params___0;
        }
        if (opt_param){
            {
                NewEnvironments[iNewEnvironmentCount].opt_param = strdup((const char*)opt_param);
            }
            if ((unsigned long )NewEnvironments[iNewEnvironmentCount].opt_param == (unsigned long )((void*)0)){
                {
                    diagnostics(0, (char*)"\nCannot allocate opt_param for \\newenvironment{%s}", name);
                }
            }
        }else{
            NewEnvironments[iNewEnvironmentCount].opt_param = (char*)((void*)0);
        }
        if ((unsigned long )NewEnvironments[iNewEnvironmentCount].name == (unsigned long )((void*)0)){
            {
                diagnostics(0, (char*)"Cannot allocate memory for \\newenvironment{%s}", name);
            }
        }else
            if ((unsigned long )NewEnvironments[iNewEnvironmentCount].begdef == (unsigned long )((void*)0)){
                {
                    diagnostics(0, (char*)"Cannot allocate memory for \\newenvironment{%s}", name);
                }
            }else
                if ((unsigned long )NewEnvironments[iNewEnvironmentCount].begname == (unsigned long )((void*)0)){
                    {
                        diagnostics(0, (char*)"Cannot allocate memory for \\newenvironment{%s}", name);
                    }
                }else
                    if ((unsigned long )NewEnvironments[iNewEnvironmentCount].endname == (unsigned long )((void*)0)){
                        {
                            diagnostics(0, (char*)"Cannot allocate memory for \\newenvironment{%s}", name);
                        }
                    }else
                        if ((unsigned long )NewEnvironments[iNewEnvironmentCount].enddef == (unsigned long )((void*)0)){
                            {
                                diagnostics(0, (char*)"Cannot allocate memory for \\newenvironment{%s}", name);
                            }
                        }

        iNewEnvironmentCount++;
        return;
    }
}

void renewEnvironment(char* name, char* opt_param, char* begdef, char* enddef, int params___0)
{
    int i;
    {
        {
            i = existsEnvironment(name);
        }
        if (i < 0){
            {
                newEnvironment(name, opt_param, begdef, enddef, params___0);
                diagnostics(2, (char*)"No existing \\newevironment{%s}", name);
            }
        }else{
            {
                free((void*)NewEnvironments[i].begdef);
                free((void*)NewEnvironments[i].enddef);
                free((void*)NewEnvironments[i].begname);
                free((void*)NewEnvironments[i].endname);
            }
            if (NewEnvironments[i].opt_param){
                {
                    free((void*)NewEnvironments[i].opt_param);
                }
            }
            if (opt_param){
                {
                    NewEnvironments[i].opt_param = strdup((const char*)opt_param);
                }
                if ((unsigned long )NewEnvironments[i].opt_param == (unsigned long )((void*)0)){
                    {
                        diagnostics(0, (char*)"\nCannot allocate opt_param for \\renewenvironment{%s}", name);
                    }
                }
            }else{
                NewEnvironments[i].opt_param = (char*)((void*)0);
            }
            {
                NewEnvironments[i].params = params___0;
                NewEnvironments[i].begdef = strdup((const char*)begdef);
                NewEnvironments[i].enddef = strdup((const char*)enddef);
            }
            if ((unsigned long )NewEnvironments[i].begdef == (unsigned long )((void*)0)){
                {
                    diagnostics(0, (char*)"Cannot allocate memory for \\renewenvironment{%s}", name);
                }
            }else
                if ((unsigned long )NewEnvironments[i].enddef == (unsigned long )((void*)0)){
                    {
                        diagnostics(0, (char*)"Cannot allocate memory for \\renewenvironment{%s}", name);
                    }
                }
        }
        return;
    }
}

char* expandEnvironment(int thedef, int code)
{
    char* s;
    char* t;
    {
        if (thedef < 0){
            return ((char*)((void*)0));
        }else
            if (thedef >= iNewEnvironmentCount){
                return ((char*)((void*)0));
            }

        if (code == 1){
            {
                diagnostics(3, (char*)"\\begin{%s} <%s>", NewEnvironments[thedef].name, NewEnvironments[thedef].begdef);
                s = expandmacro(NewEnvironments[thedef].begdef, NewEnvironments[thedef].opt_param, NewEnvironments[thedef].params);
                t = strdup_together("{", (const char*)s);
            }
        }else{
            {
                diagnostics(3, (char*)"\\end{%s} <%s>", NewEnvironments[thedef].name, NewEnvironments[thedef].enddef);
                s = expandmacro(NewEnvironments[thedef].enddef, (char*)((void*)0), 0);
                t = strdup_together((const char*)s, "}");
            }
        }
        {
            free((void*)s);
        }
        return (t);
    }
}

void newTheorem(char* name, char* caption, char* numbered_like, char* within)
{
    {
        if (iNewTheoremCount == 200){
            {
                diagnostics(1, (char*)"Too many \\newtheorems, ignoring %s", name);
            }
            return;
        }
        {
            NewTheorems[iNewTheoremCount].name = strdup((const char*)name);
            NewTheorems[iNewTheoremCount].caption = strdup((const char*)caption);
        }
        if (numbered_like){
            {
                NewTheorems[iNewTheoremCount].numbered_like = strdup((const char*)numbered_like);
            }
        }else{
            {
                NewTheorems[iNewTheoremCount].numbered_like = strdup((const char*)name);
            }
        }
        if (within){
            {
                NewTheorems[iNewTheoremCount].within = strdup((const char*)within);
            }
        }else{
            NewTheorems[iNewTheoremCount].within = (char*)((void*)0);
        }
        {
            setCounter(NewTheorems[iNewTheoremCount].numbered_like, 0);
            iNewTheoremCount++;
        }
        return;
    }
}

int existsTheorem(char* s)
{
    int i;
    int tmp;
    {
        i = 0;
        {
            while (1){
                while_continue:
                ;
                if (i < iNewTheoremCount){
                    {
                        tmp = strequal(s, NewTheorems[i].name);
                    }
                    if (tmp){
                        goto while_break;
                    }
                }else{
                    goto while_break;
                }
                {
                    diagnostics(6, (char*)"seeking=<%s>, i=%d, current=<%s>", s, i, NewTheorems[i].name);
                    i++;
                }
            }
            while_break:
            ;
        }
        if (i == iNewTheoremCount){
            return (-1);
        }else{
            return (i);
        }
    }
}

char* expandTheorem(int i, char* option)
{
    char s[128];
    char* num;
    int ithm;
    char* tmp;
    char* tmp___0;
    {
        if (i < 0){
            {
                tmp = strdup("");
            }
            return (tmp);
        }else
            if (i >= iNewTheoremCount){
                {
                    tmp = strdup("");
                }
                return (tmp);
            }

        {
            incrementCounter(NewTheorems[i].numbered_like);
            ithm = getCounter(NewTheorems[i].numbered_like);
        }
        if (NewTheorems[i].within){
            {
                num = FormatUnitNumber(NewTheorems[i].within);
            }
            if (option){
                {
                    snprintf((char*)(s), (size_t)128, (const char*)"%s %s.%d (%s)", NewTheorems[i].caption, num, ithm, option);
                }
            }else{
                {
                    snprintf((char*)(s), (size_t)128, (const char*)"%s %s.%d", NewTheorems[i].caption, num, ithm);
                }
            }
            {
                free((void*)num);
            }
        }else
            if (option){
                {
                    snprintf((char*)(s), (size_t)128, (const char*)"%s %d (%s)", NewTheorems[i].caption, ithm, option);
                }
            }else{
                {
                    snprintf((char*)(s), (size_t)128, (const char*)"%s %d", NewTheorems[i].caption, ithm);
                }
            }

        {
            tmp___0 = strdup((const char*)(s));
        }
        return (tmp___0);
    }
}

void resetTheoremCounter(char* unit)
{
    int i;
    int tmp;
    {
        i = 0;
        {
            while (1){
                while_continue:
                ;
                if (!(i < iNewTheoremCount)){
                    goto while_break;
                }
                {
                    tmp = strequal(unit, NewTheorems[i].within);
                }
                if (tmp){
                    {
                        setCounter(NewTheorems[i].numbered_like, 0);
                    }
                }
                i++;
            }
            while_break:
            ;
        }
        return;
    }
}

extern void (qsort)(void* __base, size_t __nmemb, size_t __size, int (*__compar)(const void*, const void*));
char* g_bbl_name;
int g_processing_figure;
int g_processing_table;
int g_document_type;
int g_document_bibstyle;
int g_bbl_file_missing;
char* g_figure_label;
char* g_table_label;
char* g_equation_label;
char* g_section_label;
int g_tableofcontents;
void putRtfStrEscaped(const char* string);
char* strdup_noblanks(const char* s);
char* strdup_nocomments(const char* s);
int my_fgetc(FILE* f);
void PopEnvironment(void);
void ConvertBabelName(char* name);
void InitializeBibliography(void);
void CmdTheEndNotes(int code);
void CmdFootNote(int code);
void CmdLabel(int code);
void CmdNoCite(int code);
void CmdBibliographyStyle(int code);
void CmdBibStyle(int code);
void CmdBibliography(int code);
void CmdThebibliography(int code);
void CmdBibitem(int code);
void CmdNewblock(int code);
void CmdIndex(int code);
void CmdPrintIndex(int code);
void CmdHtml(int code);
void InsertBookmark(char* name, char* text);
void InsertContentMark(char marker, char* s1, char* s2, char* s3);
void CmdCite(int code);
void CmdHarvardCite(int code);
void CmdBCAY(int code);
void CmdApaCite(int code);
void set_longnamesfirst(void);
void set_bibpunct_style_super(void);
void set_bibpunct_style_number(void);
void set_bibpunct_style_separator(char* s);
void set_bibpunct_style_paren(char* open, char* close);
void set_sorted_citations(void);
void set_compressed_citations(void);
void CmdCiteName(int code);
void CmdNumberLine(int code);
void CmdContentsLine(int code);
void CmdListOf(int code);
void CmdHarvard(int code);
void CmdNatbibCite(int code);
void CmdBibpunct(int code);
void CmdBibEntry(int code);
void CmdNatexlab(int code);
char getNonBlank(void);
char* getDelimitedText(char left, char right, int raw);

inline static void ignoreBracketParam(void)
{
    char* p;
    char* tmp;
    {
        {
            tmp = getBracketParam();
            p = tmp;
        }
        if ((unsigned long )((void*)0) != (unsigned long )p){
            {
                free((void*)p);
            }
        }
        return;
    }
}

void setLength(char* s, int d);
void CmdFontFamily(int code);
int script_shift(void);
int script_size(void);
char* g_figure_label = (char*)((void*)0);
char* g_table_label = (char*)((void*)0);
char* g_equation_label = (char*)((void*)0);
char* g_section_label = (char*)((void*)0);
int g_suppress_name = 0;
static int g_warned_once = 0;
char* BIB_DASH_MARKER = (char*)"%dash%";
char* g_label_list[200];
int g_label_list_number = -1;
static char* g_all_citations[1000];
static int g_last_citation = 0;
static int g_current_cite_type = 0;
static int g_current_cite_seen = 0;
static int g_current_cite_paren = 0;
static char g_last_author_cited[201];
static char g_last_year_cited[51];
static int g_citation_longnamesfirst = 0;
static int g_current_cite_item = 0;
static int g_sorted_citations = 0;
static int g_compressed_citations = 0;
static char* g_bibpunct_open = (char*)((void*)0);
static char* g_bibpunct_close = (char*)((void*)0);
static char* g_bibpunct_cite_sep = (char*)((void*)0);
static char* g_bibpunct_author_date_sep = (char*)((void*)0);
static char* g_bibpunct_numbers_sep = (char*)((void*)0);
static char* g_bibpunct_postnote_sep = (char*)((void*)0);
static char* g_bibstyle_punct[2] = {(char*)"[", (char*)"]"};
static int g_bibpunct_cite_sep_touched = 0;
static int g_bibpunct_style_paren_touched = 0;
static int g_bibpunct_style = 0;
static int g_in_bibliography = 0;

void InitializeBibliography(void)
{
    {
        {
            g_bibpunct_open = strdup("(");
            g_bibpunct_close = strdup(")");
            g_bibpunct_cite_sep = strdup(",");
            g_bibpunct_author_date_sep = strdup(",");
            g_bibpunct_numbers_sep = strdup(",");
            g_bibpunct_postnote_sep = strdup(", ");
            g_bibpunct_cite_sep_touched = 0;
            g_bibpunct_style_paren_touched = 0;
            g_bibpunct_style = 0;
        }
        return;
    }
}

void set_longnamesfirst(void)
{
    {
        g_citation_longnamesfirst = 1;
        return;
    }
}

void set_bibpunct_style_super(void)
{
    {
        g_bibpunct_style = 1;
        return;
    }
}

void set_bibpunct_style_number(void)
{
    {
        g_bibpunct_style = 2;
        return;
    }
}

void set_bibpunct_style_separator(char* s)
{
    {
        {
            g_bibpunct_cite_sep_touched = 1;
            g_bibpunct_cite_sep = strdup((const char*)s);
        }
        return;
    }
}

void set_bibpunct_style_paren(char* open, char* close)
{
    {
        {
            g_bibpunct_style_paren_touched = 1;
            g_bibpunct_open = strdup((const char*)open);
            g_bibpunct_close = strdup((const char*)close);
        }
        return;
    }
}

void set_author_date_and_numbers_sep(char* ad, char* n)
{
    {
        {
            safe_free(g_bibpunct_author_date_sep);
            g_bibpunct_author_date_sep = strdup((const char*)ad);
            safe_free(g_bibpunct_numbers_sep);
            g_bibpunct_numbers_sep = strdup((const char*)n);
        }
        return;
    }
}

void set_sorted_citations(void)
{
    {
        g_sorted_citations = 1;
        return;
    }
}

void set_compressed_citations(void)
{
    {
        g_compressed_citations = 1;
        return;
    }
}

static int citation_used(char* citation)
{
    int i;
    int tmp;
    {
        i = 0;
        {
            while (1){
                while_continue:
                ;
                if (!(i < g_last_citation)){
                    goto while_break;
                }
                {
                    tmp = strcmp((const char*)citation, (const char*)g_all_citations[i]);
                }
                if (tmp == 0){
                    return (1);
                }
                i++;
            }
            while_break:
            ;
        }
        if (g_last_citation > 999){
            {
                diagnostics(1, (char*)"Too many citations ... increase MAX_CITATIONS");
            }
        }else{
            {
                g_all_citations[g_last_citation] = strdup((const char*)citation);
                g_last_citation++;
            }
        }
        return (0);
    }
}

static char* ScanAux(int token_id, char* reference, int code)
{
    char* tmp;
    char* tmp___0;
    char* tmp___1;
    char* tmp___2;
    {
        {
            if (token_id == 1){
                goto case_1;
            }
            if (token_id == 0){
                goto case_0___0;
            }
            goto switch_default___1;
            case_1:
            {
                if (code == 0){
                    goto case_0;
                }
                if (code == 1){
                    goto case_1___0;
                }
                goto switch_default;
                case_0:
                {
                    tmp = getLabelDefinition(reference);
                }
                return (tmp);
                case_1___0:
                {
                    tmp___0 = getLabelSection(reference);
                }
                return (tmp___0);
                switch_default:
                {
                    diagnostics(0, (char*)"assert failed in ScanAux: unknown code (%d) for token %d", code, token_id);
                }
                return ((char*)((void*)0));
                switch_break___0:
                ;
            }
            goto switch_break;
            case_0___0:
            {
                if (code == 0){
                    goto case_0___1;
                }
                if (code == 1){
                    goto case_1___1;
                }
                goto switch_default___0;
                case_0___1:
                {
                    tmp___1 = getBiblioRef(reference);
                }
                return (tmp___1);
                case_1___1:
                {
                    tmp___2 = getBiblioFirst(reference);
                }
                return (tmp___2);
                switch_default___0:
                {
                    diagnostics(0, (char*)"assert failed in ScanAux: unknown code (%d) for token %d", code, token_id);
                }
                return ((char*)((void*)0));
                switch_break___1:
                ;
            }
            goto switch_break;
            switch_default___1:
            {
                diagnostics(0, (char*)"assert failed in ScanAux: unknown token_id %d", token_id);
            }
            switch_break:
            ;
        }
        return ((char*)((void*)0));
    }
}

static char* ScanBbl(char* reference);
static FILE* f_bbl = (FILE*)((void*)0);

static char* ScanBbl(char* reference)
{
    char line[512];
    char* buffer___0;
    char* target;
    char* s;
    char last_c;
    int i;
    size_t tmp;
    char* tmp___0;
    void* tmp___1;
    int tmp___2;
    int tmp___3;
    {
        s = (char*)((void*)0);
        i = 1;
        if (g_bbl_file_missing){
            return ((char*)((void*)0));
        }else{
            {
                tmp = strlen((const char*)reference);
            }
            if (tmp == 0UL){
                return ((char*)((void*)0));
            }
        }
        {
            target = strdup_together3("{", (const char*)reference, "}");
            diagnostics(4, (char*)"seeking \'%s\' in .bbl", target);
        }
        if ((unsigned long )f_bbl == (unsigned long )((void*)0)){
            {
                f_bbl = my_fopen(g_bbl_name, (char*)"rb");
            }
            if ((unsigned long )f_bbl == (unsigned long )((void*)0)){
                {
                    diagnostics(1, (char*)"No .bbl file.  Run LaTeX to create one.");
                    g_bbl_file_missing = 1;
                }
                return ((char*)((void*)0));
            }
        }
        {
            rewind(f_bbl);
        }
        {
            while (1){
                while_continue:
                ;
                {
                    tmp___0 = my_fgets(line, 511, f_bbl);
                }
                if (!tmp___0){
                    goto while_break;
                }
                {
                    s = strstr((const char*)(line), (const char*)target);
                }
                if (s){
                    goto while_break;
                }
            }
            while_break:
            ;
        }
        {
            safe_free(target);
        }
        if ((unsigned long )s == (unsigned long )((void*)0)){
            return ((char*)((void*)0));
        }
        {
            tmp___1 = malloc((size_t)4096);
            buffer___0 = (char*)tmp___1;
            last_c = (char)'\000';
            i = 0;
        }
        {
            while (1){
                while_continue___0:
                ;
                if (!(i < 4096)){
                    goto while_break___0;
                }
                {
                    tmp___2 = my_fgetc(f_bbl);
                    *(buffer___0 + i) = (char)tmp___2;
                    tmp___3 = feof(f_bbl);
                }
                if (tmp___3){
                    goto while_break___0;
                }
                if ((int)*(buffer___0 + i) == 10){
                    if ((int)last_c == 10){
                        goto while_break___0;
                    }
                }
                last_c = *(buffer___0 + i);
                i++;
            }
            while_break___0:
            ;
        }
        {
            while (1){
                while_continue___1:
                ;
                if (!((int)*(buffer___0 + i) == 32)){
                    if (!((int)*(buffer___0 + i) == 10)){
                        goto while_break___1;
                    }
                }
                i--;
            }
            while_break___1:
            ;
        }
        if ((int)*(buffer___0 + i) == 46){
            i--;
        }
        {
            *(buffer___0 + (i + 1)) = (char)'\000';
            s = strdup((const char*)buffer___0);
            safe_free(buffer___0);
        }
        return (s);
    }
}

void CmdTheEndNotes(int code)
{
    {
        {
            diagnostics(4, (char*)"Entering CmdTheEndNotes");
            CmdVspace(3);
            startParagraph("bibliography", 3);
            fprintRTF((char*)"{\\sect ");
            InsertStyle("section");
            fprintRTF((char*)" Notes");
            CmdEndParagraph(0);
            fprintRTF((char*)"\\endnhere}");
        }
        return;
    }
}

static int thankno = 0;

void CmdFootNote(int code)
{
    char* number;
    char* text;
    {
        {
            diagnostics(4, (char*)"Entering ConvertFootNote");
            number = getBracketParam();
            text = getBraceParam();
        }
        {
            if (code == 3){
                goto case_3;
            }
            if (code == 1){
                goto case_1;
            }
            if (code == 2){
                goto case_2;
            }
            if (code == 4){
                goto case_4;
            }
            if (code == 5){
                goto case_5;
            }
            goto switch_break;
            case_3:
            {
                thankno++;
                fprintRTF((char*)"{");
                InsertStyle("footnote reference");
                fprintRTF((char*)" %d}\n", thankno);
                fprintRTF((char*)"{\\*\\footnote\\pard ");
                InsertStyle("footnote text");
                fprintRTF((char*)"{");
                InsertStyle("footnote reference");
                fprintRTF((char*)"%d} ", thankno);
            }
            goto switch_break;
            case_1:
            {
                fprintRTF((char*)"{");
                InsertStyle("footnote reference");
                fprintRTF((char*)"\\chftn}\n");
                fprintRTF((char*)"{\\*\\footnote\\pard ");
                InsertStyle("footnote text");
                fprintRTF((char*)"{");
                InsertStyle("footnote reference");
                fprintRTF((char*)"\\chftn} ");
            }
            goto switch_break;
            case_2:
            {
                fprintRTF((char*)"{\\*\\footnote\\pard ");
                InsertStyle("footnote text");
            }
            goto switch_break;
            case_4:
            {
                fprintRTF((char*)"{");
                InsertStyle("endnote reference");
                fprintRTF((char*)"\\chftn}\n");
                fprintRTF((char*)"{\\*\\footnote\\ftnalt\\pard ");
                InsertStyle("endnote text");
                fprintRTF((char*)"{");
                InsertStyle("endnote reference");
                fprintRTF((char*)"\\chftn} ");
            }
            goto switch_break;
            case_5:
            {
                fprintRTF((char*)"{\\*\\footnote\\ftnalt\\pard ");
                InsertStyle("endnote text");
            }
            goto switch_break;
            switch_break:
            ;
        }
        {
            ConvertString((const char*)text);
            fprintRTF((char*)"}\n");
            diagnostics(4, (char*)"Exiting CmdFootNote");
            safe_free(text);
        }
        if (number){
            {
                safe_free(number);
            }
        }
        return;
    }
}

void CmdNoCite(int code)
{
    char* tmp;
    {
        {
            tmp = getBraceParam();
            safe_free(tmp);
        }
        return;
    }
}

void CmdBibliographyStyle(int code)
{
    char* s;
    char* tmp;
    {
        {
            tmp = getBraceParam();
            s = tmp;
            diagnostics(4, (char*)"CmdBibliographyStyle <%s>", s);
            safe_free(s);
        }
        return;
    }
}

void CmdBibStyle(int code)
{
    char* s;
    char* tmp;
    int tmp___0;
    int tmp___1;
    int tmp___2;
    int tmp___3;
    int tmp___4;
    int tmp___5;
    int tmp___6;
    int tmp___7;
    int tmp___8;
    int tmp___9;
    int tmp___10;
    int tmp___11;
    int tmp___12;
    int tmp___13;
    int tmp___14;
    int tmp___15;
    int tmp___16;
    int tmp___17;
    int tmp___18;
    int tmp___19;
    int tmp___20;
    {
        {
            tmp = getBraceParam();
            s = tmp;
            diagnostics(4, (char*)"CmdBibStyle <%s>", s);
            tmp___20 = strcmp((const char*)s, "nature");
        }
        if (tmp___20 == 0){
            {
                g_bibstyle_punct[0] = (char*)"";
                g_bibstyle_punct[1] = (char*)".";
                g_bibpunct_style = 1;
                g_sorted_citations = 1;
                g_compressed_citations = 1;
                set_bibpunct_style_separator((char*)",");
                set_bibpunct_style_paren((char*)"", (char*)"");
                set_author_date_and_numbers_sep((char*)"", (char*)",");
            }
        }else{
            {
                tmp___19 = strcmp((const char*)s, "chicago");
            }
            if (tmp___19 == 0){
                {
                    g_bibpunct_style = 0;
                    set_bibpunct_style_separator((char*)";");
                    set_bibpunct_style_paren((char*)"(", (char*)")");
                    set_author_date_and_numbers_sep((char*)",", (char*)",");
                }
            }else{
                {
                    tmp___18 = strcmp((const char*)s, "named");
                }
                if (tmp___18 == 0){
                    {
                        g_bibpunct_style = 0;
                        set_bibpunct_style_separator((char*)";");
                        set_bibpunct_style_paren((char*)"[", (char*)"]");
                        set_bibpunct_style_separator((char*)";");
                    }
                }else{
                    {
                        tmp___17 = strcmp((const char*)s, "agu");
                    }
                    if (tmp___17 == 0){
                        {
                            g_bibpunct_style = 0;
                            set_bibpunct_style_separator((char*)";");
                            set_bibpunct_style_paren((char*)"[", (char*)"]");
                            set_bibpunct_style_separator((char*)";");
                            set_author_date_and_numbers_sep((char*)",", (char*)",~");
                        }
                    }else{
                        {
                            tmp___16 = strcmp((const char*)s, "egs");
                        }
                        if (tmp___16 == 0){
                            {
                                g_bibpunct_style = 0;
                                set_bibpunct_style_paren((char*)"(", (char*)")");
                                set_bibpunct_style_separator((char*)";");
                                set_author_date_and_numbers_sep((char*)",", (char*)",");
                            }
                        }else{
                            {
                                tmp___15 = strcmp((const char*)s, "agsm");
                            }
                            if (tmp___15 == 0){
                                {
                                    g_bibpunct_style = 0;
                                    set_bibpunct_style_paren((char*)"(", (char*)")");
                                    set_bibpunct_style_separator((char*)",");
                                    set_author_date_and_numbers_sep((char*)"", (char*)",");
                                }
                            }else{
                                {
                                    tmp___14 = strcmp((const char*)s, "kluwer");
                                }
                                if (tmp___14 == 0){
                                    {
                                        g_bibpunct_style = 0;
                                        set_bibpunct_style_paren((char*)"(", (char*)")");
                                        set_bibpunct_style_separator((char*)",");
                                        set_author_date_and_numbers_sep((char*)"", (char*)",");
                                    }
                                }else{
                                    {
                                        tmp___13 = strcmp((const char*)s, "dcu");
                                    }
                                    if (tmp___13 == 0){
                                        {
                                            g_bibpunct_style = 0;
                                            set_bibpunct_style_paren((char*)"(", (char*)")");
                                            set_bibpunct_style_separator((char*)";");
                                            set_author_date_and_numbers_sep((char*)";", (char*)",");
                                        }
                                    }else{
                                        {
                                            tmp___12 = strcmp((const char*)s, "aa");
                                        }
                                        if (tmp___12 == 0){
                                            {
                                                g_bibpunct_style = 0;
                                                set_bibpunct_style_paren((char*)"(", (char*)")");
                                                set_bibpunct_style_separator((char*)";");
                                                set_author_date_and_numbers_sep((char*)"", (char*)",");
                                            }
                                        }else{
                                            {
                                                tmp___11 = strcmp((const char*)s, "pass");
                                            }
                                            if (tmp___11 == 0){
                                                {
                                                    g_bibpunct_style = 0;
                                                    set_bibpunct_style_paren((char*)"(", (char*)")");
                                                    set_bibpunct_style_separator((char*)";");
                                                    set_author_date_and_numbers_sep((char*)",", (char*)",");
                                                }
                                            }else{
                                                {
                                                    tmp___10 = strcmp((const char*)s, "anngeo");
                                                }
                                                if (tmp___10 == 0){
                                                    {
                                                        g_bibpunct_style = 0;
                                                        set_bibpunct_style_paren((char*)"(", (char*)")");
                                                        set_bibpunct_style_separator((char*)";");
                                                        set_author_date_and_numbers_sep((char*)",", (char*)",");
                                                    }
                                                }else{
                                                    {
                                                        tmp___9 = strcmp((const char*)s, "nlinproc");
                                                    }
                                                    if (tmp___9 == 0){
                                                        {
                                                            g_bibpunct_style = 0;
                                                            set_bibpunct_style_paren((char*)"(", (char*)")");
                                                            set_bibpunct_style_separator((char*)";");
                                                            set_author_date_and_numbers_sep((char*)",", (char*)",");
                                                        }
                                                    }else{
                                                        {
                                                            tmp___8 = strcmp((const char*)s, "cospar");
                                                        }
                                                        if (tmp___8 == 0){
                                                            {
                                                                g_bibstyle_punct[0] = (char*)"";
                                                                g_bibstyle_punct[1] = (char*)".";
                                                                g_bibpunct_style = 2;
                                                                set_bibpunct_style_paren((char*)"/", (char*)"/");
                                                                set_bibpunct_style_separator((char*)",");
                                                                set_author_date_and_numbers_sep((char*)"", (char*)"");
                                                            }
                                                        }else{
                                                            {
                                                                tmp___7 = strcmp((const char*)s, "esa");
                                                            }
                                                            if (tmp___7 == 0){
                                                                {
                                                                    g_bibstyle_punct[0] = (char*)"";
                                                                    g_bibstyle_punct[1] = (char*)".";
                                                                    g_bibpunct_style = 2;
                                                                    set_bibpunct_style_paren((char*)"(Ref.~", (char*)")");
                                                                    set_bibpunct_style_separator((char*)",");
                                                                    set_author_date_and_numbers_sep((char*)"", (char*)"");
                                                                }
                                                            }else{
                                                                {
                                                                    tmp___3 = strcmp((const char*)s, "plain");
                                                                }
                                                                if (tmp___3 == 0){
                                                                    {
                                                                        g_bibpunct_style = 2;
                                                                        set_bibpunct_style_paren((char*)"[", (char*)"]");
                                                                        set_bibpunct_style_separator((char*)",");
                                                                        set_author_date_and_numbers_sep((char*)"", (char*)",");
                                                                    }
                                                                }else{
                                                                    {
                                                                        tmp___4 = strcmp((const char*)s, "alpha");
                                                                    }
                                                                    if (tmp___4 == 0){
                                                                        {
                                                                            g_bibpunct_style = 2;
                                                                            set_bibpunct_style_paren((char*)"[", (char*)"]");
                                                                            set_bibpunct_style_separator((char*)",");
                                                                            set_author_date_and_numbers_sep((char*)"", (char*)",");
                                                                        }
                                                                    }else{
                                                                        {
                                                                            tmp___5 = strcmp((const char*)s, "abbrv");
                                                                        }
                                                                        if (tmp___5 == 0){
                                                                            {
                                                                                g_bibpunct_style = 2;
                                                                                set_bibpunct_style_paren((char*)"[", (char*)"]");
                                                                                set_bibpunct_style_separator((char*)",");
                                                                                set_author_date_and_numbers_sep((char*)"", (char*)",");
                                                                            }
                                                                        }else{
                                                                            {
                                                                                tmp___6 = strcmp((const char*)s, "unsrt");
                                                                            }
                                                                            if (tmp___6 == 0){
                                                                                {
                                                                                    g_bibpunct_style = 2;
                                                                                    set_bibpunct_style_paren((char*)"[", (char*)"]");
                                                                                    set_bibpunct_style_separator((char*)",");
                                                                                    set_author_date_and_numbers_sep((char*)"", (char*)",");
                                                                                }
                                                                            }else{
                                                                                {
                                                                                    tmp___0 = strcmp((const char*)s, "plainnat");
                                                                                }
                                                                                if (tmp___0 == 0){
                                                                                    {
                                                                                        g_bibpunct_style = 0;
                                                                                        set_bibpunct_style_paren((char*)"[", (char*)"]");
                                                                                        set_bibpunct_style_separator((char*)",");
                                                                                        set_author_date_and_numbers_sep((char*)",", (char*)",");
                                                                                    }
                                                                                }else{
                                                                                    {
                                                                                        tmp___1 = strcmp((const char*)s, "abbrvnat");
                                                                                    }
                                                                                    if (tmp___1 == 0){
                                                                                        {
                                                                                            g_bibpunct_style = 0;
                                                                                            set_bibpunct_style_paren((char*)"[", (char*)"]");
                                                                                            set_bibpunct_style_separator((char*)",");
                                                                                            set_author_date_and_numbers_sep((char*)",", (char*)",");
                                                                                        }
                                                                                    }else{
                                                                                        {
                                                                                            tmp___2 = strcmp((const char*)s, "unsrtnat");
                                                                                        }
                                                                                        if (tmp___2 == 0){
                                                                                            {
                                                                                                g_bibpunct_style = 0;
                                                                                                set_bibpunct_style_paren((char*)"[", (char*)"]");
                                                                                                set_bibpunct_style_separator((char*)",");
                                                                                                set_author_date_and_numbers_sep((char*)",", (char*)",");
                                                                                            }
                                                                                        }else{
                                                                                            {
                                                                                                diagnostics(1, (char*)"\\bibstyle{%s} unknown -- ignored.", s);
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        {
            safe_free(s);
        }
        return;
    }
}

void CmdBibliography(int code)
{
    int err;
    char* s;
    {
        {
            s = getBraceParam();
            safe_free(s);
            err = PushSource((const char*)g_bbl_name, (const char*)((void*)0));
            g_in_bibliography = 1;
        }
        if (!err){
            {
                diagnostics(2, (char*)"CmdBibliography ... begin Convert()");
                Convert();
                diagnostics(2, (char*)"CmdBibliography ... done Convert()");
            }
        }else{
            {
                diagnostics(1, (char*)"Cannot open bibliography file.  Create %s using BibTeX", g_bbl_name);
            }
        }
        g_in_bibliography = 0;
        return;
    }
}

void CmdThebibliography(int code)
{
    int amount;
    int i;
    char* s;
    char* tmp;
    char* str;
    char* tmp___0;
    int tmp___1;
    {
        amount = 450;
        if (code & 16384){
            {
                tmp = getBraceParam();
                s = tmp;
                diagnostics(4, (char*)"\\begin{thebibliography}");
                safe_free(s);
                CmdEndParagraph(0);
                CmdVspace(2);
            }
            if (g_document_type == 6){
                {
                    ConvertString("\\begin{center}{\\bf");
                }
            }else{
                {
                    startParagraph("bibliography", 3);
                    fprintRTF((char*)"{\\plain\\b\\fs32 ");
                }
            }
            {
                i = existsDefinition((char*)"refname");
            }
            if (i > -1){
                {
                    tmp___0 = expandDefinition(i);
                    str = tmp___0;
                    ConvertString((const char*)str);
                    safe_free(str);
                }
            }else
                if (g_document_type == 1){
                    {
                        ConvertBabelName((char*)"REFNAME");
                    }
                }else
                    if (g_document_type == 6){
                        {
                            ConvertBabelName((char*)"REFNAME");
                        }
                    }else{
                        {
                            ConvertBabelName((char*)"BIBNAME");
                        }
                    }

            if (g_document_type == 6){
                {
                    ConvertString("}\\end{center}");
                }
            }else{
                {
                    fprintRTF((char*)"}");
                    CmdEndParagraph(0);
                }
            }
            {
                CmdVspace(1);
                PushEnvironment(25);
                setLength((char*)"parindent", -amount);
                tmp___1 = getLeftMarginIndent();
                setLeftMarginIndent(tmp___1 + amount);
            }
        }else{
            {
                diagnostics(4, (char*)"\\end{thebibliography}");
                CmdEndParagraph(0);
                CmdVspace(1);
                PopEnvironment();
                g_processing_list_environment = 0;
            }
        }
        return;
    }
}

void CmdBibitem(int code)
{
    char* label;
    char* key;
    char* signet;
    char* s;
    char c;
    {
        {
            g_processing_list_environment = 1;
            CmdEndParagraph(0);
            startParagraph("bibitem", 1);
            label = getBracketParam();
            key = getBraceParam();
            signet = strdup_nobadchars((const char*)key);
            s = ScanAux(0, key, 0);
        }
        if (label){
            if (!s){
                if (!g_warned_once){
                    {
                        diagnostics(1, (char*)"Cannot locate \\bibcite{%s} in .aux file", key);
                        diagnostics(1, (char*)"**** The .tex file probably needs to be LaTeXed again ***");
                        g_warned_once = 1;
                    }
                }
                {
                    fprintRTF((char*)"[");
                    ConvertString((const char*)label);
                    fprintRTF((char*)"]");
                }
            }else{
                goto _L___0;
            }
        }else{
            _L___0:
            {
                diagnostics(4, (char*)"CmdBibitem <%s>", s);
            }
            if (g_document_bibstyle == 1){
                goto _L;
            }else
                if (g_document_bibstyle == 4){
                    if (g_bibpunct_style != 0){
                        _L:
                        {
                            fprintRTF((char*)"%s", g_bibstyle_punct[0]);
                            fprintRTF((char*)"{\\v\\*\\bkmkstart BIB_%s}", signet);
                            ConvertString((const char*)s);
                            fprintRTF((char*)"{\\*\\bkmkend BIB_%s}", signet);
                            fprintRTF((char*)"%s", g_bibstyle_punct[1]);
                            fprintRTF((char*)"\\tab\n");
                        }
                    }
                }
        }
        if (s){
            {
                safe_free(s);
            }
        }
        if (label){
            {
                safe_free(label);
            }
        }
        {
            safe_free(signet);
            safe_free(key);
            c = getNonBlank();
            ungetTexChar(c);
        }
        return;
    }
}

void CmdBibEntry(int code)
{
    char* key;
    char* s;
    {
        {
            key = getBraceParam();
            s = ScanBbl(key);
        }
        if (s){
            {
                ConvertString((const char*)s);
                safe_free(s);
            }
        }
        {
            safe_free(key);
        }
        return;
    }
}

void CmdNewblock(int code)
{
    {
        return;
    }
}

void CmdIndex(int code)
{
    char* text;
    char* r;
    char* s;
    char* t;
    {
        {
            getNonBlank();
            text = getDelimitedText((char)'{', (char)'}', 1);
            diagnostics(4, (char*)"CmdIndex \\index{%s}", text);
            fprintRTF((char*)"{\\xe{\\v ");
            t = text;
        }
        {
            while (1){
                while_continue:
                ;
                if (!t){
                    goto while_break;
                }
                {
                    s = t;
                    t = strchr((const char*)s, '!');
                }
                if (t){
                    *t = (char)'\000';
                }
                {
                    r = strchr((const char*)s, '@');
                }
                if (r){
                    s = r + 1;
                }
                {
                    ConvertString((const char*)s);
                }
                if (t){
                    {
                        fprintRTF((char*)"\\:");
                        t++;
                    }
                }
            }
            while_break:
            ;
        }
        {
            fprintRTF((char*)"}}");
            diagnostics(4, (char*)"leaving CmdIndex");
            safe_free(text);
        }
        return;
    }
}

void CmdPrintIndex(int code)
{
    {
        {
            CmdEndParagraph(0);
            fprintRTF((char*)"\\page ");
            fprintRTF((char*)"{\\field{\\*\\fldinst{INDEX \\\\c 2}}{\\fldrslt{}}}");
        }
        return;
    }
}

static int ExistsBookmark(char* s)
{
    int i;
    int tmp;
    {
        if (!s){
            return (0);
        }
        i = 0;
        {
            while (1){
                while_continue:
                ;
                if (!(i <= g_label_list_number)){
                    goto while_break;
                }
                {
                    tmp = strcmp((const char*)s, (const char*)g_label_list[i]);
                }
                if (tmp == 0){
                    return (1);
                }
                i++;
            }
            while_break:
            ;
        }
        return (0);
    }
}

static void RecordBookmark(char* s)
{
    {
        if (!s){
            return;
        }
        if (g_label_list_number >= 200){
            {
                diagnostics(1, (char*)"Too many labels...some cross-references will fail");
            }
        }else{
            {
                g_label_list_number++;
                g_label_list[g_label_list_number] = strdup((const char*)s);
            }
        }
        return;
    }
}

void InsertBookmark(char* name, char* text)
{
    char* signet;
    int tmp;
    int tmp___0;
    int tmp___1;
    int tmp___2;
    {
        if (!name){
            {
                tmp = getTexMode();
            }
            if (tmp == 6){
                {
                    changeTexMode(2);
                }
            }
            {
                fprintRTF((char*)"%s", text);
            }
            return;
        }
        {
            signet = strdup_nobadchars((const char*)name);
            tmp___2 = ExistsBookmark(signet);
        }
        if (tmp___2){
            {
                diagnostics(4, (char*)"bookmark %s already exists", signet);
            }
        }else{
            {
                diagnostics(4, (char*)"bookmark %s being inserted around <%s>", signet, text);
                RecordBookmark(signet);
                tmp___0 = fields_use_REF();
            }
            if (tmp___0){
                {
                    fprintRTF((char*)"{\\*\\bkmkstart BM%s}", signet);
                }
            }
            {
                fprintRTF((char*)"%s", text);
                tmp___1 = fields_use_REF();
            }
            if (tmp___1){
                {
                    fprintRTF((char*)"{\\*\\bkmkend BM%s}", signet);
                }
            }
        }
        {
            safe_free(signet);
        }
        return;
    }
}

void InsertContentMark(char marker, char* s1, char* s2, char* s3)
{
    {
        {
            fprintRTF((char*)"{\\field{\\*\\fldinst TC \"");
            ConvertString((const char*)s1);
            ConvertString((const char*)s2);
            ConvertString((const char*)s3);
            fprintRTF((char*)"\" \\\\f %c}{\\fldrslt }}", (int)marker);
        }
        return;
    }
}

void CmdLabel(int code)
{
    int brace;
    char* text;
    char* signet;
    char* s;
    char* t;
    char* p;
    char* option;
    int mode;
    int tmp;
    size_t tmp___0;
    int tmp___1;
    int tmp___2;
    int tmp___3;
    int tmp___4;
    int tmp___5;
    int tmp___6;
    {
        {
            option = (char*)((void*)0);
            tmp = getTexMode();
            mode = tmp;
            option = getBracketParam();
            text = getBraceParam();
            tmp___0 = strlen((const char*)text);
        }
        if (tmp___0 == 0UL){
            {
                safe_free(text);
            }
            return;
        }
        {
            if (code == 1){
                goto case_1;
            }
            if (code == 11){
                goto case_11;
            }
            if (code == 10){
                goto case_11;
            }
            if (code == 3){
                goto case_11;
            }
            if (code == 2){
                goto case_11;
            }
            if (code == 7){
                goto case_7;
            }
            if (code == 6){
                goto case_7;
            }
            if (code == 17){
                goto case_17;
            }
            goto switch_break;
            case_1:
            if (g_processing_figure){
                goto switch_break;
            }else
                if (g_processing_table){
                    goto switch_break;
                }
            if (mode == 5){
                {
                    g_equation_label = strdup_nobadchars((const char*)text);
                    diagnostics(4, (char*)"equation label is <%s>", text);
                }
            }else{
                {
                    InsertBookmark(text, (char*)"");
                }
            }
            goto switch_break;
            case_11:
            case_10:
            case_3:
            case_2:
            {
                signet = strdup_nobadchars((const char*)text);
                s = ScanAux(1, text, 1);
            }
            if (code == 10){
                {
                    fprintRTF((char*)"(");
                }
            }
            {
                tmp___1 = fields_use_REF();
            }
            if (tmp___1){
                {
                    fprintRTF((char*)"{\\field{\\*\\fldinst{\\lang1024 REF BM%s \\\\* MERGEFORMAT }}", signet);
                    fprintRTF((char*)"{\\fldrslt{");
                }
            }
            if (s){
                {
                    ConvertString((const char*)s);
                }
            }else{
                {
                    fprintRTF((char*)"?");
                }
            }
            {
                tmp___2 = fields_use_REF();
            }
            if (tmp___2){
                {
                    fprintRTF((char*)"}}}");
                }
            }
            if (code == 10){
                {
                    fprintRTF((char*)")");
                }
            }
            if (code == 11){
                {
                    fprintRTF((char*)" ");
                    tmp___3 = fields_use_REF();
                }
                if (tmp___3){
                    {
                        fprintRTF((char*)"{\\field{\\*\\fldinst{\\lang1024 PAGEREF BM%s \\\\p }}", signet);
                        fprintRTF((char*)"{\\fldrslt{");
                    }
                }
                {
                    fprintRTF((char*)"%s", signet);
                    tmp___4 = fields_use_REF();
                }
                if (tmp___4){
                    {
                        fprintRTF((char*)"}}}");
                    }
                }
            }
            {
                safe_free(signet);
            }
            if (s){
                {
                    safe_free(s);
                }
            }
            goto switch_break;
            case_7:
            case_6:
            {
                signet = strdup_nobadchars((const char*)text);
                tmp___5 = fields_use_REF();
            }
            if (tmp___5){
                {
                    fprintRTF((char*)"{\\field{\\*\\fldinst{\\lang1024 PAGEREF BM%s \\\\* MERGEFORMAT }}", signet);
                    fprintRTF((char*)"{\\fldrslt{");
                }
            }
            {
                fprintRTF((char*)"%s", signet);
                tmp___6 = fields_use_REF();
            }
            if (tmp___6){
                {
                    fprintRTF((char*)"}}}");
                }
            }
            {
                safe_free(signet);
            }
            goto switch_break;
            case_17:
            {
                signet = strdup_nobadchars((const char*)text);
                s = ScanAux(1, text, 0);
            }
            if (s){
                {
                    t = strchr((const char*)s, '{');
                }
                if (t){
                    {
                        t = strchr((const char*)(t + 1), '{');
                    }
                }
                if (t){
                    {
                        t = strchr((const char*)(t + 1), '{');
                    }
                }
                if (t){
                    t++;
                    p = t;
                    brace = 1;
                    {
                        while (1){
                            while_continue:
                            ;
                            if (p){
                                if (!*p){
                                    goto while_break;
                                }
                            }else{
                                goto while_break;
                            }
                            if ((int)*p == 123){
                                brace++;
                            }
                            if ((int)*p == 125){
                                brace--;
                                if (brace == 0){
                                    goto while_break;
                                }
                            }
                            p++;
                        }
                        while_break:
                        ;
                    }
                    if (p){
                        *p = (char)'\000';
                    }
                    {
                        ConvertString((const char*)t);
                    }
                }
            }
            {
                safe_free(signet);
            }
            if (s){
                {
                    safe_free(s);
                }
            }
            goto switch_break;
            switch_break:
            ;
        }
        {
            safe_free(text);
        }
        if (option){
            {
                safe_free(option);
            }
        }
        return;
    }
}

static char* popCommaName(char* s)
{
    char* t;
    {
        if ((unsigned long )s == (unsigned long )((void*)0)){
            return ((char*)((void*)0));
        }else
            if ((int)*s == 0){
                return ((char*)((void*)0));
            }

        {
            t = strchr((const char*)s, ',');
        }
        if (!t){
            return ((char*)((void*)0));
        }
        *t = (char)'\000';
        return (t + 1);
    }
}

static char* getAngleParam(void)
{
    char c;
    char* text;
    {
        {
            c = getNonBlank();
        }
        if ((int)c == 60){
            {
                text = getDelimitedText((char)'<', (char)'>', 1);
                diagnostics(5, (char*)"getAngleParam [%s]", text);
            }
        }else{
            {
                ungetTexChar(c);
                text = (char*)((void*)0);
                diagnostics(5, (char*)"getAngleParam []");
            }
        }
        return (text);
    }
}

static int isEmptyName(char* s)
{
    {
        if ((unsigned long )s == (unsigned long )((void*)0)){
            return (1);
        }
        if ((int)*(s + 0) == 0){
            return (1);
        }
        if ((int)*(s + 0) == 123){
            if ((int)*(s + 1) == 125){
                return (1);
            }
        }
        return (0);
    }
}

static void ConvertNatbib(char* s, int code, char* pre, char* post, int first___0, int last)
{
    char* n;
    char* year;
    char* abbv;
    char* full;
    char* v;
    int author_repeated;
    int year_repeated;
    int tmp;
    int tmp___0;
    int tmp___1;
    int tmp___2;
    int tmp___3;
    int tmp___4;
    int tmp___5;
    int tmp___6;
    char* ss;
    char* tmp___7;
    int tmp___8;
    int tmp___9;
    int tmp___10;
    int tmp___11;
    char* ss___0;
    char* tmp___12;
    int tmp___13;
    int tmp___14;
    int tmp___15;
    int tmp___16;
    int tmp___17;
    int tmp___18;
    int tmp___19;
    int tmp___20;
    int tmp___21;
    int tmp___22;
    char* ss___1;
    char* tmp___23;
    int tmp___24;
    int tmp___25;
    int tmp___26;
    int tmp___27;
    int tmp___28;
    int tmp___29;
    {
        {
            PushSource((const char*)((void*)0), (const char*)s);
            n = getBraceParam();
            year = getBraceParam();
            abbv = getBraceParam();
            full = getBraceParam();
            PopSource();
            diagnostics(4, (char*)"natbib pre=[%s] post=<%s> n=<%s> year=<%s> abbv=<%s> full=<%s>", pre, post, n, year, abbv, full);
            author_repeated = 0;
            year_repeated = 0;
        }
        if (g_bibpunct_style != 0){
            if (!first___0){
                {
                    ConvertString((const char*)g_bibpunct_cite_sep);
                }
                if (g_bibpunct_style == 2){
                    {
                        fprintRTF((char*)" ");
                    }
                }
            }
            {
                ConvertString((const char*)n);
                safe_free(n);
                safe_free(year);
                safe_free(abbv);
                safe_free(full);
            }
            return;
        }
        {
            if (code == 1){
                goto case_1;
            }
            if (code == 128){
                goto case_128;
            }
            if (code == 17){
                goto case_128;
            }
            if (code == 16){
                goto case_128;
            }
            if (code == 130){
                goto case_130;
            }
            if (code == 22){
                goto case_130;
            }
            if (code == 20){
                goto case_130;
            }
            if (code == 129){
                goto case_129;
            }
            if (code == 18){
                goto case_129;
            }
            if (code == 131){
                goto case_131;
            }
            if (code == 23){
                goto case_131;
            }
            if (code == 21){
                goto case_131;
            }
            if (code == 19){
                goto case_131;
            }
            if (code == 132){
                goto case_132;
            }
            if (code == 26){
                goto case_132;
            }
            if (code == 25){
                goto case_132;
            }
            if (code == 27){
                goto case_27;
            }
            if (code == 13){
                goto case_27;
            }
            goto switch_break;
            case_1:
            v = abbv;
            if (g_citation_longnamesfirst){
                {
                    tmp = isEmptyName(full);
                }
                if (!tmp){
                    v = full;
                }
            }
            {
                tmp___0 = isEmptyName(v);
            }
            if (tmp___0){
                v = n;
            }
            {
                tmp___1 = strcmp((const char*)v, (const char*)(g_last_author_cited));
            }
            if (tmp___1 == 0){
                author_repeated = 1;
            }
            {
                tmp___2 = strncmp((const char*)year, (const char*)(g_last_year_cited), (size_t)4);
            }
            if (tmp___2 == 0){
                year_repeated = 1;
            }
            if (!first___0){
                if (!author_repeated){
                    {
                        ConvertString((const char*)g_bibpunct_cite_sep);
                        fprintRTF((char*)" ");
                    }
                }
            }
            {
                ConvertString((const char*)v);
                fprintRTF((char*)" ");
                ConvertString((const char*)g_bibpunct_open);
                ConvertString((const char*)year);
                ConvertString((const char*)g_bibpunct_close);
            }
            goto switch_break;
            case_128:
            case_17:
            case_16:
            v = abbv;
            if (16 == code){
                if (g_citation_longnamesfirst){
                    if (!g_current_cite_seen){
                        {
                            tmp___3 = isEmptyName(full);
                        }
                        if (!tmp___3){
                            v = full;
                        }
                    }
                }
            }
            if (17 == code){
                {
                    tmp___4 = isEmptyName(full);
                }
                if (!tmp___4){
                    v = full;
                }
            }
            {
                tmp___5 = strcmp((const char*)v, (const char*)(g_last_author_cited));
            }
            if (tmp___5 == 0){
                author_repeated = 1;
            }
            if (!first___0){
                if (!author_repeated){
                    {
                        ConvertString((const char*)g_bibpunct_close);
                        ConvertString((const char*)g_bibpunct_cite_sep);
                        fprintRTF((char*)" ");
                    }
                }
            }
            if (128 == code){
                {
                    tmp___6 = toupper((int)*(v + 1));
                    *(v + 1) = (char)tmp___6;
                }
            }
            if (!author_repeated){
                {
                    ConvertString((const char*)v);
                    my_strlcpy(g_last_author_cited, (const char*)v, (size_t)201);
                    my_strlcpy(g_last_year_cited, (const char*)year, (size_t)51);
                }
                if (g_bibpunct_style == 0){
                    {
                        fprintRTF((char*)" ");
                        ConvertString((const char*)g_bibpunct_open);
                    }
                    if (pre){
                        {
                            ConvertString((const char*)pre);
                            fprintRTF((char*)" ");
                        }
                    }
                    {
                        ConvertString((const char*)year);
                    }
                }
            }else
                if (g_bibpunct_style == 0){
                    if (!year_repeated){
                        {
                            ConvertString((const char*)g_bibpunct_numbers_sep);
                            fprintRTF((char*)" ");
                            ConvertString((const char*)year);
                        }
                    }else{
                        {
                            tmp___7 = strdup((const char*)(year + 4));
                            ss = tmp___7;
                            ConvertString((const char*)g_bibpunct_numbers_sep);
                            ConvertString((const char*)ss);
                            safe_free(ss);
                        }
                    }
                }

            if (g_bibpunct_style == 0){
                if (last){
                    if (post){
                        {
                            tmp___8 = isEmptyName(post);
                        }
                        if (!tmp___8){
                            {
                                ConvertString((const char*)g_bibpunct_postnote_sep);
                                ConvertString((const char*)post);
                            }
                        }
                    }
                }
                if (last){
                    {
                        ConvertString((const char*)g_bibpunct_close);
                    }
                }
            }
            goto switch_break;
            case_130:
            case_22:
            case_20:
            {
                v = abbv;
                tmp___9 = strcmp((const char*)v, (const char*)(g_last_author_cited));
            }
            if (tmp___9 == 0){
                author_repeated = 1;
            }
            {
                tmp___10 = strncmp((const char*)year, (const char*)(g_last_year_cited), (size_t)4);
            }
            if (tmp___10 == 0){
                year_repeated = 1;
            }
            if (!first___0){
                if (!author_repeated){
                    {
                        ConvertString((const char*)g_bibpunct_cite_sep);
                        fprintRTF((char*)" ");
                    }
                }
            }
            if (130 == code){
                {
                    tmp___11 = toupper((int)*(v + 1));
                    *(v + 1) = (char)tmp___11;
                }
            }
            if (!author_repeated){
                {
                    ConvertString((const char*)v);
                    my_strlcpy(g_last_author_cited, (const char*)v, (size_t)201);
                    my_strlcpy(g_last_year_cited, (const char*)year, (size_t)51);
                    fprintRTF((char*)" ");
                }
                if (pre){
                    {
                        ConvertString((const char*)pre);
                        fprintRTF((char*)" ");
                    }
                }
                {
                    ConvertString((const char*)year);
                }
            }else
                if (!year_repeated){
                    {
                        ConvertString((const char*)g_bibpunct_numbers_sep);
                        fprintRTF((char*)" ");
                        ConvertString((const char*)year);
                    }
                }else{
                    {
                        tmp___12 = strdup((const char*)(year + 4));
                        ss___0 = tmp___12;
                        ConvertString((const char*)g_bibpunct_numbers_sep);
                        ConvertString((const char*)ss___0);
                        safe_free(ss___0);
                    }
                }

            if (last){
                if (post){
                    {
                        tmp___13 = isEmptyName(post);
                    }
                    if (!tmp___13){
                        {
                            ConvertString((const char*)g_bibpunct_postnote_sep);
                            ConvertString((const char*)post);
                        }
                    }
                }
            }
            goto switch_break;
            case_129:
            case_18:
            {
                v = abbv;
                tmp___14 = strcmp((const char*)v, (const char*)(g_last_author_cited));
            }
            if (tmp___14 == 0){
                author_repeated = 1;
            }
            {
                tmp___15 = strncmp((const char*)year, (const char*)(g_last_year_cited), (size_t)4);
            }
            if (tmp___15 == 0){
                year_repeated = 1;
            }
            if (!first___0){
                if (!author_repeated){
                    {
                        ConvertString((const char*)g_bibpunct_cite_sep);
                        fprintRTF((char*)" ");
                    }
                }
            }
            if (pre){
                if (g_current_cite_item == 1){
                    {
                        ConvertString((const char*)pre);
                        fprintRTF((char*)" ");
                    }
                }
            }
            if (129 == code){
                {
                    tmp___16 = toupper((int)*(v + 1));
                    *(v + 1) = (char)tmp___16;
                }
            }
            if (!author_repeated){
                {
                    ConvertString((const char*)v);
                    my_strlcpy(g_last_author_cited, (const char*)v, (size_t)201);
                    my_strlcpy(g_last_year_cited, (const char*)year, (size_t)51);
                    ConvertString((const char*)g_bibpunct_author_date_sep);
                    fprintRTF((char*)" ");
                }
            }else{
                {
                    ConvertString((const char*)g_bibpunct_numbers_sep);
                    fprintRTF((char*)" ");
                }
            }
            {
                ConvertString((const char*)year);
            }
            if (last){
                if (post){
                    {
                        tmp___17 = isEmptyName(post);
                    }
                    if (!tmp___17){
                        {
                            ConvertString((const char*)g_bibpunct_postnote_sep);
                            ConvertString((const char*)post);
                        }
                    }
                }
            }
            goto switch_break;
            case_131:
            case_23:
            case_21:
            case_19:
            v = abbv;
            if (18 == code){
                if (g_citation_longnamesfirst){
                    if (!g_current_cite_seen){
                        {
                            tmp___18 = isEmptyName(full);
                        }
                        if (!tmp___18){
                            v = full;
                        }
                    }
                }
            }
            if (19 == code){
                {
                    tmp___19 = isEmptyName(full);
                }
                if (!tmp___19){
                    v = full;
                }
            }
            {
                tmp___20 = strcmp((const char*)v, (const char*)(g_last_author_cited));
            }
            if (tmp___20 == 0){
                author_repeated = 1;
            }
            {
                tmp___21 = strncmp((const char*)year, (const char*)(g_last_year_cited), (size_t)4);
            }
            if (tmp___21 == 0){
                year_repeated = 1;
            }
            if (pre){
                if (g_current_cite_item == 1){
                    {
                        ConvertString((const char*)pre);
                        fprintRTF((char*)" ");
                    }
                }
            }
            if (!first___0){
                if (!author_repeated){
                    {
                        ConvertString((const char*)g_bibpunct_cite_sep);
                        fprintRTF((char*)" ");
                    }
                }
            }
            if (131 == code){
                {
                    tmp___22 = toupper((int)*(v + 1));
                    *(v + 1) = (char)tmp___22;
                }
            }
            if (!author_repeated){
                {
                    ConvertString((const char*)v);
                    my_strlcpy(g_last_author_cited, (const char*)v, (size_t)201);
                    my_strlcpy(g_last_year_cited, (const char*)year, (size_t)51);
                    ConvertString((const char*)g_bibpunct_author_date_sep);
                    fprintRTF((char*)" ");
                    ConvertString((const char*)year);
                }
            }else
                if (!year_repeated){
                    {
                        ConvertString((const char*)g_bibpunct_numbers_sep);
                        fprintRTF((char*)" ");
                        ConvertString((const char*)year);
                    }
                }else{
                    {
                        tmp___23 = strdup((const char*)(year + 4));
                        ss___1 = tmp___23;
                        ConvertString((const char*)g_bibpunct_numbers_sep);
                        ConvertString((const char*)ss___1);
                        safe_free(ss___1);
                    }
                }

            if (last){
                if (post){
                    {
                        tmp___24 = isEmptyName(post);
                    }
                    if (!tmp___24){
                        {
                            ConvertString((const char*)g_bibpunct_postnote_sep);
                            ConvertString((const char*)post);
                        }
                    }
                }
            }
            goto switch_break;
            case_132:
            case_26:
            case_25:
            v = abbv;
            if (!first___0){
                {
                    ConvertString((const char*)g_bibpunct_cite_sep);
                    fprintRTF((char*)" ");
                }
            }
            if (25 == code){
                if (g_citation_longnamesfirst){
                    if (!g_current_cite_seen){
                        {
                            tmp___25 = isEmptyName(full);
                        }
                        if (!tmp___25){
                            v = full;
                        }
                    }
                }
            }
            if (132 == code){
                {
                    tmp___26 = toupper((int)*(v + 1));
                    *(v + 1) = (char)tmp___26;
                }
            }
            if (26 == code){
                {
                    tmp___27 = isEmptyName(full);
                }
                if (!tmp___27){
                    v = full;
                }
            }
            {
                ConvertString((const char*)v);
            }
            if (last){
                if (post){
                    {
                        tmp___28 = isEmptyName(post);
                    }
                    if (!tmp___28){
                        {
                            ConvertString((const char*)g_bibpunct_postnote_sep);
                            ConvertString((const char*)post);
                        }
                    }
                }
            }
            goto switch_break;
            case_27:
            case_13:
            if (!first___0){
                {
                    ConvertString((const char*)g_bibpunct_cite_sep);
                    fprintRTF((char*)" ");
                }
            }
            if (13 != code){
                if (pre){
                    if (g_current_cite_item == 1){
                        {
                            ConvertString((const char*)pre);
                            fprintRTF((char*)" ");
                        }
                    }
                }
            }
            {
                ConvertString((const char*)year);
            }
            if (last){
                if (post){
                    {
                        tmp___29 = isEmptyName(post);
                    }
                    if (!tmp___29){
                        {
                            ConvertString((const char*)g_bibpunct_postnote_sep);
                            ConvertString((const char*)post);
                        }
                    }
                }
            }
            goto switch_break;
            switch_break:
            ;
        }
        {
            safe_free(n);
            safe_free(year);
            safe_free(abbv);
            safe_free(full);
        }
        return;
    }
}

static void ConvertHarvard(biblioElem* bibElem, int code, char* pre, char* post, int first___0)
{
    char* year;
    char* abbv;
    char* full;
    int author_repeated;
    int year_repeated;
    {
        {
            year = strdup((const char*)bibElem->biblioYear);
            abbv = strdup((const char*)bibElem->biblioAbbr);
            full = strdup((const char*)bibElem->biblioFull);
            diagnostics(4, (char*)"harvard pre=[%s] post=<%s> full=<%s> abbv=<%s> year=<%s>", pre, post, full, abbv, year);
            author_repeated = 0;
            year_repeated = 0;
        }
        {
            if (code == 30){
                goto case_30;
            }
            if (code == 1){
                goto case_1;
            }
            if (code == 31){
                goto case_31;
            }
            if (code == 13){
                goto case_31;
            }
            if (code == 35){
                goto case_35;
            }
            if (code == 28){
                goto case_28;
            }
            if (code == 29){
                goto case_29;
            }
            goto switch_break;
            case_30:
            if (first___0){
                if (pre){
                    {
                        ConvertString((const char*)pre);
                        fprintRTF((char*)" ");
                    }
                }
            }
            {
                ConvertString((const char*)full);
                fprintRTF((char*)" ");
                ConvertString((const char*)year);
            }
            goto switch_break;
            case_1:
            {
                ConvertString((const char*)full);
                fprintRTF((char*)" ");
                ConvertString((const char*)year);
            }
            goto switch_break;
            case_31:
            case_13:
            {
                ConvertString((const char*)year);
            }
            goto switch_break;
            case_35:
            {
                ConvertString((const char*)full);
            }
            goto switch_break;
            case_28:
            {
                ConvertString((const char*)full);
                fprintRTF((char*)" (");
                ConvertString((const char*)year);
                fprintRTF((char*)")");
            }
            goto switch_break;
            case_29:
            {
                ConvertString((const char*)full);
                fprintRTF((char*)"\\rquote s (");
                ConvertString((const char*)year);
                fprintRTF((char*)")");
            }
            goto switch_break;
            switch_break:
            ;
        }
        {
            safe_free(full);
            safe_free(year);
            safe_free(abbv);
        }
        return;
    }
}

void CmdNatexlab(int code)
{
    char* s;
    char* tmp;
    {
        {
            tmp = getBracketParam();
            s = tmp;
            safe_free(s);
        }
        return;
    }
}

void CmdBibpunct(int code)
{
    char* s;
    {
        {
            s = (char*)((void*)0);
            s = getBracketParam();
        }
        if (s){
            {
                safe_free(g_bibpunct_postnote_sep);
                g_bibpunct_postnote_sep = s;
            }
        }
        {
            safe_free(g_bibpunct_open);
            g_bibpunct_open = getBraceParam();
            safe_free(g_bibpunct_close);
            g_bibpunct_close = getBraceParam();
            safe_free(g_bibpunct_cite_sep);
            g_bibpunct_cite_sep = getBraceParam();
            s = getBraceParam();
        }
        if ((int)*s == 115){
            g_bibpunct_style = 1;
        }
        if ((int)*s == 110){
            g_bibpunct_style = 2;
        }
        if ((int)*s == 97){
            g_bibpunct_style = 0;
        }
        {
            safe_free(s);
            safe_free(g_bibpunct_author_date_sep);
            g_bibpunct_author_date_sep = getBraceParam();
            safe_free(g_bibpunct_numbers_sep);
            g_bibpunct_numbers_sep = getBraceParam();
            g_bibpunct_cite_sep_touched = 1;
            g_bibpunct_style_paren_touched = 1;
        }
        return;
    }
}

static int CmpFunc(const void* _a, const void* _b)
{
    citekey_type* aa;
    citekey_type* bb;
    int a;
    int b;
    {
        aa = (citekey_type*)_a;
        bb = (citekey_type*)_b;
        a = aa->number;
        b = bb->number;
        if (a > b){
            return (1);
        }
        if (a == b){
            return (0);
        }
        return (-1);
    }
}

static char* reorder_citations(char* keys, int scan_aux_code)
{
    char* key;
    char* remaining_keys;
    char* ordered_keys;
    char* a;
    char* b;
    int n;
    int i;
    int dash;
    citekey_type names[100];
    char* s;
    char* tmp;
    int number;
    {
        {
            diagnostics(4, (char*)"original list <%s> scan aux code=%d", keys, scan_aux_code);
            key = keys;
            remaining_keys = popCommaName(key);
            n = 0;
        }
        {
            while (1){
                while_continue:
                ;
                if (key){
                    if (!(n < 100)){
                        goto while_break;
                    }
                }else{
                    goto while_break;
                }
                {
                    tmp = ScanAux(0, key, scan_aux_code);
                    s = tmp;
                }
                if (s){
                    {
                        sscanf((const char*)s, (const char*)"%d", &number);
                        safe_free(s);
                        names[n].key = key;
                        names[n].number = number;
                        n++;
                    }
                }
                {
                    key = remaining_keys;
                    remaining_keys = popCommaName(key);
                }
            }
            while_break:
            ;
        }
        if (n <= 1){
            {
                ordered_keys = strdup((const char*)keys);
            }
            return (ordered_keys);
        }
        {
            qsort((void*)(names), (size_t)n, sizeof (citekey_type), &CmpFunc);
            ordered_keys = strdup((const char*)names[0].key);
            dash = 0;
            i = 1;
        }
        {
            while (1){
                while_continue___0:
                ;
                if (!(i < n)){
                    goto while_break___0;
                }
                if (g_compressed_citations){
                    if (dash){
                        if (i != n - 1){
                            if (names[i].number + 1 == names[i + 1].number){
                                goto __Cont;
                            }
                        }
                    }
                }
                {
                    a = strdup_together((const char*)ordered_keys, ",");
                }
                if (g_compressed_citations){
                    if (!dash){
                        if (i != n - 1){
                            if (names[i - 1].number + 2 == names[i + 1].number){
                                {
                                    dash = 1;
                                    b = strdup_together((const char*)a, (const char*)BIB_DASH_MARKER);
                                }
                            }else{
                                {
                                    dash = 0;
                                    b = strdup_together((const char*)a, (const char*)names[i].key);
                                }
                            }
                        }else{
                            {
                                dash = 0;
                                b = strdup_together((const char*)a, (const char*)names[i].key);
                            }
                        }
                    }else{
                        {
                            dash = 0;
                            b = strdup_together((const char*)a, (const char*)names[i].key);
                        }
                    }
                }else{
                    {
                        dash = 0;
                        b = strdup_together((const char*)a, (const char*)names[i].key);
                    }
                }
                {
                    safe_free(a);
                    safe_free(ordered_keys);
                    ordered_keys = b;
                }
                __Cont:
                i++;
            }
            while_break___0:
            ;
        }
        {
            diagnostics(4, (char*)"compressed list <%s>", ordered_keys);
        }
        return (ordered_keys);
    }
}

void CmdCite(int code)
{
    char* text;
    char* str1;
    char* keys;
    char* key;
    char* next_keys;
    char* option;
    char* pretext;
    int first_key;
    size_t tmp;
    char* s;
    char* t;
    int tmp___0;
    char* signet;
    char* tmp___1;
    int tmp___2;
    int tmp___3;
    {
        option = (char*)((void*)0);
        pretext = (char*)((void*)0);
        first_key = 1;
        g_current_cite_paren = 1;
        g_last_author_cited[0] = (char)'\000';
        g_last_year_cited[0] = (char)'\000';
        if (g_document_bibstyle == 1){
            {
                safe_free(g_bibpunct_open);
                safe_free(g_bibpunct_close);
                g_bibpunct_open = strdup("[");
                g_bibpunct_close = strdup("]");
                option = getBracketParam();
            }
        }
        if (g_document_bibstyle == 2){
            {
                option = getBracketParam();
            }
        }
        if (g_document_bibstyle == 5){
            {
                option = getBracketParam();
            }
        }
        if (g_document_bibstyle == 3){
            {
                pretext = getAngleParam();
                option = getBracketParam();
            }
            if (code != 1){
                if (code != 2){
                    if (code != 3){
                        if (code != 13){
                            g_current_cite_paren = 0;
                        }
                    }
                }
            }
            g_current_cite_type = code;
        }
        {
            text = getBraceParam();
            str1 = strdup_nocomments((const char*)text);
            safe_free(text);
            text = str1;
            tmp = strlen((const char*)text);
        }
        if (tmp == 0UL){
            {
                safe_free(text);
            }
            if (pretext){
                {
                    safe_free(pretext);
                }
            }
            if (option){
                {
                    safe_free(option);
                }
            }
            return;
        }
        if (g_current_cite_paren){
            {
                fprintRTF((char*)"\n");
                ConvertString((const char*)g_bibpunct_open);
            }
        }
        if (pretext){
            if (g_document_bibstyle == 3){
                {
                    ConvertString((const char*)pretext);
                    fprintRTF((char*)" ");
                }
            }
        }
        {
            keys = strdup_noblanks((const char*)text);
            safe_free(text);
        }
        if (g_sorted_citations){
            {
                text = reorder_citations(keys, 0);
                safe_free(keys);
                keys = text;
            }
        }
        {
            key = keys;
            next_keys = popCommaName(key);
            g_current_cite_item = 0;
        }
        {
            while (1){
                while_continue:
                ;
                if (!key){
                    goto while_break;
                }
                {
                    g_current_cite_item++;
                    tmp___0 = strcmp((const char*)key, (const char*)BIB_DASH_MARKER);
                }
                if (tmp___0 == 0){
                    {
                        fprintRTF((char*)"-");
                        first_key = 1;
                        key = next_keys;
                        next_keys = popCommaName(key);
                    }
                    goto while_continue;
                }
                {
                    s = ScanAux(0, key, 0);
                }
                if (g_document_bibstyle == 2){
                    if (s){
                        t = s;
                    }else{
                        t = key;
                    }
                    if (!first_key){
                        {
                            ConvertString((const char*)g_bibpunct_cite_sep);
                            fprintRTF((char*)" ");
                        }
                    }
                    {
                        ConvertString((const char*)t);
                    }
                }
                if (g_document_bibstyle == 5){
                    if (!first_key){
                        {
                            ConvertString((const char*)g_bibpunct_cite_sep);
                            fprintRTF((char*)" ");
                        }
                    }
                    if (s){
                        t = s;
                    }else{
                        t = key;
                    }
                    if (code == 3){
                        g_suppress_name = 1;
                    }
                    {
                        ConvertString((const char*)t);
                    }
                    if (code == 3){
                        g_suppress_name = 0;
                    }
                }
                if (g_document_bibstyle == 3){
                    if (!first_key){
                        {
                            ConvertString((const char*)g_bibpunct_cite_sep);
                            fprintRTF((char*)" ");
                        }
                    }
                    if (s){
                        t = s;
                    }else{
                        t = key;
                    }
                    {
                        g_current_cite_seen = citation_used(key);
                        ConvertString((const char*)t);
                    }
                }
                if (g_document_bibstyle == 1){
                    {
                        tmp___1 = strdup_nobadchars((const char*)key);
                        signet = tmp___1;
                    }
                    if (!first_key){
                        {
                            ConvertString((const char*)g_bibpunct_cite_sep);
                            fprintRTF((char*)" ");
                        }
                    }
                    if (s){
                        t = s;
                    }else{
                        t = signet;
                    }
                    {
                        tmp___2 = fields_use_REF();
                    }
                    if (tmp___2){
                        {
                            fprintRTF((char*)"{\\field{\\*\\fldinst{\\lang1024 REF BIB_%s \\\\* MERGEFORMAT }}", signet);
                            fprintRTF((char*)"{\\fldrslt{");
                        }
                    }
                    {
                        ConvertString((const char*)t);
                        tmp___3 = fields_use_REF();
                    }
                    if (tmp___3){
                        {
                            fprintRTF((char*)"}}}");
                        }
                    }
                    {
                        safe_free(signet);
                    }
                }
                {
                    first_key = 0;
                    key = next_keys;
                    next_keys = popCommaName(key);
                    safe_free(s);
                }
            }
            while_break:
            ;
        }
        if (option){
            {
                ConvertString((const char*)g_bibpunct_postnote_sep);
                ConvertString((const char*)option);
            }
        }
        if (g_current_cite_paren){
            {
                fprintRTF((char*)"\n");
                ConvertString((const char*)g_bibpunct_close);
            }
        }
        {
            safe_free(keys);
            safe_free(option);
            safe_free(pretext);
        }
        return;
    }
}

void CmdNatbibCite(int code)
{
    char* text;
    char* str1;
    char* keys;
    char* key;
    char* next_keys;
    char* option;
    char* pretext;
    int first_key;
    int last_key;
    size_t tmp;
    int tmp___0;
    int tmp___1;
    char* s;
    int tmp___2;
    {
        option = (char*)((void*)0);
        pretext = (char*)((void*)0);
        first_key = 1;
        last_key = 0;
        g_current_cite_paren = 1;
        g_last_author_cited[0] = (char)'\000';
        g_last_year_cited[0] = (char)'\000';
        if (!g_bibpunct_cite_sep_touched){
            {
                safe_free(g_bibpunct_cite_sep);
                g_bibpunct_cite_sep = strdup(";");
            }
        }
        if (!g_bibpunct_style_paren_touched){
            {
                safe_free(g_bibpunct_cite_sep);
                g_bibpunct_cite_sep = strdup(";");
            }
        }
        {
            pretext = getBracketParam();
            option = getBracketParam();
        }
        if (!option){
            option = pretext;
            pretext = (char*)'\000';
        }
        if (code != 18){
            if (code != 19){
                if (code != 27){
                    g_current_cite_paren = 0;
                }
            }
        }
        if (g_bibpunct_style == 1){
            g_current_cite_paren = 0;
        }
        if (g_bibpunct_style == 2){
            g_current_cite_paren = 1;
        }
        {
            text = getBraceParam();
            str1 = strdup_nocomments((const char*)text);
            safe_free(text);
            text = str1;
            tmp = strlen((const char*)text);
        }
        if (tmp == 0UL){
            {
                safe_free(text);
            }
            if (pretext){
                {
                    safe_free(pretext);
                }
            }
            if (option){
                {
                    safe_free(option);
                }
            }
            return;
        }
        if (g_bibpunct_style == 1){
            {
                tmp___0 = script_size();
                tmp___1 = script_shift();
                fprintRTF((char*)"{\\up%d\\fs%d ", tmp___1, tmp___0);
            }
        }
        if (g_current_cite_paren){
            {
                ConvertString((const char*)g_bibpunct_open);
            }
        }
        {
            keys = strdup_noblanks((const char*)text);
            safe_free(text);
        }
        if (g_sorted_citations){
            {
                text = reorder_citations(keys, 1);
                safe_free(keys);
                keys = text;
            }
        }
        {
            g_current_cite_item = 0;
            key = keys;
            next_keys = popCommaName(key);
            last_key = !next_keys;
        }
        {
            while (1){
                while_continue:
                ;
                if (!key){
                    goto while_break;
                }
                {
                    g_current_cite_item++;
                    tmp___2 = strcmp((const char*)key, (const char*)BIB_DASH_MARKER);
                }
                if (tmp___2 == 0){
                    {
                        fprintRTF((char*)"-");
                        first_key = 1;
                    }
                }else{
                    {
                        s = ScanAux(0, key, 0);
                        diagnostics(4, (char*)"natbib key=[%s] <%s> ", key, s);
                    }
                    if (s){
                        {
                            g_current_cite_seen = citation_used(key);
                            ConvertNatbib(s, code, pretext, option, first_key, last_key);
                        }
                    }else{
                        if (!first_key){
                            {
                                ConvertString((const char*)g_bibpunct_cite_sep);
                                fprintRTF((char*)" ");
                            }
                        }
                        {
                            ConvertString((const char*)key);
                        }
                    }
                    if (s){
                        {
                            safe_free(s);
                        }
                    }
                    first_key = 0;
                }
                {
                    key = next_keys;
                    next_keys = popCommaName(key);
                    last_key = !next_keys;
                }
            }
            while_break:
            ;
        }
        if (g_current_cite_paren){
            {
                ConvertString((const char*)g_bibpunct_close);
            }
        }
        if (g_bibpunct_style == 1){
            {
                fprintRTF((char*)"}");
            }
        }
        if (keys){
            {
                safe_free(keys);
            }
        }
        if (option){
            {
                safe_free(option);
            }
        }
        if (pretext){
            {
                safe_free(pretext);
            }
        }
        return;
    }
}

void CmdHarvardCite(int code)
{
    char* text;
    char* s;
    char* keys;
    char* key;
    char* next_keys;
    char* posttext;
    char* pretext;
    int first_key;
    size_t tmp;
    biblioElem* hcite;
    int tmp___0;
    {
        posttext = (char*)((void*)0);
        pretext = (char*)((void*)0);
        first_key = 1;
        g_current_cite_paren = 1;
        g_last_author_cited[0] = (char)'\000';
        g_last_year_cited[0] = (char)'\000';
        if (code == 28){
            g_current_cite_paren = 0;
        }else
            if (code == 31){
                g_current_cite_paren = 0;
            }else
                if (code == 35){
                    g_current_cite_paren = 0;
                }else
                    if (code == 29){
                        g_current_cite_paren = 0;
                    }

        {
            posttext = getBracketParam();
            text = getBraceParam();
        }
        if (code == 30){
            {
                pretext = getBraceParam();
            }
        }
        {
            s = strdup_nocomments((const char*)text);
            safe_free(text);
            text = s;
            tmp = strlen((const char*)text);
        }
        if (tmp == 0UL){
            {
                safe_free(text);
            }
            if (pretext){
                {
                    safe_free(pretext);
                }
            }
            if (posttext){
                {
                    safe_free(posttext);
                }
            }
            return;
        }
        if (g_current_cite_paren){
            {
                fprintRTF((char*)"\n");
                ConvertString((const char*)g_bibpunct_open);
            }
        }
        {
            keys = strdup_noblanks((const char*)text);
            safe_free(text);
        }
        if (g_sorted_citations){
            {
                text = reorder_citations(keys, 0);
                safe_free(keys);
                keys = text;
            }
        }
        {
            key = keys;
            next_keys = popCommaName(key);
            g_current_cite_item = 0;
        }
        {
            while (1){
                while_continue:
                ;
                if (!key){
                    goto while_break;
                }
                {
                    g_current_cite_item++;
                    tmp___0 = strcmp((const char*)key, (const char*)BIB_DASH_MARKER);
                }
                if (tmp___0 == 0){
                    {
                        fprintRTF((char*)"-");
                        first_key = 1;
                        key = next_keys;
                        next_keys = popCommaName(key);
                    }
                    goto while_continue;
                }
                {
                    hcite = getBiblio(key);
                }
                if (!first_key){
                    {
                        ConvertString((const char*)g_bibpunct_cite_sep);
                        fprintRTF((char*)" ");
                    }
                }
                if ((unsigned long )((void*)0) != (unsigned long )hcite){
                    if ((unsigned int)hcite->biblioType == 1U){
                        {
                            g_current_cite_seen = citation_used(key);
                            ConvertHarvard(hcite, code, pretext, (char*)((void*)0), first_key);
                        }
                    }else{
                        {
                            ConvertString((const char*)key);
                        }
                    }
                }else{
                    {
                        ConvertString((const char*)key);
                    }
                }
                {
                    first_key = 0;
                    key = next_keys;
                    next_keys = popCommaName(key);
                }
            }
            while_break:
            ;
        }
        if (posttext){
            {
                fprintRTF((char*)"%s", g_bibpunct_postnote_sep);
                ConvertString((const char*)posttext);
            }
        }
        if (g_current_cite_paren){
            {
                fprintRTF((char*)"\n");
                ConvertString((const char*)g_bibpunct_close);
            }
        }
        if (keys){
            {
                safe_free(keys);
            }
        }
        if (posttext){
            {
                safe_free(posttext);
            }
        }
        if (pretext){
            {
                safe_free(pretext);
            }
        }
        return;
    }
}

static void putHtmlRTF(const char* style___0)
{
    int n;
    char* tmp;
    char* tmp___0;
    char* tmp___1;
    {
        if (style___0){
            {
                tmp___1 = strstr(style___0, "rm");
            }
            if (tmp___1){
                {
                    CmdFontFamily(1);
                }
            }else{
                {
                    tmp___0 = strstr(style___0, "tt");
                }
                if (tmp___0){
                    {
                        CmdFontFamily(9);
                    }
                }else{
                    {
                        tmp = strstr(style___0, "sf");
                    }
                    if (tmp){
                        {
                            CmdFontFamily(5);
                        }
                    }
                }
            }
        }else{
            {
                CmdFontFamily(9);
            }
        }
        {
            n = existsDefinition((char*)"UrlFont");
        }
        if (n != -1){
            {
                ConvertString("\\UrlFont");
            }
        }
        return;
    }
}

static void InsertRtfHyperlink(const char* text, const char* url, const char* baseurl___0, const char* style___0)
{
    char* fullurl;
    char* tmp;
    {
        {
            tmp = strdup_together(baseurl___0, url);
            fullurl = tmp;
            fprintRTF((char*)"{");
            putHtmlRTF(style___0);
            fprintRTF((char*)"\\field{\\*\\fldinst{ HYPERLINK \"");
            putRtfStrEscaped((const char*)fullurl);
            fprintRTF((char*)"\" }{{}}}{\\fldrslt{");
            ConvertString(text);
            fprintRTF((char*)"}}}");
            safe_free(fullurl);
        }
        return;
    }
}

static char* baseurl = (char*)((void*)0);
static char* urlstyle = (char*)((void*)0);

void CmdHtml(int code)
{
    char* text;
    char* url;
    char* s;
    char* a;
    char* b;
    char* category;
    char* name;
    {
        text = (char*)((void*)0);
        url = (char*)((void*)0);
        s = (char*)((void*)0);
        {
            if (code == 8){
                goto case_8;
            }
            if (code == 9){
                goto case_9;
            }
            if (code == 2){
                goto case_2;
            }
            if (code == 12){
                goto case_12;
            }
            if (code == 18){
                goto case_18;
            }
            if (code == 14){
                goto case_14;
            }
            if (code == 13){
                goto case_14;
            }
            if (code == 15){
                goto case_15;
            }
            if (code == 16){
                goto case_16;
            }
            goto switch_break;
            case_8:
            {
                text = getBraceParam();
                url = getBraceParam();
            }
            {
                while (1){
                    while_continue:
                    ;
                    {
                        s = strstr((const char*)text, "\\~{}");
                    }
                    if (!((unsigned long )s != (unsigned long )((void*)0))){
                        goto while_break;
                    }
                    {
                        *s = (char)'~';
                        my_strcpy(s + 1, (const char*)(s + 4));
                    }
                }
                while_break:
                ;
            }
            {
                while (1){
                    while_continue___0:
                    ;
                    {
                        s = strstr((const char*)url, "\\~{}");
                    }
                    if (!((unsigned long )s != (unsigned long )((void*)0))){
                        goto while_break___0;
                    }
                    {
                        *s = (char)'~';
                        my_strcpy(s + 1, (const char*)(s + 4));
                    }
                }
                while_break___0:
                ;
            }
            {
                InsertRtfHyperlink((const char*)text, (const char*)url, (const char*)((void*)0), (const char*)((void*)0));
            }
            goto switch_break;
            case_9:
            {
                text = getBraceParam();
                url = getBraceParam();
                ConvertString((const char*)text);
            }
            goto switch_break;
            case_2:
            {
                url = getBracketParam();
            }
            if (!url){
                {
                    a = getBraceParam();
                    category = getBraceParam();
                    name = getBraceParam();
                    b = strdup_together3((const char*)a, "#", (const char*)category);
                    url = strdup_together3((const char*)b, ".", (const char*)name);
                    safe_free(b);
                    safe_free(name);
                    safe_free(category);
                    safe_free(a);
                }
            }
            {
                text = getBraceParam();
                InsertRtfHyperlink((const char*)text, (const char*)url, (const char*)baseurl, (const char*)urlstyle);
            }
            goto switch_break;
            case_12:
            {
                url = getBraceParam();
                text = getBraceParam();
                InsertRtfHyperlink((const char*)text, (const char*)url, (const char*)baseurl, (const char*)urlstyle);
            }
            goto switch_break;
            case_18:
            {
                url = getBraceRawParam();
                text = strdup_together((const char*)baseurl, (const char*)url);
                fprintRTF((char*)"{");
                putHtmlRTF((const char*)urlstyle);
                fprintRTF((char*)"\\field{\\*\\fldinst{ HYPERLINK \"");
                putRtfStrEscaped((const char*)text);
                fprintRTF((char*)"\" }{{}}}{\\fldrslt{");
                putRtfStrEscaped((const char*)text);
                fprintRTF((char*)"}}}");
            }
            goto switch_break;
            case_14:
            case_13:
            {
                url = getBraceRawParam();
                text = strdup_together((const char*)baseurl, (const char*)url);
                fprintRTF((char*)"{");
                putHtmlRTF((const char*)urlstyle);
                putRtfStrEscaped((const char*)text);
                fprintRTF((char*)"}");
            }
            goto switch_break;
            case_15:
            if (baseurl){
                {
                    safe_free(baseurl);
                }
            }
            {
                baseurl = getBraceRawParam();
            }
            goto switch_break;
            case_16:
            if (urlstyle){
                {
                    safe_free(urlstyle);
                }
            }
            {
                urlstyle = getBraceParam();
            }
            goto switch_break;
            switch_break:
            ;
        }
        if (text){
            {
                safe_free(text);
            }
        }
        if (url){
            {
                safe_free(url);
            }
        }
        return;
    }
}

void CmdBCAY(int code)
{
    char* s;
    char* t;
    char* v;
    char* year;
    int tmp;
    {
        {
            s = (char*)((void*)0);
            s = getBraceParam();
            diagnostics(4, (char*)"Entering CmdBCAY", s);
            t = getBraceParam();
            year = getBraceParam();
        }
        if (g_current_cite_seen){
            v = t;
        }else{
            v = s;
        }
        {
            diagnostics(4, (char*)"s    = <%s>", s);
            diagnostics(4, (char*)"t    = <%s>", t);
            diagnostics(4, (char*)"year = <%s>", year);
            diagnostics(4, (char*)"type = %d, seen = %d, item= %d", g_current_cite_type, g_current_cite_seen, g_current_cite_item);
        }
        {
            if (g_current_cite_type == 7){
                goto case_7;
            }
            if (g_current_cite_type == 4){
                goto case_7;
            }
            if (g_current_cite_type == 1){
                goto case_7;
            }
            if (g_current_cite_type == 10){
                goto case_10;
            }
            if (g_current_cite_type == 8){
                goto case_8;
            }
            if (g_current_cite_type == 5){
                goto case_8;
            }
            if (g_current_cite_type == 2){
                goto case_8;
            }
            if (g_current_cite_type == 11){
                goto case_11;
            }
            if (g_current_cite_type == 12){
                goto case_12;
            }
            if (g_current_cite_type == 9){
                goto case_12;
            }
            if (g_current_cite_type == 6){
                goto case_12;
            }
            if (g_current_cite_type == 3){
                goto case_12;
            }
            if (g_current_cite_type == 14){
                goto case_14;
            }
            if (g_current_cite_type == 13){
                goto case_14;
            }
            goto switch_break;
            case_7:
            case_4:
            case_1:
            {
                tmp = strcmp((const char*)v, (const char*)(g_last_author_cited));
            }
            if (tmp != 0){
                {
                    ConvertString((const char*)v);
                    my_strlcpy(g_last_author_cited, (const char*)v, (size_t)201);
                    my_strlcpy(g_last_year_cited, (const char*)year, (size_t)51);
                }
                if (g_current_cite_type == 7){
                    {
                        fprintRTF((char*)" (");
                    }
                }else{
                    {
                        fprintRTF((char*)", ");
                    }
                }
            }
            {
                ConvertString((const char*)year);
            }
            if (g_current_cite_type == 7){
                {
                    fprintRTF((char*)")");
                }
            }
            goto switch_break;
            case_10:
            {
                ConvertString((const char*)v);
            }
            goto switch_break;
            case_8:
            case_5:
            case_2:
            {
                ConvertString((const char*)s);
            }
            if (g_current_cite_type == 8){
                {
                    fprintRTF((char*)" (");
                }
            }else{
                {
                    fprintRTF((char*)", ");
                }
            }
            {
                ConvertString((const char*)year);
            }
            if (g_current_cite_type == 8){
                {
                    fprintRTF((char*)")");
                }
            }
            goto switch_break;
            case_11:
            {
                ConvertString((const char*)s);
            }
            goto switch_break;
            case_12:
            case_9:
            case_6:
            case_3:
            {
                ConvertString((const char*)t);
            }
            if (g_current_cite_type == 9){
                {
                    fprintRTF((char*)" (");
                }
            }else{
                {
                    fprintRTF((char*)", ");
                }
            }
            {
                ConvertString((const char*)year);
            }
            if (g_current_cite_type == 9){
                {
                    fprintRTF((char*)")");
                }
            }
            goto switch_break;
            case_14:
            case_13:
            {
                ConvertString((const char*)year);
            }
            goto switch_break;
            switch_break:
            ;
        }
        {
            safe_free(s);
            safe_free(t);
            safe_free(year);
        }
        return;
    }
}

static void ConvertBraceParam(char* pre, char* post)
{
    char* s;
    char* t;
    size_t tmp;
    {
        {
            s = (char*)((void*)0);
            t = (char*)((void*)0);
            s = getBraceParam();
            tmp = strlen((const char*)s);
        }
        if (tmp > 0UL){
            {
                t = strdup_together3((const char*)pre, (const char*)s, (const char*)post);
                ConvertString((const char*)t);
                safe_free(t);
            }
        }
        {
            safe_free(s);
        }
        return;
    }
}

static void DiscardBraceParam(void)
{
    char* s;
    {
        {
            s = getBraceParam();
        }
        if (s){
            {
                safe_free(s);
            }
        }
        return;
    }
}

void CmdApaCite(int code)
{
    int n;
    char* s;
    char* month[12];
    int tmp;
    {
        month[0] = (char*)"Jan";
        month[1] = (char*)"Feb";
        month[2] = (char*)"Mar";
        month[3] = (char*)"Apr";
        month[4] = (char*)"May";
        month[5] = (char*)"Jun";
        month[6] = (char*)"Jul";
        month[7] = (char*)"Aug";
        month[8] = (char*)"Sep";
        month[9] = (char*)"Oct";
        month[10] = (char*)"Nov";
        month[11] = (char*)"Dec";
        {
            if (code == 0){
                goto case_0;
            }
            if (code == 1){
                goto case_1;
            }
            if (code == 2){
                goto case_2;
            }
            if (code == 3){
                goto case_3;
            }
            if (code == 4){
                goto case_4;
            }
            if (code == 5){
                goto case_5;
            }
            if (code == 6){
                goto case_6;
            }
            if (code == 7){
                goto case_7;
            }
            if (code == 8){
                goto case_8;
            }
            if (code == 9){
                goto case_9;
            }
            if (code == 10){
                goto case_10;
            }
            if (code == 11){
                goto case_11;
            }
            if (code == 12){
                goto case_12;
            }
            if (code == 13){
                goto case_13;
            }
            if (code == 14){
                goto case_14;
            }
            if (code == 15){
                goto case_15;
            }
            if (code == 16){
                goto case_16;
            }
            if (code == 17){
                goto case_17;
            }
            if (code == 18){
                goto case_18;
            }
            if (code == 19){
                goto case_19;
            }
            if (code == 20){
                goto case_20;
            }
            if (code == 21){
                goto case_21;
            }
            if (code == 22){
                goto case_22;
            }
            if (code == 23){
                goto case_23;
            }
            if (code == 24){
                goto case_24;
            }
            if (code == 25){
                goto case_25;
            }
            if (code == 26){
                goto case_26;
            }
            if (code == 27){
                goto case_27;
            }
            if (code == 28){
                goto case_28;
            }
            if (code == 29){
                goto case_29;
            }
            if (code == 30){
                goto case_30;
            }
            if (code == 31){
                goto case_31;
            }
            if (code == 32){
                goto case_32;
            }
            if (code == 33){
                goto case_33;
            }
            if (code == 34){
                goto case_34;
            }
            if (code == 35){
                goto case_35;
            }
            if (code == 36){
                goto case_36;
            }
            if (code == 37){
                goto case_37;
            }
            if (code == 38){
                goto case_38;
            }
            if (code == 202){
                goto case_202;
            }
            if (code == 201){
                goto case_201;
            }
            if (code == 203){
                goto case_203;
            }
            if (code == 204){
                goto case_204;
            }
            if (code == 205){
                goto case_205;
            }
            if (code == 206){
                goto case_206;
            }
            if (code == 207){
                goto case_207;
            }
            if (code == 208){
                goto case_208;
            }
            if (code == 209){
                goto case_209;
            }
            if (code == 210){
                goto case_210;
            }
            if (code == 211){
                goto case_211;
            }
            if (code == 213){
                goto case_213;
            }
            if (code == 212){
                goto case_212;
            }
            if (code == 227){
                goto case_212;
            }
            if (code == 214){
                goto case_214;
            }
            if (code == 215){
                goto case_215;
            }
            if (code == 223){
                goto case_223;
            }
            if (code == 216){
                goto case_216;
            }
            if (code == 217){
                goto case_217;
            }
            if (code == 225){
                goto case_225;
            }
            if (code == 218){
                goto case_218;
            }
            if (code == 219){
                goto case_219;
            }
            if (code == 220){
                goto case_220;
            }
            if (code == 224){
                goto case_224;
            }
            if (code == 221){
                goto case_221;
            }
            if (code == 226){
                goto case_226;
            }
            goto switch_default;
            case_0:
            {
                fprintRTF((char*)" (");
            }
            goto switch_break;
            case_1:
            {
                fprintRTF((char*)"&");
            }
            goto switch_break;
            case_2:
            {
                fprintRTF((char*)"and");
            }
            goto switch_break;
            case_3:
            {
                fprintRTF((char*)", ");
            }
            goto switch_break;
            case_4:
            {
                fprintRTF((char*)"; ");
            }
            goto switch_break;
            case_5:
            {
                fprintRTF((char*)", ");
            }
            goto switch_break;
            case_6:
            {
                fprintRTF((char*)")");
            }
            goto switch_break;
            case_7:
            {
                fprintRTF((char*)"");
            }
            goto switch_break;
            case_8:
            {
                fprintRTF((char*)"");
            }
            goto switch_break;
            case_9:
            {
                fprintRTF((char*)",");
            }
            goto switch_break;
            case_10:
            {
                fprintRTF((char*)",");
            }
            goto switch_break;
            case_11:
            {
                s = getBraceParam();
                fprintRTF((char*)"et al.");
                safe_free(s);
            }
            goto switch_break;
            case_12:
            {
                fprintRTF((char*)"in press");
            }
            goto switch_break;
            case_13:
            {
                fprintRTF((char*)"and");
            }
            goto switch_break;
            case_14:
            {
                fprintRTF((char*)"Ed.");
            }
            goto switch_break;
            case_15:
            {
                fprintRTF((char*)"Eds.");
            }
            goto switch_break;
            case_16:
            {
                fprintRTF((char*)"Trans.");
            }
            goto switch_break;
            case_17:
            {
                fprintRTF((char*)"Trans.");
            }
            goto switch_break;
            case_18:
            {
                fprintRTF((char*)"Chair");
            }
            goto switch_break;
            case_19:
            {
                fprintRTF((char*)"Chairs");
            }
            goto switch_break;
            case_20:
            {
                fprintRTF((char*)"Vol.");
            }
            goto switch_break;
            case_21:
            {
                fprintRTF((char*)"Vols.");
            }
            goto switch_break;
            case_22:
            {
                fprintRTF((char*)"No.");
            }
            goto switch_break;
            case_23:
            {
                fprintRTF((char*)"Nos.");
            }
            goto switch_break;
            case_24:
            {
                fprintRTF((char*)"ed.");
            }
            goto switch_break;
            case_25:
            {
                fprintRTF((char*)"p.");
            }
            goto switch_break;
            case_26:
            {
                fprintRTF((char*)"pp.");
            }
            goto switch_break;
            case_27:
            {
                fprintRTF((char*)"Tech. Rep.");
            }
            goto switch_break;
            case_28:
            {
                fprintRTF((char*)"Doctoral dissertation");
            }
            goto switch_break;
            case_29:
            {
                fprintRTF((char*)"Unpublished doctoral dissertation");
            }
            goto switch_break;
            case_30:
            {
                fprintRTF((char*)"Master\'s thesis");
            }
            goto switch_break;
            case_31:
            {
                fprintRTF((char*)"Unpublished master\'s thesis");
            }
            goto switch_break;
            case_32:
            {
                fprintRTF((char*)"Original work published ");
            }
            goto switch_break;
            case_33:
            {
                fprintRTF((char*)"Reprinted from ");
            }
            goto switch_break;
            case_34:
            {
                s = getBraceParam();
                tmp = sscanf((const char*)s, (const char*)"%d", &n);
            }
            if (tmp == 1){
                {
                    fprintRTF((char*)"%c", (97 + n) - 1);
                }
            }
            {
                safe_free(s);
            }
            goto switch_break;
            case_35:
            if (g_current_cite_paren){
                {
                    fprintRTF((char*)"&");
                }
            }else
                if (g_in_bibliography){
                    {
                        fprintRTF((char*)"&");
                    }
                }else{
                    {
                        fprintRTF((char*)"and");
                    }
                }
            goto switch_break;
            case_36:
            {
                DiscardBraceParam();
                diagnostics(4, (char*)"Ignoring \\AX{blah blah}");
            }
            goto switch_break;
            case_37:
            {
                fprintRTF((char*)". ");
            }
            goto switch_break;
            case_38:
            {
                fprintRTF((char*)"In");
            }
            goto switch_break;
            case_202:
            {
                ConvertString("$\\star");
            }
            goto switch_break;
            case_201:
            {
                ConvertBraceParam((char*)"", (char*)"");
            }
            goto switch_break;
            case_203:
            {
                ConvertBraceParam((char*)"``", (char*)"\'\'");
            }
            goto switch_break;
            case_204:
            {
                ConvertBraceParam((char*)"\\textit{", (char*)"}");
            }
            goto switch_break;
            case_205:
            {
                DiscardBraceParam();
            }
            goto switch_break;
            case_206:
            {
                fprintRTF((char*)"(");
                ConvertBraceParam((char*)"", (char*)"");
                ConvertBraceParam((char*)", ", (char*)"");
                ConvertBraceParam((char*)" ", (char*)"");
                fprintRTF((char*)")");
            }
            goto switch_break;
            case_207:
            {
                DiscardBraceParam();
                ConvertBraceParam((char*)"", (char*)"");
            }
            goto switch_break;
            case_208:
            {
                DiscardBraceParam();
                ConvertBraceParam((char*)"\\textit{", (char*)"}");
            }
            goto switch_break;
            case_209:
            {
                ConvertBraceParam((char*)"\\textit{", (char*)"}");
                ConvertBraceParam((char*)", \\textit{", (char*)"}");
                ConvertBraceParam((char*)"(", (char*)")");
                ConvertBraceParam((char*)", ", (char*)"");
            }
            goto switch_break;
            case_210:
            {
                ConvertBraceParam((char*)"(", (char*)")");
            }
            goto switch_break;
            case_211:
            {
                ConvertBraceParam((char*)"", (char*)": ");
                ConvertBraceParam((char*)"", (char*)"");
            }
            goto switch_break;
            case_213:
            {
                DiscardBraceParam();
            }
            goto switch_break;
            case_212:
            case_227:
            {
                ConvertBraceParam((char*)"", (char*)"");
            }
            goto switch_break;
            case_214:
            {
                ConvertBraceParam((char*)"", (char*)": Author");
                DiscardBraceParam();
            }
            goto switch_break;
            case_215:
            {
                DiscardBraceParam();
                ConvertBraceParam((char*)"[", (char*)"]");
            }
            goto switch_break;
            case_223:
            {
                DiscardBraceParam();
                ConvertBraceParam((char*)"[", (char*)"]");
            }
            goto switch_break;
            case_216:
            {
                s = getBraceParam();
            }
            if (s){
                if (*s){
                    {
                        sscanf((const char*)s, (const char*)"%d", &n);
                        ConvertString((const char*)month[n - 1]);
                        safe_free(s);
                    }
                }
            }
            goto switch_break;
            case_217:
            {
                DiscardBraceParam();
                ConvertBraceParam((char*)"(", (char*)")");
            }
            goto switch_break;
            case_225:
            {
                fprintRTF((char*)"(");
                DiscardBraceParam();
                ConvertBraceParam((char*)"", (char*)"");
                ConvertBraceParam((char*)", ", (char*)"");
                fprintRTF((char*)")");
            }
            goto switch_break;
            case_218:
            {
                ConvertBraceParam((char*)"", (char*)"");
                ConvertBraceParam((char*)": ", (char*)"");
            }
            goto switch_break;
            case_219:
            {
                ConvertBraceParam((char*)"", (char*)"");
            }
            goto switch_break;
            case_220:
            {
                ConvertBraceParam((char*)"(Original work published ", (char*)")");
                DiscardBraceParam();
            }
            goto switch_break;
            case_224:
            {
                s = getBraceParam();
                ConvertBraceParam((char*)"(Reprinted from \\textit{", (char*)"}");
            }
            if (s){
                if (*s){
                    {
                        fprintRTF((char*)", ");
                        ConvertString((const char*)s);
                        safe_free(s);
                    }
                }
            }
            {
                ConvertBraceParam((char*)", \\textit{", (char*)"}");
                ConvertBraceParam((char*)"(", (char*)")");
                ConvertBraceParam((char*)", ", (char*)"");
                fprintRTF((char*)")");
            }
            goto switch_break;
            case_221:
            {
                ConvertBraceParam((char*)"(", (char*)")");
            }
            goto switch_break;
            case_226:
            goto switch_break;
            switch_default:
            ;
            switch_break:
            ;
        }
        return;
    }
}

void CmdCiteName(int code)
{
    char* s;
    const char* tmp;
    {
        {
            s = (char*)((void*)0);
            s = getBraceParam();
        }
        if (s){
            tmp = (const char*)s;
        }else{
            tmp = "";
        }
        {
            diagnostics(4, (char*)"Entering CmdCitename [%s]", tmp);
        }
        if (!g_suppress_name){
            {
                ConvertString((const char*)s);
            }
        }
        {
            safe_free(s);
        }
        return;
    }
}

void CmdNumberLine(int code)
{
    char* number;
    {
        {
            number = getBraceParam();
            diagnostics(4, (char*)"Entering CmdNumberLine [%s]", number);
            ConvertString((const char*)number);
            fprintRTF((char*)"\\tab\n");
            safe_free(number);
        }
        return;
    }
}

void CmdHarvard(int code)
{
    {
        {
            if (code == 32){
                goto case_32;
            }
            if (code == 33){
                goto case_33;
            }
            if (code == 34){
                goto case_34;
            }
            if (code == 36){
                goto case_36;
            }
            goto switch_default;
            case_32:
            {
                ignoreBracketParam();
                ignoreBraceParam();
                ignoreBraceParam();
                ignoreBraceParam();
            }
            goto switch_break;
            case_33:
            {
                fprintRTF((char*)"(");
            }
            goto switch_break;
            case_34:
            {
                fprintRTF((char*)")");
            }
            goto switch_break;
            case_36:
            {
                fprintRTF((char*)"&");
            }
            switch_default:
            goto switch_break;
            switch_break:
            ;
        }
        return;
    }
}

void CmdContentsLine(int code)
{
    char* type;
    char* text;
    char* num;
    char* contents_type;
    {
        {
            type = getBraceParam();
            text = getBraceParam();
            num = getBraceParam();
            diagnostics(4, (char*)"Entering CmdContentsLine %s [%s]", type, text);
            startParagraph("contents", 3);
            fprintRTF((char*)"{");
            contents_type = strdup_together("contents_", (const char*)type);
            InsertStyle((const char*)contents_type);
            fprintRTF((char*)" ");
            ConvertString((const char*)text);
            CmdEndParagraph(0);
            fprintRTF((char*)"}");
            safe_free(type);
            safe_free(text);
            safe_free(num);
            safe_free(contents_type);
        }
        return;
    }
}

void CmdListOf(int code)
{
    char c;
    {
        {
            c = (char)' ';
            diagnostics(4, (char*)"Entering CmdListOf");
            startParagraph("contents", 3);
            fprintRTF((char*)" ");
        }
        {
            if (code == 1){
                goto case_1;
            }
            if (code == 2){
                goto case_2;
            }
            if (code == 3){
                goto case_3;
            }
            goto switch_break;
            case_1:
            {
                ConvertBabelName((char*)"LISTFIGURENAME");
                c = (char)'f';
            }
            goto switch_break;
            case_2:
            {
                ConvertBabelName((char*)"LISTTABLENAME");
                c = (char)'t';
            }
            goto switch_break;
            case_3:
            {
                ConvertBabelName((char*)"CONTENTSNAME");
                c = (char)'c';
            }
            goto switch_break;
            switch_break:
            ;
        }
        {
            CmdEndParagraph(0);
            startParagraph("Normal", 2);
            CmdVspace(1);
            g_tableofcontents = 1;
            fprintRTF((char*)"{\\field{\\*\\fldinst TOC \\\\f %c }{\\fldrslt }}\n", (int)c);
            CmdNewPage(1);
            CmdEndParagraph(0);
        }
        return;
    }
}

int GermanMode;
int RecursionLevel;
int g_tab_counter;
int g_equation_column;
int g_processing_tabbing;
int g_processing_tabular;
int g_processing_eqnarray;
int g_processing_arrays;
int g_escape_parens;
void ConvertAllttString(char* s);
int CallCommandFunc(char* cCommand);
void CmdUmlauteChar(int code);
void CmdGraveChar(int code);
void CmdAcuteChar(int code);
void CmdTildeChar(int code);
void CmdHatChar(int code);
void CmdMacronChar(int code);
void CmdDotChar(int code);
void CmdUnicodeChar(int code);
void CmdIgnore(int code);
void TranslateGerman(void);
void CmdSpace(float kk);
void CmdNonBreakSpace(int code);
int TryConditionSet(char* command);
int CurrentFontEncoding(void);
void PushLevels(void);
void CleanStack(void);
void PushBrace(void);
int PopBrace(void);
void CmdTabjump(void);
void CmdTabset(void);
void CmdEquation(int code);
void CmdSuperscript(int code);
void CmdSubscript(int code);
void CmdSlashSlash(int height);
void CmdArraySlashSlash(int height);
void CmdEqnArraySlashSlash(int height);
int TryDirectConvert(char* command);
int TryVariableIgnore(const char* command);
void CmdOT2Transliteration(int cThis);
void show_string(int level, const char* s, const char* label);
int StillSource(void);
char getTexChar(void);
int getSameChar(char c);
void skipSpaces(void);
int getSlashSlashParam(void);
static int ret = 0;
static void TranslateCommand(void);

void ConvertString(const char* string)
{
    int tmp;
    int tmp___0;
    {
        if ((unsigned long )string == (unsigned long )((void*)0)){
            return;
        }else
            if ((unsigned long )string == (unsigned long )((const char*)0)){
                return;
            }

        {
            tmp___0 = PushSource((const char*)((void*)0), string);
        }
        if (tmp___0 == 0){
            {
                diagnostics(5, (char*)"Entering Convert() from ConvertString()");
                show_string(4, string, "converting");
            }
            {
                while (1){
                    while_continue:
                    ;
                    {
                        tmp = StillSource();
                    }
                    if (!tmp){
                        goto while_break;
                    }
                    {
                        Convert();
                    }
                }
                while_break:
                ;
            }
            {
                PopSource();
                diagnostics(5, (char*)"Exiting Convert() from ConvertString()");
            }
        }
        return;
    }
}

void ConvertAllttString(char* s)
{
    char cThis;
    int tmp;
    int tmp___0;
    int tmp___1;
    {
        if ((unsigned long )s == (unsigned long )((void*)0)){
            return;
        }
        {
            diagnostics(3, (char*)"Entering Convert() from StringAllttConvert()");
            tmp___1 = PushSource((const char*)((void*)0), (const char*)s);
        }
        if (tmp___1 == 0){
            {
                while (1){
                    while_continue:
                    ;
                    {
                        tmp___0 = StillSource();
                    }
                    if (!tmp___0){
                        goto while_break;
                    }
                    {
                        cThis = getRawTexChar();
                    }
                    {
                        if ((int)cThis == 92){
                            goto case_92;
                        }
                        if ((int)cThis == 123){
                            goto case_123;
                        }
                        if ((int)cThis == 125){
                            goto case_125;
                        }
                        goto switch_default;
                        case_92:
                        {
                            PushLevels();
                            TranslateCommand();
                            CleanStack();
                        }
                        goto switch_break;
                        case_123:
                        {
                            PushBrace();
                            fprintRTF((char*)"{");
                        }
                        goto switch_break;
                        case_125:
                        {
                            tmp = PopBrace();
                            ret = RecursionLevel - tmp;
                            fprintRTF((char*)"}");
                        }
                        goto switch_break;
                        switch_default:
                        {
                            fprintRTF((char*)"%c", (int)cThis);
                        }
                        goto switch_break;
                        switch_break:
                        ;
                    }
                }
                while_break:
                ;
            }
            {
                PopSource();
            }
        }
        {
            diagnostics(3, (char*)"Exiting Convert() from StringAllttConvert()");
        }
        return;
    }
}

void Convert(void)
{
    char cThis;
    char cLast;
    char cNext;
    int count;
    int tmp;
    int tmp___0;
    uint8_t byte;
    uint16_t len;
    uint16_t value;
    uint16_t i;
    char tmp___1;
    int tmp___2;
    int tmp___3;
    int tmp___4;
    int tmp___5;
    int tmp___6;
    int tmp___7;
    int tmp___8;
    int tmp___9;
    int tmp___10;
    int tmp___11;
    int tmp___12;
    int tmp___13;
    int tmp___14;
    int tmp___15;
    int tmp___16;
    int tmp___17;
    int tmp___18;
    int tmp___19;
    int tmp___20;
    int tmp___21;
    int tmp___22;
    int tmp___23;
    int tmp___24;
    int tmp___25;
    int tmp___26;
    int tmp___27;
    int tmp___28;
    int tmp___29;
    int tmp___30;
    int tmp___31;
    int tmp___32;
    int tmp___33;
    int tmp___36;
    int tmp___37;
    int tmp___38;
    int tmp___39;
    int tmp___40;
    int tmp___41;
    int tmp___42;
    int tmp___43;
    int tmp___44;
    int tmp___45;
    int tmp___46;
    int tmp___47;
    int tmp___48;
    {
        {
            cThis = (char)'\n';
            cLast = (char)'\000';
            diagnostics(3, (char*)"Entering Convert ret = %d", ret);
            RecursionLevel++;
            PushLevels();
        }
        {
            while (1){
                while_continue:
                ;
                {
                    cThis = getTexChar();
                }
                if (cThis){
                    if (!((int)cThis != 0)){
                        goto while_break;
                    }
                }else{
                    goto while_break;
                }
                if ((int)cThis == 10){
                    {
                        tmp = getTexMode();
                        diagnostics(6, (char*)"Current character is \'\\n\' mode = %d ret = %d level = %d", tmp, ret, RecursionLevel);
                    }
                }else{
                    {
                        tmp___0 = getTexMode();
                        diagnostics(6, (char*)"Current character is \'%c\' mode = %d ret = %d level = %d", (int)cThis, tmp___0, ret, RecursionLevel);
                    }
                }
                if ((int)cThis & 32768){
                    {
                        tmp___48 = CurrentFontEncoding();
                    }
                    if (tmp___48 == 31){
                        byte = (uint8_t)cThis;
                        len = (uint16_t)0;
                        value = (uint16_t)0;
                        if ((int)byte >= 240){
                            len = (uint16_t)3;
                            value = (uint16_t)((int)byte & -241);
                        }else
                            if ((int)byte >= 224){
                                len = (uint16_t)2;
                                value = (uint16_t)((int)byte & -225);
                            }else
                                if ((int)byte >= 192){
                                    len = (uint16_t)1;
                                    value = (uint16_t)((int)byte & -193);
                                }

                        i = (uint16_t)0;
                        {
                            while (1){
                                while_continue___0:
                                ;
                                if (!((int)i < (int)len)){
                                    goto while_break___0;
                                }
                                {
                                    tmp___1 = getTexChar();
                                    byte = (uint8_t)((int)tmp___1 & -193);
                                    value = (uint16_t)(((int)value << 6) + (int)byte);
                                    i = (uint16_t)((int)i + 1);
                                }
                            }
                            while_break___0:
                            ;
                        }
                        {
                            diagnostics(4, (char*)"(flag = 0x%X) char value = 0X%04X or %u (%u bytes)", (int)((unsigned char)cThis), (int)value, (int)value, (int)len);
                            CmdUnicodeChar((int)value);
                        }
                    }else{
                        goto _L___4;
                    }
                }else{
                    _L___4:
                    {
                        if ((int)cThis == 92){
                            goto case_92;
                        }
                        if ((int)cThis == 123){
                            goto case_123;
                        }
                        if ((int)cThis == 125){
                            goto case_125;
                        }
                        if ((int)cThis == 32){
                            goto case_32;
                        }
                        if ((int)cThis == 10){
                            goto case_10;
                        }
                        if ((int)cThis == 36){
                            goto case_36;
                        }
                        if ((int)cThis == 38){
                            goto case_38;
                        }
                        if ((int)cThis == 126){
                            goto case_126;
                        }
                        if ((int)cThis == 94){
                            goto case_94;
                        }
                        if ((int)cThis == 95){
                            goto case_95;
                        }
                        if ((int)cThis == 45){
                            goto case_45;
                        }
                        if ((int)cThis == 124){
                            goto case_124;
                        }
                        if ((int)cThis == 39){
                            goto case_39;
                        }
                        if ((int)cThis == 96){
                            goto case_96;
                        }
                        if ((int)cThis == 34){
                            goto case_34;
                        }
                        if ((int)cThis == 60){
                            goto case_60;
                        }
                        if ((int)cThis == 62){
                            goto case_62;
                        }
                        if ((int)cThis == 33){
                            goto case_33;
                        }
                        if ((int)cThis == 63){
                            goto case_63;
                        }
                        if ((int)cThis == 58){
                            goto case_58;
                        }
                        if ((int)cThis == 46){
                            goto case_46;
                        }
                        if ((int)cThis == 9){
                            goto case_9;
                        }
                        if ((int)cThis == 13){
                            goto case_13;
                        }
                        if ((int)cThis == 37){
                            goto case_37;
                        }
                        if ((int)cThis == 40){
                            goto case_40;
                        }
                        if ((int)cThis == 41){
                            goto case_41;
                        }
                        if ((int)cThis == 59){
                            goto case_59;
                        }
                        if ((int)cThis == 44){
                            goto case_44;
                        }
                        goto switch_default;
                        case_92:
                        {
                            PushLevels();
                            TranslateCommand();
                            CleanStack();
                        }
                        if (ret > 1){
                            {
                                diagnostics(3, (char*)"Exiting Convert via TranslateCommand ret = %d level = %d", ret, RecursionLevel);
                                ret--;
                                RecursionLevel--;
                            }
                            return;
                        }
                        goto switch_break;
                        case_123:
                        {
                            tmp___2 = getTexMode();
                        }
                        if (tmp___2 == 6){
                            {
                                changeTexMode(2);
                            }
                        }
                        {
                            CleanStack();
                            PushBrace();
                            fprintRTF((char*)"{");
                        }
                        goto switch_break;
                        case_125:
                        {
                            CleanStack();
                            tmp___3 = PopBrace();
                            ret = RecursionLevel - tmp___3;
                            fprintRTF((char*)"}");
                        }
                        if (ret > 1){
                            {
                                diagnostics(3, (char*)"Exiting Convert via \'}\' ret = %d level = %d", ret, RecursionLevel);
                                ret--;
                                RecursionLevel--;
                            }
                            return;
                        }
                        goto switch_break;
                        case_32:
                        {
                            tmp___5 = getTexMode();
                        }
                        if (tmp___5 == 6){
                            cThis = cLast;
                        }else{
                            {
                                tmp___6 = getTexMode();
                            }
                            if (tmp___6 == 4){
                                cThis = cLast;
                            }else{
                                {
                                    tmp___7 = getTexMode();
                                }
                                if (tmp___7 == 5){
                                    cThis = cLast;
                                }else
                                    if ((int)cLast != 32){
                                        if ((int)cLast != 10){
                                            {
                                                tmp___4 = getTexMode();
                                            }
                                            if (tmp___4 == 3){
                                                {
                                                    fprintRTF((char*)"\\~");
                                                }
                                            }else{
                                                {
                                                    fprintRTF((char*)" ");
                                                }
                                            }
                                        }
                                    }
                            }
                        }
                        goto switch_break;
                        case_10:
                        {
                            g_tab_counter = 0;
                            tmp___9 = getTexMode();
                        }
                        if (tmp___9 == 4){
                            {
                                cNext = getNonBlank();
                                ungetTexChar(cNext);
                            }
                        }else{
                            {
                                tmp___10 = getTexMode();
                            }
                            if (tmp___10 == 5){
                                {
                                    cNext = getNonBlank();
                                    ungetTexChar(cNext);
                                }
                            }else{
                                {
                                    cNext = getNonSpace();
                                }
                                if ((int)cNext == 10){
                                    {
                                        CmdEndParagraph(0);
                                    }
                                }else{
                                    {
                                        ungetTexChar(cNext);
                                        tmp___8 = getTexMode();
                                    }
                                    if (tmp___8 != 6){
                                        if ((int)cLast != 32){
                                            {
                                                fprintRTF((char*)" ");
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        goto switch_break;
                        case_36:
                        {
                            cNext = getTexChar();
                            diagnostics(5, (char*)"Processing $, next char <%c>", (int)cNext);
                        }
                        if ((int)cNext == 36){
                            {
                                tmp___11 = getTexMode();
                            }
                            if (tmp___11 != 4){
                                {
                                    CmdEquation(16398);
                                }
                            }else{
                                {
                                    ungetTexChar(cNext);
                                    CmdEquation(16386);
                                }
                            }
                        }else{
                            {
                                ungetTexChar(cNext);
                                CmdEquation(16386);
                            }
                        }
                        goto switch_break;
                        case_38:
                        if (g_processing_arrays){
                            {
                                fprintRTF((char*)"%c", (int)g_field_separator);
                            }
                            goto switch_break;
                        }
                        {
                            tmp___12 = EQ_field_active();
                        }
                        if (tmp___12){
                            {
                                diagnostics(4, (char*)"ending/restarting field before alignment \'&\'");
                                endCurrentField();
                                fprintRTF((char*)"\\tab\n");
                                startField(1);
                            }
                        }else{
                            {
                                diagnostics(4, (char*)"tabbing to match \'&\'");
                                fprintRTF((char*)"\\tab\n");
                            }
                        }
                        g_equation_column++;
                        goto switch_break;
                        case_126:
                        {
                            fprintRTF((char*)"\\~");
                        }
                        goto switch_break;
                        case_94:
                        {
                            CmdSuperscript(0);
                        }
                        goto switch_break;
                        case_95:
                        {
                            CmdSubscript(0);
                        }
                        goto switch_break;
                        case_45:
                        {
                            tmp___15 = getTexMode();
                        }
                        if (tmp___15 == 4){
                            {
                                CmdUnicodeChar(8722);
                            }
                        }else{
                            {
                                tmp___16 = getTexMode();
                            }
                            if (tmp___16 == 5){
                                {
                                    CmdUnicodeChar(8722);
                                }
                            }else{
                                {
                                    changeTexMode(2);
                                    tmp___13 = getSameChar((char)'-');
                                    count = tmp___13 + 1;
                                }
                                if (count == 1){
                                    {
                                        fprintRTF((char*)"-");
                                    }
                                }else
                                    if (count == 2){
                                        {
                                            fprintRTF((char*)"\\endash ");
                                        }
                                    }else
                                        if (count == 3){
                                            {
                                                fprintRTF((char*)"\\emdash ");
                                            }
                                        }else{
                                            {
                                                while (1){
                                                    while_continue___1:
                                                    ;
                                                    tmp___14 = count;
                                                    count--;
                                                    if (!tmp___14){
                                                        goto while_break___1;
                                                    }
                                                    {
                                                        fprintRTF((char*)"-");
                                                    }
                                                }
                                                while_break___1:
                                                ;
                                            }
                                        }
                            }
                        }
                        goto switch_break;
                        case_124:
                        {
                            tmp___17 = getTexMode();
                        }
                        if (tmp___17 == 4){
                            {
                                fprintRTF((char*)"|");
                            }
                        }else{
                            {
                                tmp___18 = getTexMode();
                            }
                            if (tmp___18 == 5){
                                {
                                    fprintRTF((char*)"|");
                                }
                            }else{
                                {
                                    fprintRTF((char*)"\\emdash ");
                                }
                            }
                        }
                        goto switch_break;
                        case_39:
                        {
                            tmp___21 = getTexMode();
                        }
                        if (tmp___21 == 4){
                            {
                                fprintRTF((char*)"\'");
                            }
                        }else{
                            {
                                tmp___22 = getTexMode();
                            }
                            if (tmp___22 == 5){
                                {
                                    fprintRTF((char*)"\'");
                                }
                            }else{
                                {
                                    changeTexMode(2);
                                    tmp___19 = getSameChar((char)'\'');
                                    count = tmp___19 + 1;
                                }
                                if (count == 2){
                                    {
                                        fprintRTF((char*)"\\rdblquote ");
                                    }
                                }else{
                                    {
                                        while (1){
                                            while_continue___2:
                                            ;
                                            tmp___20 = count;
                                            count--;
                                            if (!tmp___20){
                                                goto while_break___2;
                                            }
                                            {
                                                fprintRTF((char*)"\\rquote ");
                                            }
                                        }
                                        while_break___2:
                                        ;
                                    }
                                }
                            }
                        }
                        goto switch_break;
                        case_96:
                        {
                            tmp___23 = getTexMode();
                        }
                        if (tmp___23 == 6){
                            {
                                changeTexMode(2);
                            }
                        }
                        {
                            tmp___24 = getSameChar((char)'`');
                            count = tmp___24 + 1;
                        }
                        if (count == 2){
                            {
                                fprintRTF((char*)"\\ldblquote ");
                            }
                        }else{
                            {
                                while (1){
                                    while_continue___3:
                                    ;
                                    tmp___25 = count;
                                    count--;
                                    if (!tmp___25){
                                        goto while_break___3;
                                    }
                                    {
                                        fprintRTF((char*)"\\lquote ");
                                    }
                                }
                                while_break___3:
                                ;
                            }
                        }
                        goto switch_break;
                        case_34:
                        {
                            changeTexMode(2);
                        }
                        if (GermanMode){
                            {
                                TranslateGerman();
                            }
                        }else{
                            {
                                fprintRTF((char*)"\"");
                            }
                        }
                        goto switch_break;
                        case_60:
                        {
                            tmp___26 = getTexMode();
                        }
                        if (tmp___26 == 6){
                            {
                                changeTexMode(2);
                            }
                        }
                        {
                            tmp___27 = getTexMode();
                        }
                        if (tmp___27 == 2){
                            {
                                cNext = getTexChar();
                            }
                            if ((int)cNext == 60){
                                {
                                    fprintRTF((char*)"\\\'ab");
                                }
                            }else{
                                {
                                    ungetTexChar(cNext);
                                    fprintRTF((char*)"<");
                                }
                            }
                        }else{
                            {
                                fprintRTF((char*)"<");
                            }
                        }
                        goto switch_break;
                        case_62:
                        {
                            tmp___28 = getTexMode();
                        }
                        if (tmp___28 == 6){
                            {
                                changeTexMode(2);
                            }
                        }
                        {
                            tmp___29 = getTexMode();
                        }
                        if (tmp___29 == 2){
                            {
                                cNext = getTexChar();
                            }
                            if ((int)cNext == 62){
                                {
                                    fprintRTF((char*)"\\\'bb");
                                }
                            }else{
                                {
                                    ungetTexChar(cNext);
                                    fprintRTF((char*)">");
                                }
                            }
                        }else{
                            {
                                fprintRTF((char*)">");
                            }
                        }
                        goto switch_break;
                        case_33:
                        {
                            tmp___30 = getTexMode();
                        }
                        if (tmp___30 == 4){
                            {
                                fprintRTF((char*)"!");
                            }
                        }else{
                            {
                                tmp___31 = getTexMode();
                            }
                            if (tmp___31 == 5){
                                {
                                    fprintRTF((char*)"!");
                                }
                            }else{
                                {
                                    changeTexMode(2);
                                    cNext = getTexChar();
                                }
                                if (cNext){
                                    if ((int)cNext == 96){
                                        {
                                            fprintRTF((char*)"\\\'a1 ");
                                        }
                                    }else{
                                        {
                                            fprintRTF((char*)"! ");
                                            ungetTexChar(cNext);
                                        }
                                    }
                                }else{
                                    {
                                        fprintRTF((char*)"! ");
                                        ungetTexChar(cNext);
                                    }
                                }
                            }
                        }
                        goto switch_break;
                        case_63:
                        {
                            changeTexMode(2);
                            cNext = getTexChar();
                        }
                        if (cNext){
                            if ((int)cNext == 96){
                                {
                                    fprintRTF((char*)"\\\'bf ");
                                }
                            }else{
                                {
                                    fprintRTF((char*)"? ");
                                    ungetTexChar(cNext);
                                }
                            }
                        }else{
                            {
                                fprintRTF((char*)"? ");
                                ungetTexChar(cNext);
                            }
                        }
                        goto switch_break;
                        case_58:
                        {
                            tmp___32 = getTexMode();
                        }
                        if (tmp___32 == 4){
                            {
                                fprintRTF((char*)":");
                            }
                        }else{
                            {
                                tmp___33 = getTexMode();
                            }
                            if (tmp___33 == 5){
                                {
                                    fprintRTF((char*)":");
                                }
                            }else{
                                {
                                    changeTexMode(2);
                                }
                                if (FrenchMode){
                                    {
                                        fprintRTF((char*)"\\~:");
                                    }
                                }else{
                                    {
                                        fprintRTF((char*)":");
                                    }
                                }
                            }
                        }
                        goto switch_break;
                        case_46:
                        {
                            tmp___36 = getTexMode();
                        }
                        if (tmp___36 == 4){
                            {
                                fprintRTF((char*)".");
                            }
                        }else{
                            {
                                tmp___37 = getTexMode();
                            }
                            if (tmp___37 == 5){
                                {
                                    fprintRTF((char*)".");
                                }
                            }else{
                                {
                                    changeTexMode(2);
                                    fprintRTF((char*)".");
                                    cNext = getTexChar();
                                    ungetTexChar(cNext);
                                }
                            }
                        }
                        goto switch_break;
                        case_9:
                        {
                            diagnostics(1, (char*)"This should not happen, ignoring \\t");
                            cThis = (char)' ';
                        }
                        goto switch_break;
                        case_13:
                        {
                            diagnostics(1, (char*)"This should not happen, ignoring \\r");
                            cThis = (char)' ';
                        }
                        goto switch_break;
                        case_37:
                        {
                            diagnostics(1, (char*)"This should not happen, ignoring %%");
                            cThis = (char)' ';
                        }
                        goto switch_break;
                        case_40:
                        {
                            tmp___38 = processing_fields();
                        }
                        if (tmp___38){
                            if (g_escape_parens){
                                {
                                    fprintRTF((char*)"\\\\(");
                                }
                            }else{
                                {
                                    fprintRTF((char*)"(");
                                }
                            }
                        }else{
                            {
                                fprintRTF((char*)"(");
                            }
                        }
                        goto switch_break;
                        case_41:
                        {
                            tmp___39 = processing_fields();
                        }
                        if (tmp___39){
                            if (g_escape_parens){
                                {
                                    fprintRTF((char*)"\\\\)");
                                }
                            }else{
                                {
                                    fprintRTF((char*)")");
                                }
                            }
                        }else{
                            {
                                fprintRTF((char*)")");
                            }
                        }
                        goto switch_break;
                        case_59:
                        if ((int)g_field_separator == 59){
                            {
                                tmp___40 = processing_fields();
                            }
                            if (tmp___40){
                                {
                                    fprintRTF((char*)"\\\\;");
                                }
                            }else{
                                goto _L;
                            }
                        }else
                            _L:
                            if (FrenchMode){
                                {
                                    fprintRTF((char*)"\\~;");
                                }
                            }else{
                                {
                                    fprintRTF((char*)";");
                                }
                            }
                        goto switch_break;
                        case_44:
                        if ((int)g_field_separator == 44){
                            {
                                tmp___41 = processing_fields();
                            }
                            if (tmp___41){
                                if (g_processing_arrays){
                                    {
                                        fprintRTF((char*)";");
                                    }
                                }else{
                                    {
                                        fprintRTF((char*)"\\\\,");
                                    }
                                }
                            }else{
                                goto _L___0;
                            }
                        }else{
                            _L___0:
                            {
                                cNext = getTexChar();
                            }
                            if (cNext){
                                if ((int)cNext == 44){
                                    {
                                        fprintRTF((char*)"\\\'84");
                                    }
                                }else{
                                    {
                                        fprintRTF((char*)",");
                                        ungetTexChar(cNext);
                                    }
                                }
                            }else{
                                {
                                    fprintRTF((char*)",");
                                    ungetTexChar(cNext);
                                }
                            }
                        }
                        goto switch_break;
                        switch_default:
                        {
                            tmp___46 = getTexMode();
                        }
                        if (tmp___46 == 4){
                            goto _L___3;
                        }else{
                            {
                                tmp___47 = getTexMode();
                            }
                            if (tmp___47 == 5){
                                _L___3:
                                if (97 <= (int)cThis){
                                    if ((int)cThis <= 122){
                                        goto _L___1;
                                    }else{
                                        goto _L___2;
                                    }
                                }else
                                    _L___2:
                                    if (65 <= (int)cThis){
                                        if ((int)cThis <= 90){
                                            _L___1:
                                            {
                                                tmp___43 = CurrentFontSeries();
                                            }
                                            if (tmp___43 == 5){
                                                {
                                                    fprintRTF((char*)"%c", (int)cThis);
                                                }
                                            }else{
                                                {
                                                    tmp___42 = CurrentFontShape();
                                                }
                                                if (tmp___42 == 17){
                                                    {
                                                        fprintRTF((char*)"%c", (int)cThis);
                                                    }
                                                }else{
                                                    {
                                                        fprintRTF((char*)"{\\i %c}", (int)cThis);
                                                    }
                                                }
                                            }
                                        }else{
                                            {
                                                fprintRTF((char*)"%c", (int)cThis);
                                            }
                                        }
                                    }else{
                                        {
                                            fprintRTF((char*)"%c", (int)cThis);
                                        }
                                    }
                            }else{
                                {
                                    tmp___44 = getTexMode();
                                }
                                if (tmp___44 == 6){
                                    {
                                        changeTexMode(2);
                                    }
                                }
                                {
                                    tmp___45 = CurrentFontEncoding();
                                }
                                if (tmp___45 != 27){
                                    {
                                        fprintRTF((char*)"%c", (int)cThis);
                                    }
                                }else{
                                    {
                                        CmdOT2Transliteration((int)cThis);
                                    }
                                }
                            }
                        }
                        goto switch_break;
                        switch_break:
                        ;
                    }
                }
                g_tab_counter++;
                cLast = cThis;
            }
            while_break:
            ;
        }
        {
            RecursionLevel--;
            diagnostics(3, (char*)"Exiting Convert via exhaustion ret = %d", ret);
        }
        return;
    }
}

static void TranslateCommand(void)
{
    char cCommand[100];
    int i;
    int mode;
    int height;
    int cThis;
    int cNext;
    char tmp;
    char tmp___0;
    char tmp___1;
    char tmp___2;
    int found_nl;
    char tmp___3;
    char tmp___4;
    const unsigned short **tmp___5;
    char tmp___6;
    int tmp___7;
    int tmp___8;
    int tmp___9;
    int tmp___10;
    int tmp___11;
    int tmp___12;
    int tmp___13;
    {
        {
            tmp = getTexChar();
            cThis = (int)tmp;
            mode = getTexMode();
            diagnostics(4, (char*)"Beginning TranslateCommand() \\%c", cThis);
        }
        {
            if (cThis == 97){
                goto case_97;
            }
            if (cThis == 125){
                goto case_125;
            }
            if (cThis == 123){
                goto case_123;
            }
            if (cThis == 35){
                goto case_35;
            }
            if (cThis == 36){
                goto case_36;
            }
            if (cThis == 38){
                goto case_38;
            }
            if (cThis == 37){
                goto case_37;
            }
            if (cThis == 95){
                goto case_95;
            }
            if (cThis == 92){
                goto case_92;
            }
            if (cThis == 13){
                goto case_13;
            }
            if (cThis == 10){
                goto case_10;
            }
            if (cThis == 32){
                goto case_10;
            }
            if (cThis == 9){
                goto case_10;
            }
            if (cThis == 45){
                goto case_45;
            }
            if (cThis == 43){
                goto case_43;
            }
            if (cThis == 60){
                goto case_60;
            }
            if (cThis == 62){
                goto case_62;
            }
            if (cThis == 96){
                goto case_96;
            }
            if (cThis == 39){
                goto case_39;
            }
            if (cThis == 61){
                goto case_61;
            }
            if (cThis == 126){
                goto case_126;
            }
            if (cThis == 94){
                goto case_94;
            }
            if (cThis == 46){
                goto case_46;
            }
            if (cThis == 34){
                goto case_34;
            }
            if (cThis == 40){
                goto case_40;
            }
            if (cThis == 91){
                goto case_91;
            }
            if (cThis == 41){
                goto case_41;
            }
            if (cThis == 93){
                goto case_93;
            }
            if (cThis == 47){
                goto case_47;
            }
            if (cThis == 33){
                goto case_33;
            }
            if (cThis == 44){
                goto case_44;
            }
            if (cThis == 59){
                goto case_59;
            }
            if (cThis == 64){
                goto case_64;
            }
            if (cThis == 51){
                goto case_51;
            }
            goto switch_break;
            case_97:
            if (!g_processing_tabbing){
                goto switch_break;
            }
            {
                tmp___0 = getTexChar();
                cNext = (int)tmp___0;
            }
            if (cNext == 61){
                {
                    CmdMacronChar(0);
                }
                return;
            }
            if (cNext == 39){
                {
                    CmdAcuteChar(0);
                }
                return;
            }
            if (cNext == 96){
                {
                    CmdAcuteChar(0);
                }
                return;
            }
            {
                ungetTexChar((char)cNext);
            }
            goto switch_break;
            case_125:
            if (mode == 6){
                {
                    changeTexMode(2);
                }
            }
            {
                fprintRTF((char*)"\\}");
            }
            return;
            case_123:
            if (mode == 6){
                {
                    changeTexMode(2);
                }
            }
            {
                fprintRTF((char*)"\\{");
            }
            return;
            case_35:
            if (mode == 6){
                {
                    changeTexMode(2);
                }
            }
            {
                fprintRTF((char*)"#");
            }
            return;
            case_36:
            if (mode == 6){
                {
                    changeTexMode(2);
                }
            }
            {
                fprintRTF((char*)"$");
            }
            return;
            case_38:
            if (mode == 6){
                {
                    changeTexMode(2);
                }
            }
            {
                fprintRTF((char*)"&");
            }
            return;
            case_37:
            if (mode == 6){
                {
                    changeTexMode(2);
                }
            }
            {
                fprintRTF((char*)"%%");
            }
            return;
            case_95:
            if (mode == 6){
                {
                    changeTexMode(2);
                }
            }
            {
                fprintRTF((char*)"_");
            }
            return;
            case_92:
            {
                diagnostics(5, (char*)"here we are in TranslateCommand with \'\\\\\'");
                height = getSlashSlashParam();
            }
            if (g_processing_arrays){
                {
                    CmdArraySlashSlash(height);
                }
            }else
                if (g_processing_eqnarray){
                    {
                        CmdEqnArraySlashSlash(height);
                    }
                }else
                    if (g_processing_tabbing){
                        {
                            diagnostics(1, (char*)"should not be processing \\\\ in tabbing here");
                        }
                    }else
                        if (g_processing_tabular){
                            {
                                diagnostics(1, (char*)"should not be processing \\\\ in tabular here");
                            }
                        }else{
                            {
                                CmdSlashSlash(height);
                            }
                        }

            return;
            case_13:
            {
                tmp___1 = getTexChar();
                cNext = (int)tmp___1;
            }
            if (cNext != 10){
                {
                    ungetTexChar((char)cNext);
                }
            }
            case_10:
            case_32:
            case_9:
            if (mode == 6){
                {
                    changeTexMode(2);
                }
            }
            {
                fprintRTF((char*)" ");
                skipSpaces();
            }
            return;
            case_45:
            if (mode == 6){
                {
                    changeTexMode(2);
                }
            }
            if (g_processing_tabbing){
                {
                    PopBrace();
                    PushBrace();
                }
            }else{
                {
                    fprintRTF((char*)"\\-");
                }
            }
            return;
            case_43:
            if (mode == 6){
                {
                    changeTexMode(2);
                }
            }
            if (g_processing_tabbing){
                {
                    PopBrace();
                    PushBrace();
                }
            }
            return;
            case_60:
            if (mode == 6){
                {
                    changeTexMode(2);
                }
            }
            if (g_processing_tabbing){
                {
                    PopBrace();
                    PushBrace();
                }
            }
            return;
            case_62:
            if (mode == 6){
                {
                    changeTexMode(2);
                }
            }
            if (g_processing_tabbing){
                {
                    PopBrace();
                    CmdTabjump();
                    PushBrace();
                }
            }else{
                {
                    CmdSpace((float)0.50);
                }
            }
            return;
            case_96:
            if (mode == 6){
                {
                    changeTexMode(2);
                }
            }
            if (g_processing_tabbing){
                {
                    PopBrace();
                    PushBrace();
                }
            }else{
                {
                    CmdGraveChar(0);
                }
            }
            return;
            case_39:
            if (mode == 6){
                {
                    changeTexMode(2);
                }
            }
            if (g_processing_tabbing){
                {
                    PopBrace();
                    PushBrace();
                }
                return;
            }else{
                {
                    CmdAcuteChar(0);
                }
            }
            return;
            case_61:
            if (mode == 6){
                {
                    changeTexMode(2);
                }
            }
            if (g_processing_tabbing){
                {
                    PopBrace();
                    CmdTabset();
                    PushBrace();
                }
            }else{
                {
                    CmdMacronChar(0);
                }
            }
            return;
            case_126:
            if (mode == 6){
                {
                    changeTexMode(2);
                }
            }
            {
                CmdTildeChar(0);
            }
            return;
            case_94:
            if (mode == 6){
                {
                    changeTexMode(2);
                }
            }
            {
                tmp___2 = getTexChar();
                cThis = (int)tmp___2;
            }
            if (cThis == 94){
                {
                    getTexChar();
                    fprintRTF((char*)" ");
                }
            }else{
                {
                    ungetTexChar((char)cThis);
                    CmdHatChar(0);
                }
            }
            return;
            case_46:
            if (mode == 6){
                {
                    changeTexMode(2);
                }
            }
            {
                CmdDotChar(0);
            }
            return;
            case_34:
            if (mode == 6){
                {
                    changeTexMode(2);
                }
            }
            {
                CmdUmlauteChar(0);
            }
            return;
            case_40:
            {
                CmdEquation(16387);
            }
            return;
            case_91:
            {
                CmdEquation(16388);
            }
            return;
            case_41:
            {
                CmdEquation(5);
            }
            return;
            case_93:
            {
                CmdEquation(6);
            }
            return;
            case_47:
            {
                CmdIgnore(0);
            }
            return;
            case_33:
            {
                CmdIgnore(0);
            }
            return;
            case_44:
            if (mode == 6){
                {
                    changeTexMode(2);
                }
            }
            {
                CmdNonBreakSpace(50);
            }
            return;
            case_59:
            if (mode == 6){
                {
                    changeTexMode(2);
                }
            }
            {
                CmdSpace((float)0.75);
            }
            return;
            case_64:
            {
                CmdIgnore(0);
            }
            return;
            case_51:
            if (mode == 6){
                {
                    changeTexMode(2);
                }
            }
            {
                fprintRTF((char*)"{\\\'df}");
            }
            return;
            switch_break:
            ;
        }
        i = 0;
        {
            while (1){
                while_continue:
                ;
                if (!(i < 99)){
                    goto while_break;
                }
                {
                    tmp___5 = __ctype_b_loc();
                }
                if ((const int)*(*tmp___5 + cThis) & 1024){
                    cCommand[i] = (char)cThis;
                }else
                    if (cThis != 42){
                        found_nl = 0;
                        if (cThis == 37){
                            {
                                ungetTexChar((char)'%');
                                tmp___3 = getTexChar();
                                cThis = (int)tmp___3;
                            }
                        }
                        {
                            while (1){
                                while_continue___0:
                                ;
                                if (!(cThis == 32)){
                                    if (cThis == 10){
                                        if (!(!found_nl)){
                                            goto while_break___0;
                                        }
                                    }else{
                                        goto while_break___0;
                                    }
                                }
                                if (cThis == 10){
                                    found_nl = 1;
                                }
                                {
                                    tmp___4 = getTexChar();
                                    cThis = (int)tmp___4;
                                }
                            }
                            while_break___0:
                            ;
                        }
                        {
                            ungetTexChar((char)cThis);
                        }
                        goto while_break;
                    }else{
                        cCommand[i] = (char)cThis;
                    }

                {
                    tmp___6 = getRawTexChar();
                    cThis = (int)tmp___6;
                    i++;
                }
            }
            while_break:
            ;
        }
        {
            cCommand[i] = (char)'\000';
            diagnostics(4, (char*)"TranslateCommand() <%s>", cCommand);
        }
        if (i == 99){
            {
                diagnostics(1, (char*)"Skipping absurdly long command <%s>", cCommand);
            }
            return;
        }
        if (i == 0){
            return;
        }
        {
            tmp___7 = strcmp((const char*)(cCommand), "begin");
        }
        if (tmp___7 == 0){
            {
                fprintRTF((char*)"{");
                PushBrace();
            }
        }
        {
            tmp___10 = CallCommandFunc(cCommand);
        }
        if (tmp___10){
            {
                tmp___9 = strcmp((const char*)(cCommand), "end");
            }
            if (tmp___9 == 0){
                {
                    diagnostics(4, (char*)"before PopBrace()");
                    tmp___8 = PopBrace();
                    ret = RecursionLevel - tmp___8;
                    diagnostics(4, (char*)"after PopBrace(), ret=%d", ret);
                    fprintRTF((char*)"}");
                }
            }
            return;
        }
        {
            tmp___11 = TryDirectConvert(cCommand);
        }
        if (tmp___11){
            return;
        }
        {
            tmp___12 = TryVariableIgnore((const char*)(cCommand));
        }
        if (tmp___12){
            return;
        }
        {
            tmp___13 = TryConditionSet(cCommand);
        }
        if (tmp___13){
            return;
        }
        {
            diagnostics(1, (char*)"Unknown command \'\\%s\'", cCommand);
        }
        return;
    }
}

extern char* (strncpy)(char*restrict  __dest, const char*restrict  __src, size_t __n);
int g_show_equation_number;
int g_suppress_equation_number;
int g_amsmath_package;
int g_equation_inline_rtf;
int g_equation_display_rtf;
int g_equation_inline_bitmap;
int g_equation_display_bitmap;
int g_equation_comment;
int g_equation_raw_latex;
void putRtfCharEscaped(char cThis);
char* getLeftRightParam(void);
char* getSimpleCommand(void);
void CmdFraction(int code);
void CmdRoot(int code);
void CmdLim(int code);
void CmdIntegral(int code);
void CmdNonumber(int code);
void CmdArray(int code);
void CmdLeftRight(int code);
void CmdMatrix(int code);
void CmdStackrel(int code);
void CmdArrows(int code);
void CmdEnsuremath(int code);
void CmdOverLine(int code);
void CmdBox(int code);
char* getStringBraceParam(char** s);
void str_delete(char* s, const char* target);
int g_equation_column = 1;
int g_amsmath_package = 0;
int g_multiline_equation_type = 0;
int g_current_eqn_needs_EQ = 0;

int script_shift(void)
{
    int tmp;
    {
        {
            tmp = CurrentFontSize();
        }
        return ((int)((double)tmp / 3.0));
    }
}

int script_size(void)
{
    int tmp;
    {
        {
            tmp = CurrentFontSize();
        }
        return ((int)((double)tmp / 1.2));
    }
}

void CmdNonumber(int code)
{
    {
        if (g_processing_eqnarray){
            g_suppress_equation_number = 1;
        }else
            if (!g_processing_tabular){
                g_suppress_equation_number = 1;
            }

        return;
    }
}

static char* SlurpDollarEquation(void)
{
    int brace;
    int slash;
    int i;
    char* s;
    char* t;
    char* u;
    void* tmp;
    int tmp___0;
    int tmp___1;
    int tmp___2;
    int tmp___3;
    int tmp___4;
    int tmp___5;
    int tmp___6;
    {
        {
            brace = 0;
            slash = 0;
            tmp = malloc(1024UL * sizeof (char));
            s = (char*)tmp;
            t = s;
            i = 0;
        }
        {
            while (1){
                while_continue:
                ;
                if (!(i < 1024)){
                    goto while_break;
                }
                {
                    *t = getTexChar();
                }
                if ((int)*t == 92){
                    slash++;
                }else
                    if ((int)*t == 123){
                        {
                            tmp___4 = even((long )slash);
                        }
                        if (tmp___4){
                            if (i > 5){
                                {
                                    tmp___5 = strncmp((const char*)(t - 5), "\\left{", (size_t)6);
                                }
                                if (tmp___5 == 0){
                                    goto _L___6;
                                }else{
                                    goto _L___5;
                                }
                            }else
                                _L___5:
                                if (i > 6){
                                    {
                                        tmp___6 = strncmp((const char*)(t - 6), "\\right{", (size_t)7);
                                    }
                                    if (tmp___6 == 0){
                                        goto _L___6;
                                    }else{
                                        brace++;
                                    }
                                }else{
                                    brace++;
                                }
                        }else{
                            goto _L___6;
                        }
                    }else
                        _L___6:
                        if ((int)*t == 125){
                            {
                                tmp___1 = even((long )slash);
                            }
                            if (tmp___1){
                                if (i > 5){
                                    {
                                        tmp___2 = strncmp((const char*)(t - 5), "\\left}", (size_t)6);
                                    }
                                    if (tmp___2){
                                        goto _L___1;
                                    }else{
                                        goto _L___2;
                                    }
                                }else
                                    _L___1:
                                    if (i > 6){
                                        {
                                            tmp___3 = strncmp((const char*)(t - 6), "\\right}", (size_t)7);
                                        }
                                        if (tmp___3){
                                            brace--;
                                        }else{
                                            goto _L___2;
                                        }
                                    }else{
                                        brace--;
                                    }
                            }else{
                                goto _L___2;
                            }
                        }else
                            _L___2:
                            if ((int)*t == 36){
                                {
                                    tmp___0 = even((long )slash);
                                }
                                if (tmp___0){
                                    if (brace == 0){
                                        goto while_break;
                                    }else{
                                        slash = 0;
                                    }
                                }else{
                                    slash = 0;
                                }
                            }else{
                                slash = 0;
                            }

                t++;
                i++;
            }
            while_break:
            ;
        }
        {
            *t = (char)'\000';
            u = strdup((const char*)s);
            free((void*)s);
        }
        return (u);
    }
}

static void SlurpEquation(int code, char** pre, char** eq, char** post)
{
    int true_code;
    {
        true_code = code & -16385;
        {
            if (true_code == 12){
                goto case_12;
            }
            if (true_code == 2){
                goto case_2;
            }
            if (true_code == 3){
                goto case_3;
            }
            if (true_code == 13){
                goto case_13;
            }
            if (true_code == 11){
                goto case_11;
            }
            if (true_code == 14){
                goto case_14;
            }
            if (true_code == 4){
                goto case_4;
            }
            if (true_code == 10){
                goto case_10;
            }
            if (true_code == 9){
                goto case_9;
            }
            if (true_code == 8){
                goto case_8;
            }
            if (true_code == 18){
                goto case_18;
            }
            if (true_code == 17){
                goto case_17;
            }
            goto switch_break;
            case_12:
            {
                diagnostics(4, (char*)"SlurpEquation() --- \\begin{math}");
                *pre = strdup("\\begin{math}");
                *post = strdup("\\end{math}");
                *eq = getTexUntil(*post, 0);
            }
            goto switch_break;
            case_2:
            {
                diagnostics(4, (char*)"SlurpEquation() --- $");
                *pre = strdup("$");
                *post = strdup("$");
                *eq = SlurpDollarEquation();
            }
            goto switch_break;
            case_3:
            {
                diagnostics(4, (char*)"SlurpEquation() --- \\(");
                *pre = strdup("\\(");
                *post = strdup("\\)");
                *eq = getTexUntil(*post, 0);
            }
            goto switch_break;
            case_13:
            {
                diagnostics(4, (char*)"SlurpEquation --- displaymath");
                *pre = strdup("\\begin{displaymath}");
                *post = strdup("\\end{displaymath}");
                *eq = getTexUntil(*post, 0);
            }
            goto switch_break;
            case_11:
            {
                diagnostics(4, (char*)"SlurpEquation() --- equation*");
                *pre = strdup("\\begin{equation*}");
                *post = strdup("\\end{equation*}");
                *eq = getTexUntil(*post, 0);
            }
            goto switch_break;
            case_14:
            {
                diagnostics(4, (char*)"SlurpEquation() --- $$");
                *pre = strdup("$$");
                *post = strdup("$$");
                *eq = getTexUntil(*post, 0);
            }
            goto switch_break;
            case_4:
            {
                diagnostics(4, (char*)"SlurpEquation() --- \\[");
                *pre = strdup("\\[");
                *post = strdup("\\]");
                *eq = getTexUntil(*post, 0);
            }
            goto switch_break;
            case_10:
            {
                diagnostics(4, (char*)"SlurpEquation() --- equation");
                *pre = strdup("\\begin{equation}");
                *post = strdup("\\end{equation}");
                *eq = getTexUntil(*post, 0);
            }
            goto switch_break;
            case_9:
            {
                diagnostics(4, (char*)"SlurpEquation() --- eqnarray* ");
                *pre = strdup("\\begin{eqnarray*}");
                *post = strdup("\\end{eqnarray*}");
                *eq = getTexUntil(*post, 0);
            }
            goto switch_break;
            case_8:
            {
                diagnostics(4, (char*)"SlurpEquation() --- eqnarray");
                *pre = strdup("\\begin{eqnarray}");
                *post = strdup("\\end{eqnarray}");
                *eq = getTexUntil(*post, 0);
            }
            goto switch_break;
            case_18:
            {
                diagnostics(4, (char*)"SlurpEquation() --- align* ");
                *pre = strdup("\\begin{align*}");
                *post = strdup("\\end{align*}");
                *eq = getTexUntil(*post, 0);
            }
            goto switch_break;
            case_17:
            {
                diagnostics(4, (char*)"SlurpEquation() --- align");
                *pre = strdup("\\begin{align}");
                *post = strdup("\\end{align}");
                *eq = getTexUntil(*post, 0);
            }
            goto switch_break;
            switch_break:
            ;
        }
        return;
    }
}

static int EquationNeedsFields(char* eq)
{
    int tmp;
    char* tmp___0;
    char* tmp___1;
    char* tmp___2;
    char* tmp___3;
    char* tmp___4;
    char* tmp___5;
    char* tmp___6;
    char* tmp___7;
    char* tmp___8;
    char* tmp___9;
    char* tmp___10;
    char* tmp___11;
    char* tmp___12;
    char* tmp___13;
    char* tmp___14;
    char* tmp___15;
    char* tmp___16;
    char* tmp___17;
    char* tmp___18;
    char* tmp___19;
    {
        {
            tmp = EQ_field_active();
        }
        if (tmp){
            return (0);
        }
        {
            tmp___0 = strstr((const char*)eq, "\\frac");
        }
        if (tmp___0){
            return (1);
        }
        {
            tmp___1 = strstr((const char*)eq, "\\sum");
        }
        if (tmp___1){
            return (1);
        }
        {
            tmp___2 = strstr((const char*)eq, "\\int");
        }
        if (tmp___2){
            return (1);
        }
        {
            tmp___3 = strstr((const char*)eq, "\\iint");
        }
        if (tmp___3){
            return (1);
        }
        {
            tmp___4 = strstr((const char*)eq, "\\iiint");
        }
        if (tmp___4){
            return (1);
        }
        {
            tmp___5 = strstr((const char*)eq, "\\prod");
        }
        if (tmp___5){
            return (1);
        }
        {
            tmp___6 = strstr((const char*)eq, "\\begin{array}");
        }
        if (tmp___6){
            return (1);
        }
        {
            tmp___7 = strstr((const char*)eq, "\\left");
        }
        if (tmp___7){
            return (1);
        }
        {
            tmp___8 = strstr((const char*)eq, "\\right");
        }
        if (tmp___8){
            return (1);
        }
        {
            tmp___9 = strstr((const char*)eq, "\\root");
        }
        if (tmp___9){
            return (1);
        }
        {
            tmp___10 = strstr((const char*)eq, "\\sqrt");
        }
        if (tmp___10){
            return (1);
        }
        {
            tmp___11 = strstr((const char*)eq, "\\over");
        }
        if (tmp___11){
            return (1);
        }
        {
            tmp___12 = strstr((const char*)eq, "\\stackrel");
        }
        if (tmp___12){
            return (1);
        }
        {
            tmp___13 = strstr((const char*)eq, "_");
        }
        if (tmp___13){
            return (1);
        }else{
            {
                tmp___14 = strstr((const char*)eq, "^");
            }
            if (tmp___14){
                return (1);
            }
        }
        {
            tmp___15 = strstr((const char*)eq, "\\dfrac");
        }
        if (tmp___15){
            return (1);
        }
        {
            tmp___16 = strstr((const char*)eq, "\\lim");
        }
        if (tmp___16){
            return (1);
        }
        {
            tmp___17 = strstr((const char*)eq, "\\liminf");
        }
        if (tmp___17){
            return (1);
        }
        {
            tmp___18 = strstr((const char*)eq, "\\limsup");
        }
        if (tmp___18){
            return (1);
        }
        {
            tmp___19 = strstr((const char*)eq, "\\overline");
        }
        if (tmp___19){
            return (1);
        }
        return (0);
    }
}

static void WriteEquationAsComment(char* pre, char* eq, char* post)
{
    {
        {
            diagnostics(3, (char*)"WriteEquationAsComment");
            startField(6);
            putRtfStrEscaped((const char*)pre);
            putRtfStrEscaped((const char*)eq);
            putRtfStrEscaped((const char*)post);
            endCurrentField();
        }
        return;
    }
}

static void PrepareRtfEquation(int code, int EQ_Needed)
{
    int tmp;
    int tmp___0;
    int tmp___1;
    int tmp___2;
    int tmp___3;
    {
        {
            g_current_eqn_needs_EQ = EQ_Needed;
            diagnostics(4, (char*)"PrepareRtfEquation ...");
        }
        {
            if (code == 12){
                goto case_12;
            }
            if (code == 2){
                goto case_2;
            }
            if (code == 16){
                goto case_16;
            }
            if (code == 3){
                goto case_3;
            }
            if (code == 11){
                goto case_11;
            }
            if (code == 13){
                goto case_11;
            }
            if (code == 4){
                goto case_11;
            }
            if (code == 14){
                goto case_11;
            }
            if (code == 10){
                goto case_10;
            }
            if (code == 9){
                goto case_9;
            }
            if (code == 18){
                goto case_9;
            }
            if (code == 8){
                goto case_8;
            }
            if (code == 17){
                goto case_8;
            }
            goto switch_default;
            case_12:
            {
                diagnostics(4, (char*)"PrepareRtfEquation ... \\begin{math}");
                tmp = getTexMode();
            }
            if (tmp == 6){
                {
                    startParagraph("Normal", 2);
                }
            }
            {
                setTexMode(4);
            }
            goto switch_break;
            case_2:
            {
                diagnostics(4, (char*)"PrepareRtfEquation ... $");
                tmp___0 = getTexMode();
            }
            if (tmp___0 == 6){
                {
                    startParagraph("Normal", 2);
                }
            }
            {
                fprintRTF((char*)"{");
                setTexMode(4);
            }
            goto switch_break;
            case_16:
            {
                diagnostics(4, (char*)"PrepareRtfEquation ... \\ensuremath{}");
                tmp___1 = getTexMode();
            }
            if (tmp___1 == 6){
                {
                    startParagraph("Normal", 2);
                }
            }
            {
                fprintRTF((char*)"{");
                setTexMode(4);
            }
            goto switch_break;
            case_3:
            {
                diagnostics(4, (char*)"PrepareRtfEquation ... \\(");
                tmp___2 = getTexMode();
            }
            if (tmp___2 == 6){
                {
                    startParagraph("Normal", 2);
                }
            }
            {
                fprintRTF((char*)"{");
                setTexMode(4);
            }
            goto switch_break;
            case_11:
            case_13:
            case_4:
            case_14:
            if (code == 13){
                {
                    diagnostics(4, (char*)"PrepareRtfEquation -- $$");
                }
            }
            if (code == 13){
                {
                    diagnostics(4, (char*)"PrepareRtfEquation -- displaymath");
                }
            }
            if (code == 4){
                {
                    diagnostics(4, (char*)"PrepareRtfEquation -- \\[");
                }
            }
            if (code == 11){
                {
                    diagnostics(4, (char*)"PrepareRtfEquation -- equation*");
                }
            }
            {
                g_show_equation_number = 0;
                startParagraph("equation", 4);
                fprintRTF((char*)"\\tab\n");
                setTexMode(5);
            }
            goto switch_break;
            case_10:
            {
                diagnostics(4, (char*)"PrepareRtfEquation -- equation");
                g_equation_column = 5;
                g_show_equation_number = 1;
                g_suppress_equation_number = 0;
                startParagraph("equationNum", 4);
                fprintRTF((char*)"\\tab\n");
                setTexMode(5);
            }
            goto switch_break;
            case_9:
            case_18:
            if (code == 9){
                {
                    diagnostics(4, (char*)"PrepareRtfEquation -- eqnarray* ");
                }
            }
            if (code == 18){
                {
                    diagnostics(4, (char*)"PrepareRtfEquation -- align* ");
                }
            }
            g_show_equation_number = 0;
            g_processing_eqnarray = 1;
            g_processing_tabular = 1;
            g_equation_column = 1;
            g_multiline_equation_type = code;
            if (g_equation_display_bitmap){
                {
                    startParagraph("bitmapCenter", 4);
                }
            }else
                if (code == 18){
                    {
                        startParagraph("equationAlign", 4);
                    }
                }else{
                    {
                        startParagraph("equationArray", 4);
                    }
                }

            {
                fprintRTF((char*)"\\tab\n");
                setTexMode(5);
            }
            goto switch_break;
            case_8:
            case_17:
            if (code == 17){
                {
                    diagnostics(4, (char*)"PrepareRtfEquation --- eqnarray");
                }
            }
            if (code == 8){
                {
                    diagnostics(4, (char*)"PrepareRtfEquation --- align");
                }
            }
            g_show_equation_number = 1;
            g_processing_eqnarray = 1;
            g_processing_tabular = 1;
            g_equation_column = 1;
            g_multiline_equation_type = code;
            if (g_equation_display_bitmap){
                {
                    startParagraph("bitmapCenter", 4);
                }
            }else
                if (code == 17){
                    {
                        startParagraph("equationAlignNum", 4);
                    }
                }else{
                    {
                        startParagraph("equationArrayNum", 4);
                    }
                }

            {
                fprintRTF((char*)"\\tab\n");
                setTexMode(5);
            }
            goto switch_break;
            switch_default:
            {
                diagnostics(0, (char*)"calling PrepareRtfEquation with OFF code");
            }
            goto switch_break;
            switch_break:
            ;
        }
        if (g_current_eqn_needs_EQ){
            {
                tmp___3 = processing_fields();
            }
            if (!tmp___3){
                {
                    startField(1);
                }
            }
        }
        return;
    }
}

static char* CreateEquationLabel(void)
{
    char* number;
    void* tmp;
    int tmp___0;
    int tmp___1;
    int tmp___2;
    {
        {
            tmp = malloc((size_t)30);
            number = (char*)tmp;
        }
        if (g_document_type == 2){
            {
                tmp___0 = getCounter((char*)"equation");
                tmp___1 = getCounter((char*)"chapter");
                snprintf((char*)number, (size_t)29, (const char*)"%d.%d", tmp___1, tmp___0);
            }
        }else
            if (g_document_type == 3){
                {
                    tmp___0 = getCounter((char*)"equation");
                    tmp___1 = getCounter((char*)"chapter");
                    snprintf((char*)number, (size_t)29, (const char*)"%d.%d", tmp___1, tmp___0);
                }
            }else{
                {
                    tmp___2 = getCounter((char*)"equation");
                    snprintf((char*)number, (size_t)29, (const char*)"%d", tmp___2);
                }
            }

        return (number);
    }
}

static void FinishRtfEquation(int code, int EQ_Needed)
{
    char* number;
    {
        {
            diagnostics(4, (char*)"FinishRtfEquation ...");
        }
        if (EQ_Needed){
            {
                endCurrentField();
                g_current_eqn_needs_EQ = 0;
            }
        }
        {
            if (code == 12){
                goto case_12;
            }
            if (code == 2){
                goto case_2;
            }
            if (code == 16){
                goto case_16;
            }
            if (code == 3){
                goto case_3;
            }
            if (code == 14){
                goto case_14;
            }
            if (code == 13){
                goto case_13;
            }
            if (code == 4){
                goto case_13;
            }
            if (code == 11){
                goto case_11;
            }
            if (code == 9){
                goto case_9;
            }
            if (code == 18){
                goto case_18;
            }
            if (code == 17){
                goto case_17;
            }
            if (code == 8){
                goto case_17;
            }
            if (code == 10){
                goto case_17;
            }
            goto switch_default;
            case_12:
            {
                diagnostics(4, (char*)"FinishRtfEquation -- \\end{math}");
                CmdIndent(2);
                setTexMode(2);
            }
            goto switch_break;
            case_2:
            {
                diagnostics(4, (char*)"FinishRtfEquation -- $");
                fprintRTF((char*)"}");
                setTexMode(2);
            }
            goto switch_break;
            case_16:
            {
                diagnostics(4, (char*)"FinishRtfEquation -- \\ensuremath{}");
                fprintRTF((char*)"}");
                setTexMode(2);
            }
            goto switch_break;
            case_3:
            {
                diagnostics(4, (char*)"FinishRtfEquation -- \\)");
                fprintRTF((char*)"}");
                setTexMode(2);
            }
            goto switch_break;
            case_14:
            {
                diagnostics(4, (char*)"FinishRtfEquation -- $$");
                CmdEndParagraph(0);
                CmdIndent(2);
            }
            goto switch_break;
            case_13:
            case_4:
            if (code == 13){
                {
                    diagnostics(4, (char*)"FinishRtfEquation -- displaymath");
                }
            }else{
                {
                    diagnostics(4, (char*)"FinishRtfEquation -- \\]");
                }
            }
            {
                CmdEndParagraph(0);
                CmdIndent(2);
            }
            goto switch_break;
            case_11:
            {
                diagnostics(4, (char*)"FinishRtfEquation -- equation*");
                CmdEndParagraph(0);
                CmdIndent(2);
            }
            goto switch_break;
            case_9:
            {
                diagnostics(4, (char*)"FinishRtfEquation -- eqnarray* ");
                CmdEndParagraph(0);
                CmdIndent(2);
                g_processing_eqnarray = 0;
                g_processing_tabular = 0;
                g_multiline_equation_type = 0;
            }
            goto switch_break;
            case_18:
            {
                diagnostics(4, (char*)"FinishRtfEquation -- align* ");
                CmdEndParagraph(0);
                CmdIndent(2);
                g_processing_eqnarray = 0;
                g_processing_tabular = 0;
                g_multiline_equation_type = 0;
            }
            goto switch_break;
            case_17:
            case_8:
            case_10:
            {
                diagnostics(4, (char*)"FinishRtfEquation --- equation or eqnarray or align");
            }
            if (g_show_equation_number){
                if (!g_suppress_equation_number){
                    {
                        incrementCounter((char*)"equation");
                    }
                    if (!g_equation_display_bitmap){
                        {
                            while (1){
                                while_continue:
                                ;
                                if (!(g_equation_column < 3)){
                                    goto while_break;
                                }
                                {
                                    fprintRTF((char*)"\\tab\n");
                                    g_equation_column++;
                                }
                            }
                            while_break:
                            ;
                        }
                    }
                    {
                        fprintRTF((char*)"\\tab{\\b0 (");
                        number = CreateEquationLabel();
                        InsertBookmark(g_equation_label, number);
                        free((void*)number);
                    }
                    if (g_equation_label){
                        {
                            free((void*)g_equation_label);
                            g_equation_label = (char*)((void*)0);
                        }
                    }
                    {
                        fprintRTF((char*)")}");
                    }
                }
            }
            {
                g_multiline_equation_type = 0;
                g_processing_eqnarray = 0;
                g_processing_tabular = 0;
                CmdEndParagraph(0);
                CmdIndent(2);
            }
            goto switch_break;
            switch_default:
            {
                diagnostics(0, (char*)"calling FinishRtfEquation with OFF code");
            }
            goto switch_break;
            switch_break:
            ;
        }
        return;
    }
}

static char* scanback(char* s, char* t)
{
    int braces;
    int tmp;
    int tmp___0;
    int tmp___1;
    int tmp___2;
    {
        braces = 1;
        if (!s){
            return ((char*)((void*)0));
        }else
            if (!t){
                return ((char*)((void*)0));
            }else
                if ((unsigned long )t < (unsigned long )s){
                    return ((char*)((void*)0));
                }

        {
            while (1){
                while_continue:
                ;
                if (braces){
                    if (!((unsigned long )s < (unsigned long )t)){
                        goto while_break;
                    }
                }else{
                    goto while_break;
                }
                if ((int)*t == 123){
                    if (!((int)*(t - 1) == 92)){
                        if ((unsigned long )(s + 5) <= (unsigned long )t){
                            {
                                tmp = strncmp((const char*)(t - 5), "\\left", (size_t)5);
                            }
                            if (tmp){
                                goto _L;
                            }
                        }else
                            _L:
                            if ((unsigned long )(s + 6) <= (unsigned long )t){
                                {
                                    tmp___0 = strncmp((const char*)(t - 6), "\\right", (size_t)6);
                                }
                                if (tmp___0){
                                    braces--;
                                }
                            }else{
                                braces--;
                            }
                    }
                }
                if ((int)*t == 125){
                    if (!((int)*(t - 1) == 92)){
                        if ((unsigned long )(s + 5) <= (unsigned long )t){
                            {
                                tmp___1 = strncmp((const char*)(t - 5), "\\left", (size_t)5);
                            }
                            if (tmp___1){
                                goto _L___0;
                            }
                        }else
                            _L___0:
                            if ((unsigned long )(s + 6) <= (unsigned long )t){
                                {
                                    tmp___2 = strncmp((const char*)(t - 6), "\\right", (size_t)6);
                                }
                                if (tmp___2){
                                    braces++;
                                }
                            }else{
                                braces++;
                            }
                    }
                }
                if (braces){
                    t--;
                }
            }
            while_break:
            ;
        }
        return (t);
    }
}

static char* scanahead(char* s)
{
    char* t;
    int braces;
    int slashes;
    int tmp;
    int tmp___0;
    int tmp___1;
    int tmp___2;
    int tmp___3;
    {
        braces = 1;
        slashes = 0;
        if (!s){
            return ((char*)((void*)0));
        }
        t = s;
        {
            while (1){
                while_continue:
                ;
                if (braces){
                    if (t){
                        if (!((int)*t != 0)){
                            goto while_break;
                        }
                    }else{
                        goto while_break;
                    }
                }else{
                    goto while_break;
                }
                {
                    tmp___3 = even((long )slashes);
                }
                if (tmp___3){
                    if ((int)*t == 125){
                        if ((unsigned long )(s + 5) <= (unsigned long )t){
                            {
                                tmp = strncmp((const char*)(t - 5), "\\left", (size_t)5);
                            }
                            if (tmp){
                                goto _L;
                            }
                        }else
                            _L:
                            if ((unsigned long )(s + 6) <= (unsigned long )t){
                                {
                                    tmp___0 = strncmp((const char*)(t - 6), "\\right", (size_t)6);
                                }
                                if (tmp___0){
                                    braces--;
                                }
                            }else{
                                braces--;
                            }
                    }
                    if ((int)*t == 123){
                        if ((unsigned long )(s + 5) <= (unsigned long )t){
                            {
                                tmp___1 = strncmp((const char*)(t - 5), "\\left", (size_t)5);
                            }
                            if (tmp___1){
                                goto _L___0;
                            }
                        }else
                            _L___0:
                            if ((unsigned long )(s + 6) <= (unsigned long )t){
                                {
                                    tmp___2 = strncmp((const char*)(t - 6), "\\right", (size_t)6);
                                }
                                if (tmp___2){
                                    braces++;
                                }
                            }else{
                                braces++;
                            }
                    }
                }
                if ((int)*t == 92){
                    slashes++;
                }else{
                    slashes = 0;
                }
                if (braces){
                    t++;
                }
            }
            while_break:
            ;
        }
        return (t);
    }
}

static void ConvertOverToFrac(char** equation)
{
    char cNext;
    char* eq;
    char* mid;
    char* first___0;
    char* last;
    char* s;
    char* p;
    char* t;
    size_t tmp;
    void* tmp___0;
    const unsigned short **tmp___1;
    {
        {
            eq = *equation;
            p = eq;
            diagnostics(4, (char*)"ConvertOverToFrac before <%s>", p);
        }
        {
            while (1){
                while_continue:
                ;
                {
                    mid = strstr((const char*)p, "\\over");
                }
                if (!((unsigned long )mid != (unsigned long )((void*)0))){
                    goto while_break;
                }
                {
                    diagnostics(5, (char*)"Matched at <%s>", mid);
                    cNext = *(mid + 5);
                    diagnostics(5, (char*)"Next char is <%c>", (int)cNext);
                    tmp___1 = __ctype_b_loc();
                }
                if ((const int)*(*tmp___1 + (int)cNext) & 1024){
                    p = mid + 5;
                }else{
                    {
                        first___0 = scanback(eq, mid);
                        diagnostics(6, (char*)"first = <%s>", first___0);
                        last = scanahead(mid);
                        diagnostics(6, (char*)"last = <%s>", last);
                        strncpy((char*)mid, (const char*)"  }{ ", (size_t)5);
                        diagnostics(6, (char*)"mid = <%s>", mid);
                        tmp = strlen((const char*)eq);
                        tmp___0 = malloc((tmp + sizeof ("\\frac{}")) + 1UL);
                        s = (char*)tmp___0;
                        t = s;
                        strncpy((char*)t, (const char*)eq, (size_t)(first___0 - eq));
                        t += first___0 - eq;
                        strncpy((char*)t, (const char*)"\\frac", (size_t)5);
                        t += 5;
                    }
                    if ((int)*first___0 != 123){
                        *t = (char)'{';
                        t++;
                    }
                    {
                        strncpy((char*)t, (const char*)first___0, (size_t)(last - first___0));
                        t += last - first___0;
                    }
                    if ((int)*last != 125){
                        *t = (char)'}';
                        t++;
                    }
                    {
                        my_strcpy(t, (const char*)last);
                        free((void*)eq);
                        eq = s;
                        p = eq;
                    }
                }
                {
                    diagnostics(6, (char*)"ConvertOverToFrac current <%s>", eq);
                }
            }
            while_break:
            ;
        }
        {
            *equation = eq;
            diagnostics(4, (char*)"ConvertOverToFrac after <%s>", eq);
        }
        return;
    }
}

static int EquationGetsNoNumber(const char* s)
{
    char* tmp;
    char* tmp___0;
    {
        {
            tmp = strstr(s, "\\nonumber");
        }
        if (tmp){
            return (1);
        }
        {
            tmp___0 = strstr(s, "\\notag");
        }
        if (tmp___0){
            return (1);
        }
        return (0);
    }
}

static void WriteEquationAsRTF(int code, char** eq)
{
    int EQ_Needed;
    {
        {
            EQ_Needed = EquationNeedsFields(*eq);
            PrepareRtfEquation(code, EQ_Needed);
            ConvertOverToFrac(eq);
            ConvertString((const char*)*eq);
            FinishRtfEquation(code, EQ_Needed);
        }
        return;
    }
}

static void SetEquationLabel(char* eq)
{
    char* t;
    size_t tmp;
    {
        if (g_suppress_equation_number){
            return;
        }
        if ((unsigned long )eq == (unsigned long )((void*)0)){
            return;
        }else
            if ((int)*eq == 0){
                return;
            }

        {
            t = strstr((const char*)eq, "\\label");
        }
        if (t){
            {
                tmp = strlen("\\label");
                t += tmp;
                g_equation_label = getStringBraceParam(&t);
                diagnostics(4, (char*)"Bitmap equation label = \'%s\'", g_equation_label);
            }
        }
        return;
    }
}

void CmdEquation(int code)
{
    int inline_equation;
    int number;
    int true_code;
    char* pre;
    char* eq;
    char* post;
    int tmp;
    char* eq1;
    char* tmp___0;
    char* s;
    char* t;
    {
        pre = (char*)((void*)0);
        eq = (char*)((void*)0);
        post = (char*)((void*)0);
        true_code = code & -16385;
        if (!(code & 16384)){
            if (!(code == 16)){
                return;
            }
        }
        if (code == 16){
            {
                eq = getBraceParam();
            }
        }else{
            {
                SlurpEquation(code, &pre, &eq, &post);
            }
        }
        {
            diagnostics(4, (char*)"Entering CmdEquation --------%x\n<%s>\n<%s>\n<%s>", code, pre, eq, post);
        }
        if (true_code == 12){
            tmp = 1;
        }else
            if (true_code == 2){
                tmp = 1;
            }else
                if (true_code == 3){
                    tmp = 1;
                }else
                    if (true_code == 16){
                        tmp = 1;
                    }else{
                        tmp = 0;
                    }

        {
            inline_equation = tmp;
            number = getCounter((char*)"equation");
        }
        if (g_equation_comment){
            {
                WriteEquationAsComment(pre, eq, post);
            }
        }
        if (g_equation_raw_latex){
            if (inline_equation){
                {
                    fprintRTF((char*)"$");
                    putRtfStrEscaped((const char*)eq);
                    fprintRTF((char*)"$");
                }
            }else{
                {
                    tmp___0 = strdup((const char*)eq);
                    eq1 = tmp___0;
                    str_delete(eq1, "\\nonumber");
                    str_delete(eq1, "\\notag");
                    fprintRTF((char*)"\\\\[");
                }
                if (true_code == 14){
                    {
                        putRtfStrEscaped((const char*)eq1);
                    }
                }else
                    if (true_code == 4){
                        {
                            putRtfStrEscaped((const char*)eq1);
                        }
                    }else
                        if (true_code == 10){
                            {
                                putRtfStrEscaped((const char*)eq1);
                            }
                        }else
                            if (true_code == 11){
                                {
                                    putRtfStrEscaped((const char*)eq1);
                                }
                            }else
                                if (true_code == 13){
                                    {
                                        putRtfStrEscaped((const char*)eq1);
                                    }
                                }else
                                    if (true_code == 8){
                                        {
                                            putRtfStrEscaped("\\begin{align}");
                                            putRtfStrEscaped((const char*)eq1);
                                            putRtfStrEscaped("\\end{align}");
                                        }
                                    }else
                                        if (true_code == 9){
                                            {
                                                putRtfStrEscaped("\\begin{align}");
                                                putRtfStrEscaped((const char*)eq1);
                                                putRtfStrEscaped("\\end{align}");
                                            }
                                        }else{
                                            {
                                                putRtfStrEscaped((const char*)pre);
                                                putRtfStrEscaped((const char*)eq1);
                                                putRtfStrEscaped((const char*)post);
                                            }
                                        }

                {
                    fprintRTF((char*)"\\\\]");
                    free((void*)eq1);
                }
            }
        }
        {
            diagnostics(4, (char*)"inline=%d  inline_bitmap=%d", inline_equation, g_equation_inline_bitmap);
            diagnostics(4, (char*)"inline=%d display_bitmap=%d", inline_equation, g_equation_display_bitmap);
            diagnostics(4, (char*)"inline=%d  inline_rtf   =%d", inline_equation, g_equation_inline_rtf);
            diagnostics(4, (char*)"inline=%d display_rtf   =%d", inline_equation, g_equation_display_rtf);
        }
        if (inline_equation){
            if (g_equation_inline_bitmap){
                goto _L___0;
            }else{
                goto _L___1;
            }
        }else
            _L___1:
            if (!inline_equation){
                if (g_equation_display_bitmap){
                    _L___0:
                    if (true_code == 17){
                        goto _L;
                    }else
                        if (true_code == 8){
                            _L:
                            {
                                s = eq;
                                diagnostics(4, (char*)"eqnarray whole = <%s>", s);
                            }
                            {
                                while (1){
                                    while_continue:
                                    ;
                                    {
                                        t = strstr((const char*)s, "\\\\");
                                    }
                                    if (t){
                                        *t = (char)'\000';
                                    }
                                    {
                                        g_suppress_equation_number = EquationGetsNoNumber((const char*)s);
                                        PrepareRtfEquation(true_code, 0);
                                    }
                                    if (true_code == 8){
                                        {
                                            WriteLatexAsBitmap((char*)"\\begin{eqnarray*}", s, (char*)"\\end{eqnarray*}");
                                        }
                                    }else{
                                        {
                                            WriteLatexAsBitmap((char*)"\\begin{align*}", s, (char*)"\\end{align*}");
                                        }
                                    }
                                    {
                                        SetEquationLabel(s);
                                        FinishRtfEquation(true_code, 0);
                                    }
                                    if (t){
                                        s = t + 2;
                                    }
                                    if (!t){
                                        goto while_break;
                                    }
                                }
                                while_break:
                                ;
                            }
                        }else{
                            {
                                PrepareRtfEquation(true_code, 0);
                            }
                            if (true_code == 10){
                                if (g_amsmath_package){
                                    {
                                        g_suppress_equation_number = EquationGetsNoNumber((const char*)eq);
                                    }
                                }
                            }
                            if (true_code == 16){
                                {
                                    WriteLatexAsBitmap((char*)"\\ensuremath{", eq, (char*)"}");
                                }
                            }else{
                                {
                                    WriteLatexAsBitmap(pre, eq, post);
                                }
                            }
                            {
                                SetEquationLabel(eq);
                                FinishRtfEquation(true_code, 0);
                            }
                        }
                }
            }

        if (inline_equation){
            if (g_equation_inline_rtf){
                {
                    setCounter((char*)"equation", number);
                    WriteEquationAsRTF(true_code, &eq);
                }
            }else{
                goto _L___2;
            }
        }else
            _L___2:
            if (!inline_equation){
                if (g_equation_display_rtf){
                    {
                        setCounter((char*)"equation", number);
                        WriteEquationAsRTF(true_code, &eq);
                    }
                }
            }

        if (true_code == 12){
            {
                ConvertString((const char*)post);
            }
        }else
            if (true_code == 13){
                {
                    ConvertString((const char*)post);
                }
            }else
                if (true_code == 10){
                    {
                        ConvertString((const char*)post);
                    }
                }else
                    if (true_code == 11){
                        {
                            ConvertString((const char*)post);
                        }
                    }else
                        if (true_code == 8){
                            {
                                ConvertString((const char*)post);
                            }
                        }else
                            if (true_code == 9){
                                {
                                    ConvertString((const char*)post);
                                }
                            }else
                                if (true_code == 17){
                                    {
                                        ConvertString((const char*)post);
                                    }
                                }else
                                    if (true_code == 18){
                                        {
                                            ConvertString((const char*)post);
                                        }
                                    }

        {
            free((void*)pre);
            free((void*)eq);
            free((void*)post);
        }
        return;
    }
}

void CmdEnsuremath(int code)
{
    int mode;
    int tmp;
    char* eq;
    char* tmp___0;
    {
        {
            tmp = getTexMode();
            mode = tmp;
            diagnostics(4, (char*)"Entering CmdEnsuremath");
        }
        if (mode == 4){
            {
                tmp___0 = getBraceParam();
                eq = tmp___0;
                diagnostics(4, (char*)"already in math mode <%s>", eq);
                ConvertString((const char*)eq);
                free((void*)eq);
            }
        }else
            if (mode == 5){
                {
                    tmp___0 = getBraceParam();
                    eq = tmp___0;
                    diagnostics(4, (char*)"already in math mode <%s>", eq);
                    ConvertString((const char*)eq);
                    free((void*)eq);
                }
            }else{
                {
                    diagnostics(4, (char*)"need to start new equation");
                    CmdEquation(16);
                }
            }

        return;
    }
}

void CmdRoot(int code)
{
    char* root;
    char* power;
    size_t tmp;
    int tmp___0;
    int tmp___1;
    size_t tmp___2;
    int tmp___3;
    {
        {
            root = (char*)((void*)0);
            power = (char*)((void*)0);
            power = getBracketParam();
            root = getBraceParam();
            tmp___3 = fields_use_EQ();
        }
        if (tmp___3){
            {
                fprintRTF((char*)" \\\\R(");
            }
            if (power){
                {
                    tmp = strlen((const char*)power);
                }
                if (tmp > 0UL){
                    {
                        ConvertString((const char*)power);
                    }
                }
            }
            {
                fprintRTF((char*)"%c", (int)g_field_separator);
                ConvertString((const char*)root);
                fprintRTF((char*)")");
            }
        }else{
            if (power){
                {
                    tmp___2 = strlen((const char*)power);
                }
                if (tmp___2 > 0UL){
                    {
                        tmp___0 = script_size();
                        tmp___1 = script_shift();
                        fprintRTF((char*)"{\\up%d\\fs%d ", tmp___1, tmp___0);
                        ConvertString((const char*)power);
                        fprintRTF((char*)"}");
                    }
                }
            }
            {
                ConvertString("\\surd");
                fprintRTF((char*)"(");
                ConvertString((const char*)root);
                fprintRTF((char*)")");
            }
        }
        if (power){
            {
                free((void*)power);
            }
        }
        if (root){
            {
                free((void*)root);
            }
        }
        return;
    }
}

void CmdFraction(int code)
{
    char* denominator;
    char* numerator;
    char* nptr;
    char* dptr;
    int tmp;
    {
        {
            numerator = getBraceParam();
            nptr = strdup_noendblanks((const char*)numerator);
            skipSpaces();
            denominator = getBraceParam();
            dptr = strdup_noendblanks((const char*)denominator);
            free((void*)numerator);
            free((void*)denominator);
            diagnostics(4, (char*)"CmdFraction -- numerator   = <%s>", nptr);
            diagnostics(4, (char*)"CmdFraction -- denominator = <%s>", dptr);
            tmp = fields_use_EQ();
        }
        if (tmp){
            {
                fprintRTF((char*)" \\\\F(");
                ConvertString((const char*)nptr);
                fprintRTF((char*)"%c", (int)g_field_separator);
                ConvertString((const char*)dptr);
                fprintRTF((char*)")");
            }
        }else{
            {
                fprintRTF((char*)" ");
                ConvertString((const char*)nptr);
                fprintRTF((char*)"/");
                ConvertString((const char*)dptr);
                fprintRTF((char*)" ");
            }
        }
        {
            free((void*)nptr);
            free((void*)dptr);
        }
        return;
    }
}

void CmdArrows(int code)
{
    int size;
    int tmp;
    {
        {
            tmp = CurrentFontSize();
            size = (int)((double)tmp / 4.5);
        }
        {
            if (code == 1){
                goto case_1;
            }
            if (code == 2){
                goto case_2;
            }
            if (code == 9){
                goto case_9;
            }
            if (code == 6){
                goto case_6;
            }
            if (code == 5){
                goto case_5;
            }
            if (code == 3){
                goto case_3;
            }
            if (code == 4){
                goto case_4;
            }
            if (code == 7){
                goto case_7;
            }
            if (code == 8){
                goto case_8;
            }
            goto switch_break;
            case_1:
            {
                fprintRTF((char*)" \\\\o ({\\up%d ", size);
                ConvertString("\\leftarrow");
                fprintRTF((char*)"}%c{\\dn%d ", (int)g_field_separator, size);
                ConvertString("\\rightarrow");
                fprintRTF((char*)"}) ");
            }
            goto switch_break;
            case_2:
            {
                fprintRTF((char*)" \\\\o ({\\up%d ", size);
                ConvertString("\\rightarrow");
                fprintRTF((char*)"}%c{\\dn%d ", (int)g_field_separator, size);
                ConvertString("\\leftarrow");
                fprintRTF((char*)"}) ");
            }
            goto switch_break;
            case_9:
            {
                fprintRTF((char*)" \\\\o ({\\up%d ", size);
                ConvertString("\\leftharpoonup");
                fprintRTF((char*)"}%c{\\dn%d ", (int)g_field_separator, size);
                ConvertString("\\rightharpoondown");
                fprintRTF((char*)"}) ");
            }
            goto switch_break;
            case_6:
            {
                fprintRTF((char*)" \\\\o ({\\up%d ", size);
                ConvertString("\\rightarrow");
                fprintRTF((char*)"}%c{\\dn%d ", (int)g_field_separator, size);
                ConvertString("\\rightarrow");
                fprintRTF((char*)"}) ");
            }
            goto switch_break;
            case_5:
            {
                fprintRTF((char*)" \\\\o ({\\up%d ", size);
                ConvertString("\\leftarrow");
                fprintRTF((char*)"}%c{\\dn%d ", (int)g_field_separator, size);
                ConvertString("\\leftarrow");
                fprintRTF((char*)"}) ");
            }
            goto switch_break;
            case_3:
            {
                ConvertString("\\longleftarrow");
                ConvertString("\\longrightarrow");
            }
            goto switch_break;
            case_4:
            {
                fprintRTF((char*)" \\\\o ({\\up%d ", size);
                ConvertString("\\longrightarrow");
                fprintRTF((char*)"}%c{\\dn%d ", (int)g_field_separator, size);
                ConvertString("\\longleftarrow");
                fprintRTF((char*)"}) ");
            }
            goto switch_break;
            case_7:
            {
                ConvertString("\\leftarrow");
                CmdUnicodeChar(9135);
            }
            goto switch_break;
            case_8:
            {
                CmdUnicodeChar(9135);
                ConvertString("\\rightarrow");
            }
            goto switch_break;
            switch_break:
            ;
        }
        return;
    }
}

void CmdLim(int code)
{
    char cThis;
    char* s;
    char* lower_limit;
    int tmp;
    int tmp___0;
    int tmp___1;
    {
        {
            lower_limit = (char*)((void*)0);
            cThis = getNonBlank();
        }
        if ((int)cThis == 95){
            {
                lower_limit = getBraceParam();
            }
        }else{
            {
                ungetTexChar(cThis);
            }
        }
        if (code == 0){
            {
                s = strdup("lim");
            }
        }else
            if (code == 1){
                {
                    s = strdup("lim sup");
                }
            }else{
                {
                    s = strdup("lim inf");
                }
            }

        {
            tmp___1 = fields_use_EQ();
        }
        if (tmp___1){
            if (lower_limit){
                {
                    fprintRTF((char*)"\\\\a\\\\ac(");
                }
            }
            {
                fprintRTF((char*)"%s", s);
            }
            if (lower_limit){
                {
                    fprintRTF((char*)"%c", (int)g_field_separator);
                    ConvertString((const char*)lower_limit);
                    fprintRTF((char*)")");
                }
            }
        }else{
            {
                fprintRTF((char*)"%s ", s);
            }
            if (lower_limit){
                {
                    tmp = script_size();
                    tmp___0 = script_shift();
                    fprintRTF((char*)"{\\dn%d\\fs%d ", tmp___0, tmp);
                    ConvertString((const char*)lower_limit);
                    fprintRTF((char*)"}");
                }
            }
        }
        {
            free((void*)s);
        }
        return;
    }
}

void CmdIntegral(int code)
{
    char* upper_limit;
    char* lower_limit;
    int possible_limits;
    char* command;
    char cThis;
    int tmp;
    int tmp___0;
    int tmp___1;
    int tmp___2;
    int tmp___3;
    int tmp___4;
    int tmp___5;
    {
        {
            upper_limit = (char*)((void*)0);
            lower_limit = (char*)((void*)0);
            possible_limits = 1;
            command = (char*)((void*)0);
            diagnostics(4, (char*)"Entering CmdIntegral");
            cThis = getNonBlank();
        }
        if ((int)cThis == 92){
            {
                ungetTexChar(cThis);
                command = getSimpleCommand();
                tmp___0 = strcmp((const char*)command, "\\nolimits");
            }
            if (tmp___0 == 0){
                {
                    free((void*)command);
                    command = (char*)((void*)0);
                    possible_limits = 0;
                }
            }else{
                {
                    tmp = strcmp((const char*)command, "\\limits");
                }
                if (tmp == 0){
                    {
                        free((void*)command);
                        command = (char*)((void*)0);
                        cThis = getNonBlank();
                    }
                }else{
                    possible_limits = 0;
                }
            }
        }
        if (possible_limits){
            if ((int)cThis == 95){
                {
                    lower_limit = getBraceParam();
                }
            }else
                if ((int)cThis == 94){
                    {
                        upper_limit = getBraceParam();
                    }
                }else{
                    {
                        ungetTexChar(cThis);
                    }
                }

            if (upper_limit){
                goto _L;
            }else
                if (lower_limit){
                    _L:
                    {
                        cThis = getNonBlank();
                    }
                    if ((int)cThis == 95){
                        {
                            lower_limit = getBraceParam();
                        }
                    }else
                        if ((int)cThis == 94){
                            {
                                upper_limit = getBraceParam();
                            }
                        }else{
                            {
                                ungetTexChar(cThis);
                            }
                        }
                }
        }
        {
            tmp___5 = fields_use_EQ();
        }
        if (tmp___5){
            {
                fprintRTF((char*)" \\\\i ");
            }
            {
                if (code == 4){
                    goto case_4;
                }
                if (code == 3){
                    goto case_3;
                }
                if (code == 0){
                    goto case_0;
                }
                if (code == 1){
                    goto case_1;
                }
                if (code == 2){
                    goto case_2;
                }
                goto switch_default;
                case_4:
                if (upper_limit){
                    {
                        fprintRTF((char*)"( %c %c )\\\\I", (int)g_field_separator, (int)g_field_separator);
                    }
                }else
                    if (lower_limit){
                        {
                            fprintRTF((char*)"( %c %c )\\\\I", (int)g_field_separator, (int)g_field_separator);
                        }
                    }else{
                        {
                            fprintRTF((char*)"\\\\in( %c %c )\\\\I", (int)g_field_separator, (int)g_field_separator);
                        }
                    }
                case_3:
                if (upper_limit){
                    {
                        fprintRTF((char*)"( %c %c )\\\\I", (int)g_field_separator, (int)g_field_separator);
                    }
                }else
                    if (lower_limit){
                        {
                            fprintRTF((char*)"( %c %c )\\\\I", (int)g_field_separator, (int)g_field_separator);
                        }
                    }else{
                        {
                            fprintRTF((char*)"\\\\in( %c %c )\\\\I", (int)g_field_separator, (int)g_field_separator);
                        }
                    }
                case_0:
                if (upper_limit){
                    {
                        fprintRTF((char*)"(", (int)g_field_separator, (int)g_field_separator);
                    }
                }else
                    if (lower_limit){
                        {
                            fprintRTF((char*)"(", (int)g_field_separator, (int)g_field_separator);
                        }
                    }else{
                        {
                            fprintRTF((char*)"\\\\in(", (int)g_field_separator, (int)g_field_separator);
                        }
                    }
                goto switch_break;
                case_1:
                {
                    fprintRTF((char*)"\\\\su(");
                }
                goto switch_break;
                case_2:
                {
                    fprintRTF((char*)"\\\\pr(");
                }
                goto switch_break;
                switch_default:
                {
                    diagnostics(0, (char*)"Illegal code to CmdIntegral");
                }
                switch_break:
                ;
            }
            if (lower_limit){
                {
                    ConvertString((const char*)lower_limit);
                }
            }
            {
                fprintRTF((char*)"%c", (int)g_field_separator);
            }
            if (upper_limit){
                {
                    ConvertString((const char*)upper_limit);
                }
            }
            {
                fprintRTF((char*)"%c )", (int)g_field_separator);
            }
        }else{
            {
                if (code == 0){
                    goto case_0___0;
                }
                if (code == 1){
                    goto case_1___0;
                }
                if (code == 2){
                    goto case_2___0;
                }
                if (code == 3){
                    goto case_3___0;
                }
                if (code == 4){
                    goto case_4___0;
                }
                goto switch_default___0;
                case_0___0:
                {
                    CmdUnicodeChar(8747);
                }
                goto switch_break___0;
                case_1___0:
                {
                    CmdUnicodeChar(8721);
                }
                goto switch_break___0;
                case_2___0:
                {
                    CmdUnicodeChar(8719);
                }
                goto switch_break___0;
                case_3___0:
                {
                    CmdUnicodeChar(8747);
                    CmdUnicodeChar(8747);
                }
                goto switch_break___0;
                case_4___0:
                {
                    CmdUnicodeChar(8747);
                    CmdUnicodeChar(8747);
                    CmdUnicodeChar(8747);
                }
                goto switch_break___0;
                switch_default___0:
                {
                    diagnostics(0, (char*)"Illegal code to CmdIntegral");
                }
                switch_break___0:
                ;
            }
            if (lower_limit){
                {
                    tmp___1 = script_size();
                    tmp___2 = script_shift();
                    fprintRTF((char*)"{\\dn%d\\fs%d ", tmp___2, tmp___1);
                    ConvertString((const char*)lower_limit);
                    fprintRTF((char*)"}");
                }
            }
            if (upper_limit){
                {
                    tmp___3 = script_size();
                    tmp___4 = script_shift();
                    fprintRTF((char*)"{\\up%d\\fs%d ", tmp___4, tmp___3);
                    ConvertString((const char*)upper_limit);
                    fprintRTF((char*)"}");
                }
            }
        }
        if (command){
            {
                ConvertString((const char*)command);
                free((void*)command);
            }
        }
        if (lower_limit){
            {
                free((void*)lower_limit);
            }
        }
        if (upper_limit){
            {
                free((void*)upper_limit);
            }
        }
        return;
    }
}

static void SubSupWorker(int big)
{
    int vertical_shift;
    char cThis;
    char* upper_limit;
    char* lower_limit;
    const char* tmp;
    const char* tmp___0;
    int tmp___1;
    int tmp___2;
    int tmp___3;
    int tmp___4;
    int tmp___5;
    {
        {
            upper_limit = (char*)((void*)0);
            lower_limit = (char*)((void*)0);
            diagnostics(4, (char*)"SubSupWorker() ... big=%d", big);
        }
        {
            while (1){
                while_continue:
                ;
                {
                    cThis = getNonBlank();
                }
                if ((int)cThis == 95){
                    if (lower_limit){
                        {
                            diagnostics(1, (char*)"Double subscript");
                        }
                    }
                    {
                        lower_limit = getBraceParam();
                    }
                }else
                    if ((int)cThis == 94){
                        if (upper_limit){
                            {
                                diagnostics(1, (char*)"Double superscript");
                            }
                        }
                        {
                            upper_limit = getBraceParam();
                        }
                    }else{
                        {
                            ungetTexChar(cThis);
                        }
                        goto while_break;
                    }
            }
            while_break:
            ;
        }
        if (lower_limit){
            tmp = (const char*)lower_limit;
        }else{
            tmp = "";
        }
        {
            diagnostics(4, (char*)"...subscript  =\'%s\'", tmp);
        }
        if (upper_limit){
            tmp___0 = (const char*)upper_limit;
        }else{
            tmp___0 = "";
        }
        {
            diagnostics(4, (char*)"...superscript=\'%s\'", tmp___0);
        }
        if (big){
            {
                tmp___1 = CurrentFontSize();
                vertical_shift = (int)((double)tmp___1 / 1.4);
            }
        }else{
            {
                tmp___2 = CurrentFontSize();
                vertical_shift = tmp___2 / 4;
            }
        }
        if (upper_limit){
            if (lower_limit){
                {
                    tmp___3 = script_size();
                    fprintRTF((char*)"\\\\s\\\\up({\\fs%d ", tmp___3);
                    ConvertString((const char*)upper_limit);
                }
                if (big){
                    {
                        fprintRTF((char*)"%c %c", (int)g_field_separator, (int)g_field_separator);
                    }
                }else{
                    {
                        fprintRTF((char*)"%c", (int)g_field_separator);
                    }
                }
                {
                    ConvertString((const char*)lower_limit);
                    fprintRTF((char*)"})");
                }
            }else{
                goto _L;
            }
        }else
            _L:
            if (lower_limit){
                {
                    tmp___4 = script_size();
                    fprintRTF((char*)"\\\\s\\\\do%d({\\fs%d ", vertical_shift, tmp___4);
                    ConvertString((const char*)lower_limit);
                    fprintRTF((char*)"})");
                }
            }else
                if (upper_limit){
                    {
                        tmp___5 = script_size();
                        fprintRTF((char*)"\\\\s\\\\up%d({\\fs%d ", vertical_shift, tmp___5);
                        ConvertString((const char*)upper_limit);
                        fprintRTF((char*)"})");
                    }
                }

        if (lower_limit){
            {
                free((void*)lower_limit);
            }
        }
        if (upper_limit){
            {
                free((void*)upper_limit);
            }
        }
        return;
    }
}

static void simpleRTFScript(int super)
{
    char* s;
    int tmp;
    int tmp___0;
    int tmp___1;
    const char* tmp___2;
    {
        {
            s = (char*)((void*)0);
            tmp = getTexMode();
        }
        if (tmp == 6){
            {
                changeTexMode(2);
            }
        }
        {
            s = getBraceParam();
            tmp___0 = script_size();
            tmp___1 = script_shift();
        }
        if (super){
            tmp___2 = "up";
        }else{
            tmp___2 = "dn";
        }
        {
            fprintRTF((char*)"{\\%s%d\\fs%d ", tmp___2, tmp___1, tmp___0);
            ConvertString((const char*)s);
            fprintRTF((char*)"}");
            free((void*)s);
        }
        return;
    }
}

static void maybeFieldScript(int super)
{
    int tmp;
    {
        {
            tmp = fields_use_EQ();
        }
        if (tmp){
            if (super){
                {
                    ungetTexChar((char)'^');
                }
            }else{
                {
                    ungetTexChar((char)'_');
                }
            }
            {
                SubSupWorker(0);
            }
        }else{
            {
                simpleRTFScript(super);
            }
        }
        return;
    }
}

void CmdSuperscript(int code)
{
    {
        {
            if (code == 0){
                goto case_0;
            }
            if (code == 1){
                goto case_1;
            }
            goto switch_break;
            case_0:
            {
                diagnostics(4, (char*)"CmdSuperscript() code==0, equation ");
                maybeFieldScript(1);
            }
            goto switch_break;
            case_1:
            {
                diagnostics(4, (char*)"CmdSuperscript() code==1, \\textsuperscript ");
                simpleRTFScript(1);
            }
            goto switch_break;
            switch_break:
            ;
        }
        return;
    }
}

void CmdSubscript(int code)
{
    char* s;
    int size;
    int tmp;
    {
        s = (char*)((void*)0);
        {
            if (code == 0){
                goto case_0;
            }
            if (code == 1){
                goto case_1;
            }
            if (code == 2){
                goto case_2;
            }
            goto switch_break;
            case_0:
            {
                diagnostics(4, (char*)"CmdSubscript() code==0, equation ");
                maybeFieldScript(0);
            }
            goto switch_break;
            case_1:
            {
                diagnostics(4, (char*)"CmdSubscript() code==1, \\textsubscript ");
                simpleRTFScript(0);
            }
            goto switch_break;
            case_2:
            {
                diagnostics(4, (char*)"CmdSubscript() code==2, \\lower ");
                size = getDimension();
                fprintRTF((char*)"{\\dn%d ", size);
                s = getBraceParam();
                tmp = strcmp((const char*)s, "\\hbox");
            }
            if (tmp == 0){
                {
                    CmdBox(1);
                }
            }else{
                {
                    ConvertString((const char*)s);
                }
            }
            {
                fprintRTF((char*)"}");
                free((void*)s);
            }
            goto switch_break;
            switch_break:
            ;
        }
        return;
    }
}

static void getDelimOrCommand(char* delim, char** s)
{
    void* tmp;
    size_t tmp___0;
    int tmp___1;
    int tmp___2;
    int tmp___3;
    int tmp___4;
    int tmp___5;
    int tmp___6;
    int tmp___7;
    {
        {
            *delim = (char)'\000';
            ungetTexChar((char)'\\');
            *s = getSimpleCommand();
            tmp___0 = strlen((const char*)*s);
        }
        if (tmp___0 == 1UL){
            {
                free((void*)*s);
                tmp = malloc(3UL * sizeof (char));
                *s = (char*)tmp;
                *(*s + 0) = (char)'\\';
                *(*s + 1) = getTexChar();
                *(*s + 2) = (char)'\000';
            }
        }
        if (*s){
            {
                tmp___1 = strcmp((const char*)*s, "\\{");
            }
            if (tmp___1 == 0){
                *delim = (char)'{';
            }else{
                {
                    tmp___2 = strcmp((const char*)*s, "\\lbrace");
                }
                if (tmp___2 == 0){
                    *delim = (char)'{';
                }
            }
            {
                tmp___3 = strcmp((const char*)*s, "\\}");
            }
            if (tmp___3 == 0){
                *delim = (char)'}';
            }else{
                {
                    tmp___4 = strcmp((const char*)*s, "\\rbrace");
                }
                if (tmp___4 == 0){
                    *delim = (char)'}';
                }
            }
            {
                tmp___5 = strcmp((const char*)*s, "\\bracevert");
            }
            if (tmp___5 == 0){
                *delim = (char)'|';
            }
            {
                tmp___6 = strcmp((const char*)*s, "\\langle");
            }
            if (tmp___6 == 0){
                *delim = (char)'<';
            }
            {
                tmp___7 = strcmp((const char*)*s, "\\rangle");
            }
            if (tmp___7 == 0){
                *delim = (char)'>';
            }
            if (*delim){
                {
                    free((void*)*s);
                    *s = (char*)((void*)0);
                }
            }
        }
        return;
    }
}

void CmdLeftRight(int code)
{
    char ldelim;
    char rdelim;
    char* contents;
    char* lcommand;
    char* rcommand;
    int tmp;
    {
        {
            lcommand = (char*)((void*)0);
            rcommand = (char*)((void*)0);
            diagnostics(4, (char*)"CmdLeftRight() ... ");
            ldelim = getNonSpace();
        }
        if ((int)ldelim == 0){
            {
                PopSource();
                ldelim = getNonSpace();
            }
        }
        if ((int)ldelim == 92){
            {
                getDelimOrCommand(&ldelim, &lcommand);
            }
        }
        {
            contents = getLeftRightParam();
            rdelim = getNonSpace();
        }
        if ((int)rdelim == 92){
            {
                getDelimOrCommand(&rdelim, &rcommand);
            }
        }
        if (code == 1){
            {
                diagnostics(0, (char*)"\\right without opening \\left");
            }
        }
        {
            diagnostics(4, (char*)"CmdLeftRight() ... \\left <%c> \\right <%c>", (int)ldelim, (int)rdelim);
            tmp = fields_use_EQ();
        }
        if (tmp){
            {
                fprintRTF((char*)" \\\\b ");
            }
            if ((int)ldelim == 40){
                if ((int)rdelim == 41){
                    {
                        fprintRTF((char*)"(");
                    }
                    goto finish;
                }
            }
            if ((int)ldelim == 123){
                if ((int)rdelim == 125){
                    {
                        fprintRTF((char*)"\\\\bc\\\\\\{ (");
                    }
                    goto finish;
                }
            }
            if ((int)ldelim == 91){
                if ((int)rdelim == 93){
                    {
                        fprintRTF((char*)"\\\\bc\\\\[ (");
                    }
                    goto finish;
                }
            }
            if ((int)ldelim == 60){
                if ((int)rdelim == 62){
                    {
                        fprintRTF((char*)"\\\\bc\\\\< (");
                    }
                    goto finish;
                }
            }
            if ((int)ldelim == 123){
                {
                    fprintRTF((char*)"\\\\lc\\\\\\%c", (int)ldelim);
                }
            }else
                if ((int)ldelim == 125){
                    {
                        fprintRTF((char*)"\\\\lc\\\\\\%c", (int)ldelim);
                    }
                }else
                    if ((int)ldelim == 40){
                        {
                            fprintRTF((char*)"\\\\lc\\\\\\%c", (int)ldelim);
                        }
                    }else
                        if ((int)ldelim == 41){
                            {
                                fprintRTF((char*)"\\\\lc\\\\\\%c", (int)ldelim);
                            }
                        }else
                            if (ldelim){
                                if ((int)ldelim != 46){
                                    {
                                        fprintRTF((char*)"\\\\lc\\\\%c", (int)ldelim);
                                    }
                                }else{
                                    goto _L;
                                }
                            }else
                                _L:
                                if (lcommand){
                                    {
                                        fprintRTF((char*)"\\\\lc\\\\");
                                        ConvertString((const char*)lcommand);
                                    }
                                }

            if ((int)rdelim == 123){
                {
                    fprintRTF((char*)"\\\\rc\\\\\\%c", (int)rdelim);
                }
            }else
                if ((int)rdelim == 125){
                    {
                        fprintRTF((char*)"\\\\rc\\\\\\%c", (int)rdelim);
                    }
                }else
                    if ((int)rdelim == 40){
                        {
                            fprintRTF((char*)"\\\\rc\\\\\\%c", (int)rdelim);
                        }
                    }else
                        if ((int)rdelim == 41){
                            {
                                fprintRTF((char*)"\\\\rc\\\\\\%c", (int)rdelim);
                            }
                        }else
                            if (rdelim){
                                if ((int)rdelim != 46){
                                    {
                                        fprintRTF((char*)"\\\\rc\\\\%c", (int)rdelim);
                                    }
                                }else{
                                    goto _L___0;
                                }
                            }else
                                _L___0:
                                if (rcommand){
                                    {
                                        fprintRTF((char*)"\\\\rc\\\\");
                                        ConvertString((const char*)rcommand);
                                    }
                                }

            {
                fprintRTF((char*)" (");
            }
            finish:
            {
                ConvertString((const char*)contents);
                fprintRTF((char*)")");
                SubSupWorker(1);
            }
        }else{
            {
                putRtfCharEscaped(ldelim);
                ConvertString((const char*)contents);
                putRtfCharEscaped(rdelim);
            }
        }
        {
            safe_free(contents);
            safe_free(lcommand);
            safe_free(rcommand);
        }
        return;
    }
}

void CmdArray(int code)
{
    char* v_align;
    char* col_align;
    char* s;
    int n;
    const char* tmp;
    {
        n = 0;
        if (code & 16384){
            {
                v_align = getBracketParam();
                col_align = getBraceParam();
            }
            if (v_align){
                tmp = (const char*)v_align;
            }else{
                tmp = "";
            }
            {
                diagnostics(4, (char*)"CmdArray() ... \\begin{array}[%s]{%s}", tmp, col_align);
            }
            if (v_align){
                {
                    free((void*)v_align);
                }
            }
            s = col_align;
            {
                while (1){
                    while_continue:
                    ;
                    if (!*s){
                        goto while_break;
                    }
                    if ((int)*s == 99){
                        n++;
                    }else
                        if ((int)*s == 108){
                            n++;
                        }else
                            if ((int)*s == 114){
                                n++;
                            }

                    s++;
                }
                while_break:
                ;
            }
            {
                fprintRTF((char*)" \\\\a \\\\a%c \\\\co%d (", (int)*col_align, n);
                free((void*)col_align);
            }
            if (v_align){
                {
                    free((void*)v_align);
                }
            }
            g_processing_arrays++;
        }else{
            {
                fprintRTF((char*)")");
                diagnostics(4, (char*)"CmdArray() ... \\end{array}");
                g_processing_arrays--;
            }
        }
        return;
    }
}

void CmdMatrix(int code)
{
    char* contents;
    {
        {
            fprintRTF((char*)" matrix not implemented ");
            contents = getBraceParam();
            free((void*)contents);
        }
        return;
    }
}

void CmdStackrel(int code)
{
    char* numer;
    char* denom;
    int size;
    int tmp;
    int tmp___0;
    {
        {
            tmp = CurrentFontSize();
            size = (int)((double)tmp / 1.2);
            numer = getBraceParam();
            denom = getBraceParam();
            diagnostics(4, (char*)"CmdStackrel() ... \\stackrel{%s}{%s}", numer, denom);
            tmp___0 = fields_use_EQ();
        }
        if (tmp___0){
            {
                fprintRTF((char*)" \\\\a ({\\fs%d ", size);
                ConvertString((const char*)numer);
                fprintRTF((char*)"}%c", (int)g_field_separator);
                ConvertString((const char*)denom);
                fprintRTF((char*)") ");
            }
        }else{
            {
                diagnostics(1, (char*)"sorry stackrel requires fields");
                fprintRTF((char*)"{");
                ConvertString((const char*)numer);
                fprintRTF((char*)" ");
                ConvertString((const char*)denom);
                fprintRTF((char*)"}");
            }
        }
        {
            free((void*)numer);
            free((void*)denom);
        }
        return;
    }
}

void CmdOverLine(int code)
{
    char* argument;
    int tmp;
    {
        {
            argument = getBraceParam();
            diagnostics(4, (char*)"CmdOverLine() ... \\overline{%s}", argument);
            tmp = fields_use_EQ();
        }
        if (tmp){
            {
                fprintRTF((char*)" \\\\x\\\\to( ");
                ConvertString((const char*)argument);
                fprintRTF((char*)") ");
            }
        }else{
            {
                diagnostics(1, (char*)"sorry overline requires fields");
                fprintRTF((char*)"{");
                ConvertString((const char*)argument);
                fprintRTF((char*)"}");
            }
        }
        {
            free((void*)argument);
        }
        return;
    }
}

void CmdArraySlashSlash(int height)
{
    char cThis;
    char tmp;
    {
        {
            tmp = getNonBlank();
            cThis = tmp;
            ungetTexChar(cThis);
            diagnostics(4, (char*)"CmdArraySlashSlash height = %d, multiline=%d", height, g_multiline_equation_type);
            fprintRTF((char*)"%c", (int)g_field_separator);
        }
        return;
    }
}

void CmdEqnArraySlashSlash(int height)
{
    int restart_field;
    int tmp;
    char number[20];
    int tmp___0;
    {
        {
            restart_field = 0;
            diagnostics(4, (char*)"CmdEqnArraySlashSlash height = %d, multiline=%d", height, g_multiline_equation_type);
            tmp = EQ_field_active();
        }
        if (tmp){
            {
                diagnostics(4, (char*)"ending field due to \\\\");
                restart_field = 1;
                endCurrentField();
            }
        }
        if (g_show_equation_number){
            if (!g_suppress_equation_number){
                {
                    while (1){
                        while_continue:
                        ;
                        if (!(g_equation_column < 3)){
                            goto while_break;
                        }
                        {
                            fprintRTF((char*)"\\tab\n");
                            g_equation_column++;
                        }
                    }
                    while_break:
                    ;
                }
                {
                    incrementCounter((char*)"equation");
                    fprintRTF((char*)"\\tab{\\b0 (");
                    tmp___0 = getCounter((char*)"equation");
                    snprintf((char*)(number), (size_t)20, (const char*)"%d", tmp___0);
                    InsertBookmark(g_equation_label, number);
                }
                if (g_equation_label){
                    {
                        free((void*)g_equation_label);
                        g_equation_label = (char*)((void*)0);
                    }
                }
                {
                    fprintRTF((char*)")}");
                }
            }
        }
        {
            if (g_multiline_equation_type == 18){
                goto case_18;
            }
            if (g_multiline_equation_type == 9){
                goto case_9;
            }
            if (g_multiline_equation_type == 17){
                goto case_17;
            }
            if (g_multiline_equation_type == 8){
                goto case_8;
            }
            goto switch_default;
            case_18:
            {
                startParagraph("equationAlign", 4);
                setTexMode(5);
                g_processing_eqnarray = 1;
            }
            goto switch_break;
            case_9:
            {
                startParagraph("equationArray", 4);
                setTexMode(5);
                g_processing_eqnarray = 1;
            }
            goto switch_break;
            case_17:
            {
                startParagraph("equationAlignNum", 4);
                setTexMode(5);
                g_processing_eqnarray = 1;
            }
            goto switch_break;
            case_8:
            {
                startParagraph("equationArrayNum", 4);
                setTexMode(5);
                g_processing_eqnarray = 1;
            }
            goto switch_break;
            switch_default:
            {
                diagnostics(0, (char*)"something wrong with multiline equation");
            }
            goto switch_break;
            switch_break:
            ;
        }
        {
            fprintRTF((char*)"\\tab\n");
        }
        if (restart_field){
            {
                startField(1);
            }
        }
        g_suppress_equation_number = 0;
        g_equation_column = 1;
        return;
    }
}

void CmdSlashSlash(int height)
{
    int restart_field;
    int tmp;
    int tmp___0;
    {
        {
            restart_field = 0;
            diagnostics(4, (char*)"CmdSlashSlash height = %d", height);
        }
        if (g_processing_tabbing){
            {
                diagnostics(3, (char*)" I don\'t think this should happen anymore! ");
                PopBrace();
                PushBrace();
                g_tab_counter = 0;
            }
            return;
        }
        {
            tmp = EQ_field_active();
        }
        if (tmp){
            {
                diagnostics(4, (char*)"ending field due to \\\\");
                restart_field = 1;
                endCurrentField();
            }
        }
        if (height > 0){
            {
                tmp___0 = getVspace();
                setVspace(tmp___0 + height);
            }
        }
        {
            startParagraph("last", 0);
        }
        if (restart_field){
            {
                startField(1);
            }
        }
        return;
    }
}

void CmdLetter(int code);
void CmdAddress(int code);
void CmdSignature(int code);
void CmdOpening(int code);
void CmdClosing(int code);
void CmdPs(int code);
static int g_letterOpened = 0;
static char* g_letterToAddress = (char*)((void*)0);
static char* g_letterReturnAddress = (char*)((void*)0);
static char* g_letterSignature = (char*)((void*)0);

void CmdSignature(int code)
{
    {
        if (g_letterSignature){
            {
                free((void*)g_letterSignature);
            }
        }
        {
            g_letterSignature = getBraceParam();
        }
        return;
    }
}

void CmdAddress(int code)
{
    {
        if (g_letterReturnAddress){
            {
                free((void*)g_letterReturnAddress);
            }
        }
        {
            g_letterReturnAddress = getBraceParam();
        }
        return;
    }
}

void CmdLetter(int code)
{
    {
        if (code & 16384){
            {
                PushEnvironment(8);
            }
            if (g_letterToAddress){
                {
                    free((void*)g_letterToAddress);
                }
            }
            {
                g_letterToAddress = getBraceParam();
            }
        }else{
            {
                PopEnvironment();
            }
        }
        return;
    }
}

void CmdOpening(int code)
{
    char oldalignment___3;
    char* s;
    int tmp;
    int tmp___0;
    int tmp___1;
    int tmp___2;
    {
        {
            g_letterOpened = 1;
            tmp = getAlignment();
            oldalignment___3 = (char)tmp;
            setAlignment('r');
            tmp___0 = getAlignment();
            fprintRTF((char*)"\n\\par\\pard\\q%c ", tmp___0);
            diagnostics(5, (char*)"Entering ConvertString() from CmdAddress");
            ConvertString((const char*)g_letterReturnAddress);
            diagnostics(5, (char*)"Exiting ConvertString() from CmdAddress");
            fprintRTF((char*)"\\par\\chdate ");
            setAlignment('l');
            tmp___1 = getAlignment();
            fprintRTF((char*)"\n\\par\\pard\\q%c ", tmp___1);
            diagnostics(4, (char*)"Entering Convert() from CmdOpening");
            ConvertString((const char*)g_letterToAddress);
            diagnostics(4, (char*)"Exiting Convert() from CmdOpening");
            s = getBraceParam();
            ConvertString((const char*)s);
            free((void*)s);
            setAlignment((int)oldalignment___3);
            tmp___2 = getAlignment();
            fprintRTF((char*)"\n\\par\\pard\\q%c ", tmp___2);
        }
        return;
    }
}

void CmdClosing(int code)
{
    char oldalignment___3;
    char* s;
    int tmp;
    int tmp___0;
    int tmp___1;
    {
        {
            tmp = getAlignment();
            oldalignment___3 = (char)tmp;
            setAlignment('r');
            tmp___0 = getAlignment();
            fprintRTF((char*)"\n\\par\\pard\\q%c ", tmp___0);
            diagnostics(5, (char*)"Entering ConvertString() from CmdClosing");
            s = getBraceParam();
            ConvertString((const char*)s);
            free((void*)s);
            diagnostics(5, (char*)"Exiting ConvertString() from CmdClosing");
            fprintRTF((char*)"\n\\par\\par\\par ");
            diagnostics(5, (char*)"Entering ConvertString() from CmdSignature");
            ConvertString((const char*)g_letterSignature);
            diagnostics(5, (char*)"Exiting ConvertString() from CmdSignature");
            g_letterOpened = 0;
            setAlignment((int)oldalignment___3);
            tmp___1 = getAlignment();
            fprintRTF((char*)"\n\\par\\pard\\q%c ", tmp___1);
        }
        return;
    }
}

void CmdPs(int code)
{
    char* s;
    char* tmp;
    {
        {
            tmp = getBraceParam();
            s = tmp;
        }
        if (code == 3){
            {
                ConvertBabelName((char*)"ENCLNAME");
            }
        }else
            if (code == 2){
                {
                    ConvertBabelName((char*)"CCNAME");
                }
            }

        {
            ConvertString((const char*)s);
            free((void*)s);
        }
        return;
    }
}

extern int (atoi)(const char* __nptr);
extern time_t (time)(time_t* __timer);
extern char* (ctime)(const time_t* __timer);
int RussianMode;
int CzechMode;
int pagenumbering;
int headings;
int g_endfloat_figures;
int g_endfloat_tables;
int g_endfloat_markers;
void CmdDocumentStyle(int code);
void CmdUsepackage(int code);
void CmdTitle(int code);
void CmdAnd(int code);
void CmdMakeTitle(int code);
void CmdPreambleBeginEnd(int code);
void CmdTableOfContents(int code);
void PlainPagestyle(void);
void CmdPagestyle(int code);
void CmdHeader(int code);
void RtfHeader(int where, char* what);
void CmdHyphenation(int code);
void WriteRtfHeader(void);
void CmdHeadFoot(int code);
void CmdThePage(int code);
void setPackageInputenc(char* option);
void setPackageBabel(char* option);
void CmdGeometry(int code);
void InitializeDocumentFont(int family, int size, int shape, int series, int encoding);
int DefaultFontFamily(void);
int DefaultFontSize(void);
void CmdFontEncoding(int code);
int TexFontNumber(const char* Fname);
int RtfFontNumber(const char* Fname);
void ReadLanguage(char* lang);
ConfigEntryT** CfgStartIterate(void);
ConfigEntryT** CfgNextByInsertion(int WhichCfg, ConfigEntryT** last);
char* CurrentFileName(void);
void UpdateLineNumber(char* s);
void CmdAbstract(int code);
int TryPackageIgnore(const char* package);
void CallParamFunc(char* cCommand, int AddParam);
char* Version;
static int g_preambleTwoside = 0;
static int g_preambleTwocolumn = 0;
static int g_preambleTitlepage = 0;
static int g_preambleLandscape = 0;
static int g_preambleGeometry = 0;
static int g_geomMargl = 0;
static int g_geomMargr = 0;
static int g_geomMargt = 0;
static int g_geomMargb = 0;
static int gColorPackage = 0;
static char* g_preambleTitle = (char*)((void*)0);
static char* g_preambleAuthor = (char*)((void*)0);
static char* g_preambleDate = (char*)((void*)0);
static char* g_preambleAffiliation = (char*)((void*)0);
static char* g_preambleAbstract = (char*)((void*)0);
static char* g_preambleAck = (char*)((void*)0);
static char* g_preambleCFOOT = (char*)((void*)0);
static char* g_preambleLFOOT = (char*)((void*)0);
static char* g_preambleRFOOT = (char*)((void*)0);
static char* g_preambleCHEAD = (char*)((void*)0);
static char* g_preambleLHEAD = (char*)((void*)0);
static char* g_preambleRHEAD = (char*)((void*)0);
static void setPaperSize(char* option);
static void setDocumentOptions(char* optionlist);
static void WriteFontHeader(void);
static void WriteStyleHeader(void);
static void WritePageSize(void);
void ParseOptGeometry(char* options);
void ExecGeomOptions(char* key, char* value1, char* value2);

void setPackageBabel(char* option)
{
    char* replica;
    char* language;
    char* comma;
    char* tmp;
    char* tmp___0;
    char* tmp___1;
    char* tmp___2;
    {
        if ((unsigned long )option == (unsigned long )((void*)0)){
            return;
        }else
            if ((int)*option == 0){
                return;
            }

        {
            diagnostics(2, (char*)"setPackageBabel [%s]", option);
            replica = strdup_noblanks((const char*)option);
            language = replica;
        }
        {
            while (1){
                while_continue:
                ;
                if (language){
                    if (!*language){
                        goto while_break;
                    }
                }else{
                    goto while_break;
                }
                {
                    comma = strchr((const char*)language, ',');
                }
                if ((unsigned long )comma != (unsigned long )((void*)0)){
                    *comma = (char)'\000';
                }
                {
                    tmp = strstr((const char*)language, "german");
                }
                if (tmp){
                    {
                        GermanMode = 1;
                        PushEnvironment(12);
                        ReadLanguage((char*)"german");
                    }
                    return;
                }
                {
                    tmp___0 = strstr((const char*)language, "french");
                }
                if (tmp___0){
                    {
                        FrenchMode = 1;
                        PushEnvironment(13);
                    }
                }
                {
                    tmp___1 = strstr((const char*)language, "russian");
                }
                if (tmp___1){
                    {
                        RussianMode = 1;
                        PushEnvironment(14);
                    }
                }
                {
                    tmp___2 = strstr((const char*)language, "czech");
                }
                if (tmp___2){
                    {
                        CzechMode = 1;
                        PushEnvironment(16);
                        CmdFontEncoding(20);
                    }
                }
                {
                    ReadLanguage(language);
                }
                if (comma){
                    language = comma + 1;
                }else{
                    language = (char*)((void*)0);
                }
            }
            while_break:
            ;
        }
        {
            safe_free(replica);
        }
        return;
    }
}

void setPackageInputenc(char* option)
{
    char* tmp;
    char* tmp___0;
    char* tmp___1;
    char* tmp___2;
    char* tmp___3;
    char* tmp___4;
    char* tmp___5;
    char* tmp___6;
    char* tmp___7;
    char* tmp___8;
    char* tmp___9;
    char* tmp___10;
    char* tmp___11;
    char* tmp___12;
    char* tmp___13;
    char* tmp___14;
    char* tmp___15;
    char* tmp___16;
    char* tmp___17;
    char* tmp___18;
    char* tmp___19;
    char* tmp___20;
    char* tmp___21;
    char* tmp___22;
    char* tmp___23;
    char* tmp___24;
    char* tmp___25;
    char* tmp___26;
    {
        {
            tmp___26 = strstr((const char*)option, "applemac");
        }
        if (tmp___26){
            {
                CmdFontEncoding(14);
            }
        }else{
            {
                tmp___25 = strstr((const char*)option, "decmulti");
            }
            if (tmp___25){
                {
                    CmdFontEncoding(17);
                }
            }else{
                {
                    tmp___24 = strstr((const char*)option, "latin1");
                }
                if (tmp___24){
                    {
                        CmdFontEncoding(12);
                    }
                }else{
                    {
                        tmp___23 = strstr((const char*)option, "latin2");
                    }
                    if (tmp___23){
                        {
                            CmdFontEncoding(20);
                        }
                    }else{
                        {
                            tmp___22 = strstr((const char*)option, "latin3");
                        }
                        if (tmp___22){
                            {
                                CmdFontEncoding(21);
                            }
                        }else{
                            {
                                tmp___21 = strstr((const char*)option, "latin4");
                            }
                            if (tmp___21){
                                {
                                    CmdFontEncoding(22);
                                }
                            }else{
                                {
                                    tmp___20 = strstr((const char*)option, "latin5");
                                }
                                if (tmp___20){
                                    {
                                        CmdFontEncoding(23);
                                    }
                                }else{
                                    {
                                        tmp___19 = strstr((const char*)option, "latin9");
                                    }
                                    if (tmp___19){
                                        {
                                            CmdFontEncoding(24);
                                        }
                                    }else{
                                        {
                                            tmp___18 = strstr((const char*)option, "latin10");
                                        }
                                        if (tmp___18){
                                            {
                                                CmdFontEncoding(25);
                                            }
                                        }else{
                                            {
                                                tmp___17 = strstr((const char*)option, "next");
                                            }
                                            if (tmp___17){
                                                {
                                                    CmdFontEncoding(26);
                                                }
                                            }else{
                                                {
                                                    tmp___16 = strstr((const char*)option, "maccyr");
                                                }
                                                if (tmp___16){
                                                    {
                                                        CmdFontEncoding(16);
                                                    }
                                                }else{
                                                    {
                                                        tmp___15 = strstr((const char*)option, "macce");
                                                    }
                                                    if (tmp___15){
                                                        {
                                                            CmdFontEncoding(15);
                                                        }
                                                    }else{
                                                        {
                                                            tmp___14 = strstr((const char*)option, "koi8-r");
                                                        }
                                                        if (tmp___14){
                                                            {
                                                                CmdFontEncoding(18);
                                                            }
                                                        }else{
                                                            {
                                                                tmp___13 = strstr((const char*)option, "koi8-u");
                                                            }
                                                            if (tmp___13){
                                                                {
                                                                    CmdFontEncoding(19);
                                                                }
                                                            }else{
                                                                {
                                                                    tmp___12 = strstr((const char*)option, "437");
                                                                }
                                                                if (tmp___12){
                                                                    {
                                                                        CmdFontEncoding(3);
                                                                    }
                                                                }else{
                                                                    {
                                                                        tmp___11 = strstr((const char*)option, "ansinew");
                                                                    }
                                                                    if (tmp___11){
                                                                        {
                                                                            CmdFontEncoding(12);
                                                                        }
                                                                    }else{
                                                                        {
                                                                            tmp___10 = strstr((const char*)option, "1252");
                                                                        }
                                                                        if (tmp___10){
                                                                            {
                                                                                CmdFontEncoding(12);
                                                                            }
                                                                        }else{
                                                                            {
                                                                                tmp___9 = strstr((const char*)option, "850");
                                                                            }
                                                                            if (tmp___9){
                                                                                {
                                                                                    CmdFontEncoding(4);
                                                                                }
                                                                            }else{
                                                                                {
                                                                                    tmp___8 = strstr((const char*)option, "852");
                                                                                }
                                                                                if (tmp___8){
                                                                                    {
                                                                                        CmdFontEncoding(5);
                                                                                    }
                                                                                }else{
                                                                                    {
                                                                                        tmp___7 = strstr((const char*)option, "855");
                                                                                    }
                                                                                    if (tmp___7){
                                                                                        {
                                                                                            CmdFontEncoding(5);
                                                                                        }
                                                                                    }else{
                                                                                        {
                                                                                            tmp___6 = strstr((const char*)option, "865");
                                                                                        }
                                                                                        if (tmp___6){
                                                                                            {
                                                                                                CmdFontEncoding(8);
                                                                                            }
                                                                                        }else{
                                                                                            {
                                                                                                tmp___5 = strstr((const char*)option, "866");
                                                                                            }
                                                                                            if (tmp___5){
                                                                                                {
                                                                                                    CmdFontEncoding(9);
                                                                                                }
                                                                                            }else{
                                                                                                {
                                                                                                    tmp___4 = strstr((const char*)option, "1250");
                                                                                                }
                                                                                                if (tmp___4){
                                                                                                    {
                                                                                                        CmdFontEncoding(10);
                                                                                                    }
                                                                                                }else{
                                                                                                    {
                                                                                                        tmp___3 = strstr((const char*)option, "1251");
                                                                                                    }
                                                                                                    if (tmp___3){
                                                                                                        {
                                                                                                            CmdFontEncoding(11);
                                                                                                        }
                                                                                                    }else{
                                                                                                        {
                                                                                                            tmp___2 = strstr((const char*)option, "1253");
                                                                                                        }
                                                                                                        if (tmp___2){
                                                                                                            {
                                                                                                                CmdFontEncoding(13);
                                                                                                            }
                                                                                                        }else{
                                                                                                            {
                                                                                                                tmp___1 = strstr((const char*)option, "raw");
                                                                                                            }
                                                                                                            if (tmp___1){
                                                                                                                {
                                                                                                                    CmdFontEncoding(28);
                                                                                                                }
                                                                                                            }else{
                                                                                                                {
                                                                                                                    tmp___0 = strstr((const char*)option, "utf8");
                                                                                                                }
                                                                                                                if (tmp___0){
                                                                                                                    {
                                                                                                                        CmdFontEncoding(31);
                                                                                                                    }
                                                                                                                }else{
                                                                                                                    {
                                                                                                                        tmp = strstr((const char*)option, "ot2enc");
                                                                                                                    }
                                                                                                                    if (tmp){
                                                                                                                        {
                                                                                                                            setPackageBabel((char*)"russian");
                                                                                                                        }
                                                                                                                    }else{
                                                                                                                        {
                                                                                                                            diagnostics(1, (char*)"Input Encoding <%s> not supported", option);
                                                                                                                        }
                                                                                                                    }
                                                                                                                }
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        return;
    }
}

static void setPackageFont(char* font)
{
    int fnumber;
    char* tmp;
    char* tmp___0;
    char* tmp___1;
    char* tmp___2;
    char* tmp___3;
    char* tmp___4;
    char* tmp___5;
    int tmp___6;
    {
        {
            fnumber = -1;
            tmp___6 = strcmp((const char*)font, "palatino");
        }
        if (tmp___6 == 0){
            {
                fnumber = RtfFontNumber("Palatino");
            }
        }else{
            {
                tmp___5 = strstr((const char*)font, "times");
            }
            if (tmp___5){
                {
                    fnumber = RtfFontNumber("Times");
                }
            }else{
                {
                    tmp___4 = strstr((const char*)font, "chancery");
                }
                if (tmp___4){
                    {
                        fnumber = RtfFontNumber("Zapf Chancery");
                    }
                }else{
                    {
                        tmp___3 = strstr((const char*)font, "courier");
                    }
                    if (tmp___3){
                        {
                            fnumber = RtfFontNumber("Courier");
                        }
                    }else{
                        {
                            tmp___2 = strstr((const char*)font, "avant");
                        }
                        if (tmp___2){
                            {
                                fnumber = RtfFontNumber("Avant Garde");
                            }
                        }else{
                            {
                                tmp___1 = strstr((const char*)font, "helvet");
                            }
                            if (tmp___1){
                                {
                                    fnumber = RtfFontNumber("Helvetica");
                                }
                            }else{
                                {
                                    tmp___0 = strstr((const char*)font, "newcen");
                                }
                                if (tmp___0){
                                    {
                                        fnumber = RtfFontNumber("New Century Schoolbook");
                                    }
                                }else{
                                    {
                                        tmp = strstr((const char*)font, "book");
                                    }
                                    if (tmp){
                                        {
                                            fnumber = RtfFontNumber("Bookman");
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        if (fnumber == -1){
            {
                diagnostics(1, (char*)"Font Package <%s> not supported.", font);
            }
        }
        return;
    }
}

static void setThree(char* s, int ten, int eleven, int twelve)
{
    int n;
    int tmp;
    {
        {
            tmp = DefaultFontSize();
            n = tmp;
        }
        if (n == 20){
            {
                setLength(s, ten * 20);
            }
        }else
            if (n == 22){
                {
                    setLength(s, eleven * 20);
                }
            }else{
                {
                    setLength(s, twelve * 20);
                }
            }

        return;
    }
}

static void setPaperSize(char* option)
{
    int tmp;
    int tmp___0;
    int tmp___1;
    int tmp___2;
    int tmp___3;
    int tmp___4;
    int tmp___5;
    int tmp___6;
    {
        {
            tmp___6 = strcmp((const char*)option, "landscape");
        }
        if (tmp___6 == 0){
            g_preambleLandscape = 1;
        }else{
            {
                tmp___5 = strcmp((const char*)option, "a4paper");
            }
            if (tmp___5 == 0){
                {
                    setLength((char*)"pageheight", 16900);
                    setLength((char*)"hoffset", 0);
                    setThree((char*)"oddsidemargin", 53, 46, 31);
                    setLength((char*)"headheight", 240);
                    setThree((char*)"textheight", 598, 596, 592);
                    setLength((char*)"footskip", 600);
                    setLength((char*)"marginparpush", 100);
                    setLength((char*)"pagewidth", 11960);
                    setLength((char*)"voffset", 0);
                    setLength((char*)"topmargin", 340);
                    setLength((char*)"headsep", 500);
                    setThree((char*)"textwidth", 345, 360, 390);
                    setThree((char*)"columnwidth", 345, 360, 390);
                    setThree((char*)"linewidth", 345, 360, 390);
                    setLength((char*)"marginparsep", 200);
                    setLength((char*)"columnsep", 200);
                }
            }else{
                {
                    tmp___4 = strcmp((const char*)option, "a4");
                }
                if (tmp___4 == 0){
                    {
                        setLength((char*)"pageheight", 16900);
                        setLength((char*)"hoffset", 0);
                        setThree((char*)"oddsidemargin", 40, 33, 14);
                        setLength((char*)"headheight", 240);
                        setThree((char*)"textheight", 646, 637, 621);
                        setLength((char*)"footskip", 600);
                        setLength((char*)"marginparpush", 100);
                        setLength((char*)"pagewidth", 11960);
                        setLength((char*)"voffset", 0);
                        setLength((char*)"topmargin", 0);
                        setLength((char*)"headsep", 500);
                        setThree((char*)"textwidth", 361, 376, 412);
                        setThree((char*)"columnwidth", 361, 376, 412);
                        setThree((char*)"linewidth", 361, 376, 412);
                        setLength((char*)"marginparsep", 200);
                        setLength((char*)"columnsep", 200);
                    }
                }else{
                    {
                        tmp___3 = strcmp((const char*)option, "a4wide");
                    }
                    if (tmp___3 == 0){
                        {
                            setLength((char*)"pageheight", 16900);
                            setLength((char*)"hoffset", 0);
                            setThree((char*)"oddsidemargin", 18, 9, 0);
                            setLength((char*)"headheight", 240);
                            setThree((char*)"textheight", 621, 637, 621);
                            setLength((char*)"footskip", 600);
                            setLength((char*)"marginparpush", 100);
                            setLength((char*)"pagewidth", 11960);
                            setLength((char*)"voffset", 0);
                            setLength((char*)"topmargin", 0);
                            setLength((char*)"headsep", 500);
                            setThree((char*)"textwidth", 425, 443, 461);
                            setThree((char*)"linewidth", 425, 443, 461);
                            setThree((char*)"columnwidth", 425, 443, 461);
                            setLength((char*)"marginparsep", 200);
                            setLength((char*)"columnsep", 200);
                        }
                    }else{
                        {
                            tmp___2 = strcmp((const char*)option, "letterpaper");
                        }
                        if (tmp___2 == 0){
                            {
                                setLength((char*)"pageheight", 15900);
                                setLength((char*)"hoffset", 0);
                                setThree((char*)"oddsidemargin", 62, 54, 39);
                                setLength((char*)"headheight", 240);
                                setThree((char*)"textheight", 550, 541, 549);
                                setLength((char*)"footskip", 600);
                                setLength((char*)"marginparpush", 100);
                                setLength((char*)"pagewidth", 12280);
                                setLength((char*)"voffset", 0);
                                setLength((char*)"topmargin", 360);
                                setLength((char*)"headsep", 500);
                                setThree((char*)"textwidth", 345, 360, 390);
                                setThree((char*)"linewidth", 345, 360, 390);
                                setThree((char*)"columnwidth", 345, 360, 390);
                                setLength((char*)"marginparsep", 200);
                                setLength((char*)"columnsep", 200);
                            }
                        }else{
                            {
                                tmp___1 = strcmp((const char*)option, "legalpaper");
                            }
                            if (tmp___1 == 0){
                                {
                                    setLength((char*)"pageheight", 20240);
                                    setLength((char*)"hoffset", 0);
                                    setThree((char*)"oddsidemargin", 62, 54, 39);
                                    setLength((char*)"headheight", 240);
                                    setThree((char*)"textheight", 766, 759, 766);
                                    setLength((char*)"footskip", 600);
                                    setLength((char*)"marginparpush", 100);
                                    setLength((char*)"pagewidth", 12280);
                                    setLength((char*)"voffset", 0);
                                    setLength((char*)"topmargin", 360);
                                    setLength((char*)"headsep", 500);
                                    setThree((char*)"textwidth", 345, 360, 390);
                                    setThree((char*)"columnwidth", 345, 360, 390);
                                    setThree((char*)"linewidth", 345, 360, 390);
                                    setLength((char*)"marginparsep", 200);
                                    setLength((char*)"columnsep", 200);
                                }
                            }else{
                                {
                                    tmp___0 = strcmp((const char*)option, "a5paper");
                                }
                                if (tmp___0 == 0){
                                    {
                                        setLength((char*)"pageheight", 11960);
                                        setLength((char*)"hoffset", 0);
                                        setLength((char*)"oddsidemargin", 0);
                                        setLength((char*)"headheight", 240);
                                        setLength((char*)"textheight", 7000);
                                        setLength((char*)"footskip", 600);
                                        setLength((char*)"marginparpush", 100);
                                        setLength((char*)"pagewidth", 8420);
                                        setLength((char*)"voffset", 0);
                                        setLength((char*)"topmargin", 360);
                                        setLength((char*)"headsep", 500);
                                        setLength((char*)"textwidth", 5520);
                                        setLength((char*)"columnwidth", 5520);
                                        setLength((char*)"linewidth", 5520);
                                        setLength((char*)"marginparsep", 200);
                                        setLength((char*)"columnsep", 200);
                                    }
                                }else{
                                    {
                                        tmp = strcmp((const char*)option, "b5paper");
                                    }
                                    if (tmp == 0){
                                        {
                                            setLength((char*)"pageheight", 14220);
                                            setLength((char*)"hoffset", 0);
                                            setLength((char*)"oddsidemargin", 0);
                                            setLength((char*)"headheight", 240);
                                            setLength((char*)"textheight", 9200);
                                            setLength((char*)"footskip", 600);
                                            setLength((char*)"marginparpush", 100);
                                            setLength((char*)"pagewidth", 10020);
                                            setLength((char*)"voffset", 0);
                                            setLength((char*)"topmargin", 380);
                                            setLength((char*)"headsep", 500);
                                            setLength((char*)"textwidth", 7000);
                                            setLength((char*)"columnwidth", 7000);
                                            setLength((char*)"linewidth", 7000);
                                            setLength((char*)"marginparsep", 200);
                                            setLength((char*)"columnsep", 200);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        return;
    }
}

static void setPointSize(char* option)
{
    int tmp;
    int tmp___0;
    {
        {
            tmp___0 = strcmp((const char*)option, "10pt");
        }
        if (tmp___0 == 0){
            {
                InitializeDocumentFont(-1, 20, -1, -1, 11);
                setLength((char*)"baselineskip", 240);
                setLength((char*)"parindent", 300);
                setLength((char*)"parskip", 0);
            }
        }else{
            {
                tmp = strcmp((const char*)option, "11pt");
            }
            if (tmp == 0){
                {
                    InitializeDocumentFont(-1, 22, -1, -1, 11);
                    setLength((char*)"baselineskip", 280);
                    setLength((char*)"parindent", 340);
                    setLength((char*)"parskip", 0);
                }
            }else{
                {
                    InitializeDocumentFont(-1, 24, -1, -1, 11);
                    setLength((char*)"baselineskip", (int)14.5 * 20);
                    setLength((char*)"parindent", 360);
                    setLength((char*)"parskip", 0);
                }
            }
        }
        return;
    }
}

static void setDocumentOptions(char* optionlist)
{
    char* option;
    int tmp;
    int tmp___0;
    int tmp___1;
    int tmp___2;
    int tmp___3;
    int tmp___4;
    int tmp___5;
    int tmp___6;
    int tmp___7;
    int tmp___8;
    int tmp___9;
    int tmp___10;
    int tmp___11;
    int tmp___12;
    int tmp___13;
    int tmp___14;
    int tmp___15;
    int tmp___16;
    int tmp___17;
    int tmp___18;
    int tmp___19;
    int tmp___20;
    int tmp___21;
    int tmp___22;
    int tmp___23;
    int tmp___24;
    int tmp___25;
    int tmp___26;
    int tmp___27;
    int tmp___28;
    int tmp___29;
    int tmp___30;
    int tmp___31;
    int tmp___32;
    int tmp___33;
    int tmp___34;
    int tmp___35;
    int tmp___36;
    int tmp___37;
    int tmp___38;
    int tmp___39;
    int tmp___40;
    int tmp___41;
    int tmp___42;
    int tmp___43;
    int tmp___44;
    int tmp___45;
    int tmp___46;
    int tmp___47;
    int tmp___48;
    int tmp___49;
    int tmp___50;
    int tmp___51;
    int tmp___52;
    int tmp___53;
    int tmp___54;
    int tmp___55;
    int tmp___56;
    int tmp___57;
    int tmp___58;
    int tmp___59;
    int tmp___60;
    int tmp___61;
    int tmp___62;
    int tmp___63;
    int tmp___64;
    int tmp___65;
    int tmp___66;
    int tmp___67;
    int tmp___68;
    int tmp___69;
    int tmp___70;
    int tmp___71;
    int tmp___72;
    int tmp___73;
    int tmp___74;
    int tmp___75;
    int tmp___76;
    int tmp___77;
    int tmp___78;
    int tmp___79;
    int tmp___80;
    int tmp___81;
    int tmp___82;
    int tmp___83;
    int tmp___84;
    {
        if ((unsigned long )optionlist == (unsigned long )((void*)0)){
            return;
        }
        {
            option = strtok((char*)optionlist, (const char*)",");
        }
        {
            while (1){
                while_continue:
                ;
                if (!option){
                    goto while_break;
                }
                {
                    diagnostics(2, (char*)" (setDocumentOptions) option <%s>", option);
                    tmp___84 = TryPackageIgnore((const char*)option);
                }
                if (!tmp___84){
                    {
                        tmp___81 = strcmp((const char*)option, "10pt");
                    }
                    if (tmp___81 == 0){
                        {
                            setPointSize(option);
                        }
                    }else{
                        {
                            tmp___82 = strcmp((const char*)option, "11pt");
                        }
                        if (tmp___82 == 0){
                            {
                                setPointSize(option);
                            }
                        }else{
                            {
                                tmp___83 = strcmp((const char*)option, "12pt");
                            }
                            if (tmp___83 == 0){
                                {
                                    setPointSize(option);
                                }
                            }else{
                                {
                                    tmp___73 = strcmp((const char*)option, "a4");
                                }
                                if (tmp___73 == 0){
                                    {
                                        setPaperSize(option);
                                    }
                                }else{
                                    {
                                        tmp___74 = strcmp((const char*)option, "a4paper");
                                    }
                                    if (tmp___74 == 0){
                                        {
                                            setPaperSize(option);
                                        }
                                    }else{
                                        {
                                            tmp___75 = strcmp((const char*)option, "a4wide");
                                        }
                                        if (tmp___75 == 0){
                                            {
                                                setPaperSize(option);
                                            }
                                        }else{
                                            {
                                                tmp___76 = strcmp((const char*)option, "b5paper");
                                            }
                                            if (tmp___76 == 0){
                                                {
                                                    setPaperSize(option);
                                                }
                                            }else{
                                                {
                                                    tmp___77 = strcmp((const char*)option, "a5paper");
                                                }
                                                if (tmp___77 == 0){
                                                    {
                                                        setPaperSize(option);
                                                    }
                                                }else{
                                                    {
                                                        tmp___78 = strcmp((const char*)option, "letterpaper");
                                                    }
                                                    if (tmp___78 == 0){
                                                        {
                                                            setPaperSize(option);
                                                        }
                                                    }else{
                                                        {
                                                            tmp___79 = strcmp((const char*)option, "landscape");
                                                        }
                                                        if (tmp___79 == 0){
                                                            {
                                                                setPaperSize(option);
                                                            }
                                                        }else{
                                                            {
                                                                tmp___80 = strcmp((const char*)option, "legalpaper");
                                                            }
                                                            if (tmp___80 == 0){
                                                                {
                                                                    setPaperSize(option);
                                                                }
                                                            }else{
                                                                {
                                                                    tmp___33 = streq((const char*)option, "afrikaans");
                                                                }
                                                                if (tmp___33){
                                                                    {
                                                                        setPackageBabel(option);
                                                                    }
                                                                }else{
                                                                    {
                                                                        tmp___34 = streq((const char*)option, "bahasa");
                                                                    }
                                                                    if (tmp___34){
                                                                        {
                                                                            setPackageBabel(option);
                                                                        }
                                                                    }else{
                                                                        {
                                                                            tmp___35 = streq((const char*)option, "basque");
                                                                        }
                                                                        if (tmp___35){
                                                                            {
                                                                                setPackageBabel(option);
                                                                            }
                                                                        }else{
                                                                            {
                                                                                tmp___36 = streq((const char*)option, "brazil");
                                                                            }
                                                                            if (tmp___36){
                                                                                {
                                                                                    setPackageBabel(option);
                                                                                }
                                                                            }else{
                                                                                {
                                                                                    tmp___37 = streq((const char*)option, "breton");
                                                                                }
                                                                                if (tmp___37){
                                                                                    {
                                                                                        setPackageBabel(option);
                                                                                    }
                                                                                }else{
                                                                                    {
                                                                                        tmp___38 = streq((const char*)option, "catalan");
                                                                                    }
                                                                                    if (tmp___38){
                                                                                        {
                                                                                            setPackageBabel(option);
                                                                                        }
                                                                                    }else{
                                                                                        {
                                                                                            tmp___39 = streq((const char*)option, "croatian");
                                                                                        }
                                                                                        if (tmp___39){
                                                                                            {
                                                                                                setPackageBabel(option);
                                                                                            }
                                                                                        }else{
                                                                                            {
                                                                                                tmp___40 = streq((const char*)option, "czech");
                                                                                            }
                                                                                            if (tmp___40){
                                                                                                {
                                                                                                    setPackageBabel(option);
                                                                                                }
                                                                                            }else{
                                                                                                {
                                                                                                    tmp___41 = streq((const char*)option, "danish");
                                                                                                }
                                                                                                if (tmp___41){
                                                                                                    {
                                                                                                        setPackageBabel(option);
                                                                                                    }
                                                                                                }else{
                                                                                                    {
                                                                                                        tmp___42 = streq((const char*)option, "dutch");
                                                                                                    }
                                                                                                    if (tmp___42){
                                                                                                        {
                                                                                                            setPackageBabel(option);
                                                                                                        }
                                                                                                    }else{
                                                                                                        {
                                                                                                            tmp___43 = streq((const char*)option, "english");
                                                                                                        }
                                                                                                        if (tmp___43){
                                                                                                            {
                                                                                                                setPackageBabel(option);
                                                                                                            }
                                                                                                        }else{
                                                                                                            {
                                                                                                                tmp___44 = streq((const char*)option, "esperanto");
                                                                                                            }
                                                                                                            if (tmp___44){
                                                                                                                {
                                                                                                                    setPackageBabel(option);
                                                                                                                }
                                                                                                            }else{
                                                                                                                {
                                                                                                                    tmp___45 = streq((const char*)option, "estonian");
                                                                                                                }
                                                                                                                if (tmp___45){
                                                                                                                    {
                                                                                                                        setPackageBabel(option);
                                                                                                                    }
                                                                                                                }else{
                                                                                                                    {
                                                                                                                        tmp___46 = streq((const char*)option, "finnish");
                                                                                                                    }
                                                                                                                    if (tmp___46){
                                                                                                                        {
                                                                                                                            setPackageBabel(option);
                                                                                                                        }
                                                                                                                    }else{
                                                                                                                        {
                                                                                                                            tmp___47 = streq((const char*)option, "french");
                                                                                                                        }
                                                                                                                        if (tmp___47){
                                                                                                                            {
                                                                                                                                setPackageBabel(option);
                                                                                                                            }
                                                                                                                        }else{
                                                                                                                            {
                                                                                                                                tmp___48 = streq((const char*)option, "galician");
                                                                                                                            }
                                                                                                                            if (tmp___48){
                                                                                                                                {
                                                                                                                                    setPackageBabel(option);
                                                                                                                                }
                                                                                                                            }else{
                                                                                                                                {
                                                                                                                                    tmp___49 = streq((const char*)option, "german");
                                                                                                                                }
                                                                                                                                if (tmp___49){
                                                                                                                                    {
                                                                                                                                        setPackageBabel(option);
                                                                                                                                    }
                                                                                                                                }else{
                                                                                                                                    {
                                                                                                                                        tmp___50 = streq((const char*)option, "icelandic");
                                                                                                                                    }
                                                                                                                                    if (tmp___50){
                                                                                                                                        {
                                                                                                                                            setPackageBabel(option);
                                                                                                                                        }
                                                                                                                                    }else{
                                                                                                                                        {
                                                                                                                                            tmp___51 = streq((const char*)option, "irish");
                                                                                                                                        }
                                                                                                                                        if (tmp___51){
                                                                                                                                            {
                                                                                                                                                setPackageBabel(option);
                                                                                                                                            }
                                                                                                                                        }else{
                                                                                                                                            {
                                                                                                                                                tmp___52 = streq((const char*)option, "italian");
                                                                                                                                            }
                                                                                                                                            if (tmp___52){
                                                                                                                                                {
                                                                                                                                                    setPackageBabel(option);
                                                                                                                                                }
                                                                                                                                            }else{
                                                                                                                                                {
                                                                                                                                                    tmp___53 = streq((const char*)option, "latin");
                                                                                                                                                }
                                                                                                                                                if (tmp___53){
                                                                                                                                                    {
                                                                                                                                                        setPackageBabel(option);
                                                                                                                                                    }
                                                                                                                                                }else{
                                                                                                                                                    {
                                                                                                                                                        tmp___54 = streq((const char*)option, "lsorbian");
                                                                                                                                                    }
                                                                                                                                                    if (tmp___54){
                                                                                                                                                        {
                                                                                                                                                            setPackageBabel(option);
                                                                                                                                                        }
                                                                                                                                                    }else{
                                                                                                                                                        {
                                                                                                                                                            tmp___55 = streq((const char*)option, "magyar");
                                                                                                                                                        }
                                                                                                                                                        if (tmp___55){
                                                                                                                                                            {
                                                                                                                                                                setPackageBabel(option);
                                                                                                                                                            }
                                                                                                                                                        }else{
                                                                                                                                                            {
                                                                                                                                                                tmp___56 = streq((const char*)option, "norsk");
                                                                                                                                                            }
                                                                                                                                                            if (tmp___56){
                                                                                                                                                                {
                                                                                                                                                                    setPackageBabel(option);
                                                                                                                                                                }
                                                                                                                                                            }else{
                                                                                                                                                                {
                                                                                                                                                                    tmp___57 = streq((const char*)option, "nynorsk");
                                                                                                                                                                }
                                                                                                                                                                if (tmp___57){
                                                                                                                                                                    {
                                                                                                                                                                        setPackageBabel(option);
                                                                                                                                                                    }
                                                                                                                                                                }else{
                                                                                                                                                                    {
                                                                                                                                                                        tmp___58 = streq((const char*)option, "polish");
                                                                                                                                                                    }
                                                                                                                                                                    if (tmp___58){
                                                                                                                                                                        {
                                                                                                                                                                            setPackageBabel(option);
                                                                                                                                                                        }
                                                                                                                                                                    }else{
                                                                                                                                                                        {
                                                                                                                                                                            tmp___59 = streq((const char*)option, "portuges");
                                                                                                                                                                        }
                                                                                                                                                                        if (tmp___59){
                                                                                                                                                                            {
                                                                                                                                                                                setPackageBabel(option);
                                                                                                                                                                            }
                                                                                                                                                                        }else{
                                                                                                                                                                            {
                                                                                                                                                                                tmp___60 = streq((const char*)option, "romanian");
                                                                                                                                                                            }
                                                                                                                                                                            if (tmp___60){
                                                                                                                                                                                {
                                                                                                                                                                                    setPackageBabel(option);
                                                                                                                                                                                }
                                                                                                                                                                            }else{
                                                                                                                                                                                {
                                                                                                                                                                                    tmp___61 = streq((const char*)option, "russian");
                                                                                                                                                                                }
                                                                                                                                                                                if (tmp___61){
                                                                                                                                                                                    {
                                                                                                                                                                                        setPackageBabel(option);
                                                                                                                                                                                    }
                                                                                                                                                                                }else{
                                                                                                                                                                                    {
                                                                                                                                                                                        tmp___62 = streq((const char*)option, "samin");
                                                                                                                                                                                    }
                                                                                                                                                                                    if (tmp___62){
                                                                                                                                                                                        {
                                                                                                                                                                                            setPackageBabel(option);
                                                                                                                                                                                        }
                                                                                                                                                                                    }else{
                                                                                                                                                                                        {
                                                                                                                                                                                            tmp___63 = streq((const char*)option, "scottish");
                                                                                                                                                                                        }
                                                                                                                                                                                        if (tmp___63){
                                                                                                                                                                                            {
                                                                                                                                                                                                setPackageBabel(option);
                                                                                                                                                                                            }
                                                                                                                                                                                        }else{
                                                                                                                                                                                            {
                                                                                                                                                                                                tmp___64 = streq((const char*)option, "serbian");
                                                                                                                                                                                            }
                                                                                                                                                                                            if (tmp___64){
                                                                                                                                                                                                {
                                                                                                                                                                                                    setPackageBabel(option);
                                                                                                                                                                                                }
                                                                                                                                                                                            }else{
                                                                                                                                                                                                {
                                                                                                                                                                                                    tmp___65 = streq((const char*)option, "slovak");
                                                                                                                                                                                                }
                                                                                                                                                                                                if (tmp___65){
                                                                                                                                                                                                    {
                                                                                                                                                                                                        setPackageBabel(option);
                                                                                                                                                                                                    }
                                                                                                                                                                                                }else{
                                                                                                                                                                                                    {
                                                                                                                                                                                                        tmp___66 = streq((const char*)option, "slovene");
                                                                                                                                                                                                    }
                                                                                                                                                                                                    if (tmp___66){
                                                                                                                                                                                                        {
                                                                                                                                                                                                            setPackageBabel(option);
                                                                                                                                                                                                        }
                                                                                                                                                                                                    }else{
                                                                                                                                                                                                        {
                                                                                                                                                                                                            tmp___67 = streq((const char*)option, "spanish");
                                                                                                                                                                                                        }
                                                                                                                                                                                                        if (tmp___67){
                                                                                                                                                                                                            {
                                                                                                                                                                                                                setPackageBabel(option);
                                                                                                                                                                                                            }
                                                                                                                                                                                                        }else{
                                                                                                                                                                                                            {
                                                                                                                                                                                                                tmp___68 = streq((const char*)option, "swedish");
                                                                                                                                                                                                            }
                                                                                                                                                                                                            if (tmp___68){
                                                                                                                                                                                                                {
                                                                                                                                                                                                                    setPackageBabel(option);
                                                                                                                                                                                                                }
                                                                                                                                                                                                            }else{
                                                                                                                                                                                                                {
                                                                                                                                                                                                                    tmp___69 = streq((const char*)option, "turkish");
                                                                                                                                                                                                                }
                                                                                                                                                                                                                if (tmp___69){
                                                                                                                                                                                                                    {
                                                                                                                                                                                                                        setPackageBabel(option);
                                                                                                                                                                                                                    }
                                                                                                                                                                                                                }else{
                                                                                                                                                                                                                    {
                                                                                                                                                                                                                        tmp___70 = streq((const char*)option, "ukrainian");
                                                                                                                                                                                                                    }
                                                                                                                                                                                                                    if (tmp___70){
                                                                                                                                                                                                                        {
                                                                                                                                                                                                                            setPackageBabel(option);
                                                                                                                                                                                                                        }
                                                                                                                                                                                                                    }else{
                                                                                                                                                                                                                        {
                                                                                                                                                                                                                            tmp___71 = streq((const char*)option, "usorbian");
                                                                                                                                                                                                                        }
                                                                                                                                                                                                                        if (tmp___71){
                                                                                                                                                                                                                            {
                                                                                                                                                                                                                                setPackageBabel(option);
                                                                                                                                                                                                                            }
                                                                                                                                                                                                                        }else{
                                                                                                                                                                                                                            {
                                                                                                                                                                                                                                tmp___72 = streq((const char*)option, "welsh");
                                                                                                                                                                                                                            }
                                                                                                                                                                                                                            if (tmp___72){
                                                                                                                                                                                                                                {
                                                                                                                                                                                                                                    setPackageBabel(option);
                                                                                                                                                                                                                                }
                                                                                                                                                                                                                            }else{
                                                                                                                                                                                                                                {
                                                                                                                                                                                                                                    tmp___32 = strcmp((const char*)option, "twoside");
                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                if (tmp___32 == 0){
                                                                                                                                                                                                                                    g_preambleTwoside = 1;
                                                                                                                                                                                                                                }else{
                                                                                                                                                                                                                                    {
                                                                                                                                                                                                                                        tmp___31 = strcmp((const char*)option, "twocolumn");
                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                    if (tmp___31 == 0){
                                                                                                                                                                                                                                        g_preambleTwocolumn = 1;
                                                                                                                                                                                                                                    }else{
                                                                                                                                                                                                                                        {
                                                                                                                                                                                                                                            tmp___30 = strcmp((const char*)option, "titlepage");
                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                        if (tmp___30 == 0){
                                                                                                                                                                                                                                            g_preambleTitlepage = 1;
                                                                                                                                                                                                                                        }else{
                                                                                                                                                                                                                                            {
                                                                                                                                                                                                                                                tmp___29 = strcmp((const char*)option, "isolatin1");
                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                            if (tmp___29 == 0){
                                                                                                                                                                                                                                                {
                                                                                                                                                                                                                                                    setPackageInputenc((char*)"latin1");
                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                            }else{
                                                                                                                                                                                                                                                {
                                                                                                                                                                                                                                                    tmp___28 = strcmp((const char*)option, "hyperlatex");
                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                if (tmp___28 == 0){
                                                                                                                                                                                                                                                    {
                                                                                                                                                                                                                                                        PushEnvironment(10);
                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                }else{
                                                                                                                                                                                                                                                    {
                                                                                                                                                                                                                                                        tmp___27 = strcmp((const char*)option, "apalike");
                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                    if (tmp___27 == 0){
                                                                                                                                                                                                                                                        g_document_bibstyle = 2;
                                                                                                                                                                                                                                                    }else{
                                                                                                                                                                                                                                                        {
                                                                                                                                                                                                                                                            tmp___26 = strcmp((const char*)option, "apanat1b");
                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                        if (tmp___26 == 0){
                                                                                                                                                                                                                                                            {
                                                                                                                                                                                                                                                                PushEnvironment(17);
                                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                                        }else{
                                                                                                                                                                                                                                                            {
                                                                                                                                                                                                                                                                tmp___25 = strcmp((const char*)option, "endfloat");
                                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                                            if (tmp___25 == 0){
                                                                                                                                                                                                                                                                g_endfloat_figures = 1;
                                                                                                                                                                                                                                                            }else{
                                                                                                                                                                                                                                                                {
                                                                                                                                                                                                                                                                    tmp___24 = strcmp((const char*)option, "bibentry");
                                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                                if (!(tmp___24 == 0)){
                                                                                                                                                                                                                                                                    {
                                                                                                                                                                                                                                                                        tmp___23 = strcmp((const char*)option, "harvard");
                                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                                    if (tmp___23 == 0){
                                                                                                                                                                                                                                                                        {
                                                                                                                                                                                                                                                                            PushEnvironment(19);
                                                                                                                                                                                                                                                                            g_document_bibstyle = 6;
                                                                                                                                                                                                                                                                            LoadAuxFile();
                                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                                    }else{
                                                                                                                                                                                                                                                                        {
                                                                                                                                                                                                                                                                            tmp___22 = strcmp((const char*)option, "natbib");
                                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                                        if (tmp___22 == 0){
                                                                                                                                                                                                                                                                            {
                                                                                                                                                                                                                                                                                PushEnvironment(18);
                                                                                                                                                                                                                                                                                g_document_bibstyle = 4;
                                                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                                                        }else{
                                                                                                                                                                                                                                                                            {
                                                                                                                                                                                                                                                                                tmp___16 = strcmp((const char*)option, "authordate");
                                                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                                                            if (tmp___16 == 0){
                                                                                                                                                                                                                                                                                {
                                                                                                                                                                                                                                                                                    PushEnvironment(20);
                                                                                                                                                                                                                                                                                    g_document_bibstyle = 5;
                                                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                                            }else{
                                                                                                                                                                                                                                                                                {
                                                                                                                                                                                                                                                                                    tmp___17 = strcmp((const char*)option, "authordate1");
                                                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                                                if (tmp___17 == 0){
                                                                                                                                                                                                                                                                                    {
                                                                                                                                                                                                                                                                                        PushEnvironment(20);
                                                                                                                                                                                                                                                                                        g_document_bibstyle = 5;
                                                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                                                }else{
                                                                                                                                                                                                                                                                                    {
                                                                                                                                                                                                                                                                                        tmp___18 = strcmp((const char*)option, "authordate2");
                                                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                                                    if (tmp___18 == 0){
                                                                                                                                                                                                                                                                                        {
                                                                                                                                                                                                                                                                                            PushEnvironment(20);
                                                                                                                                                                                                                                                                                            g_document_bibstyle = 5;
                                                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                                                    }else{
                                                                                                                                                                                                                                                                                        {
                                                                                                                                                                                                                                                                                            tmp___19 = strcmp((const char*)option, "authordate3");
                                                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                                                        if (tmp___19 == 0){
                                                                                                                                                                                                                                                                                            {
                                                                                                                                                                                                                                                                                                PushEnvironment(20);
                                                                                                                                                                                                                                                                                                g_document_bibstyle = 5;
                                                                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                                                                        }else{
                                                                                                                                                                                                                                                                                            {
                                                                                                                                                                                                                                                                                                tmp___20 = strcmp((const char*)option, "authordate4");
                                                                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                                                                            if (tmp___20 == 0){
                                                                                                                                                                                                                                                                                                {
                                                                                                                                                                                                                                                                                                    PushEnvironment(20);
                                                                                                                                                                                                                                                                                                    g_document_bibstyle = 5;
                                                                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                                                            }else{
                                                                                                                                                                                                                                                                                                {
                                                                                                                                                                                                                                                                                                    tmp___21 = strcmp((const char*)option, "authordate1-4");
                                                                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                                                                if (tmp___21 == 0){
                                                                                                                                                                                                                                                                                                    {
                                                                                                                                                                                                                                                                                                        PushEnvironment(20);
                                                                                                                                                                                                                                                                                                        g_document_bibstyle = 5;
                                                                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                                                                }else{
                                                                                                                                                                                                                                                                                                    {
                                                                                                                                                                                                                                                                                                        tmp___14 = strcmp((const char*)option, "apacite");
                                                                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                                                                    if (tmp___14 == 0){
                                                                                                                                                                                                                                                                                                        {
                                                                                                                                                                                                                                                                                                            PushEnvironment(17);
                                                                                                                                                                                                                                                                                                            g_document_bibstyle = 3;
                                                                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                                                                    }else{
                                                                                                                                                                                                                                                                                                        {
                                                                                                                                                                                                                                                                                                            tmp___15 = strcmp((const char*)option, "apacitex");
                                                                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                                                                        if (tmp___15 == 0){
                                                                                                                                                                                                                                                                                                            {
                                                                                                                                                                                                                                                                                                                PushEnvironment(17);
                                                                                                                                                                                                                                                                                                                g_document_bibstyle = 3;
                                                                                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                                                                                        }else{
                                                                                                                                                                                                                                                                                                            {
                                                                                                                                                                                                                                                                                                                tmp___13 = strcmp((const char*)option, "hyperref");
                                                                                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                                                                                            if (tmp___13 == 0){
                                                                                                                                                                                                                                                                                                                {
                                                                                                                                                                                                                                                                                                                    PushEnvironment(26);
                                                                                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                                                                            }else{
                                                                                                                                                                                                                                                                                                                {
                                                                                                                                                                                                                                                                                                                    tmp___12 = strcmp((const char*)option, "amsmath");
                                                                                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                                                                                if (tmp___12 == 0){
                                                                                                                                                                                                                                                                                                                    {
                                                                                                                                                                                                                                                                                                                        g_amsmath_package = 1;
                                                                                                                                                                                                                                                                                                                        diagnostics(1, (char*)"Incomplete support for package/option \'%s\' ", option);
                                                                                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                                                                                }else{
                                                                                                                                                                                                                                                                                                                    {
                                                                                                                                                                                                                                                                                                                        tmp___4 = strcmp((const char*)option, "endnotes");
                                                                                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                                                                                    if (tmp___4 == 0){
                                                                                                                                                                                                                                                                                                                        {
                                                                                                                                                                                                                                                                                                                            diagnostics(1, (char*)"Incomplete support for package/option \'%s\' ", option);
                                                                                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                                                                                    }else{
                                                                                                                                                                                                                                                                                                                        {
                                                                                                                                                                                                                                                                                                                            tmp___5 = strcmp((const char*)option, "pstricks-add");
                                                                                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                                                                                        if (tmp___5 == 0){
                                                                                                                                                                                                                                                                                                                            {
                                                                                                                                                                                                                                                                                                                                diagnostics(1, (char*)"Incomplete support for package/option \'%s\' ", option);
                                                                                                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                                                                                                        }else{
                                                                                                                                                                                                                                                                                                                            {
                                                                                                                                                                                                                                                                                                                                tmp___6 = strcmp((const char*)option, "fancyhdr");
                                                                                                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                                                                                                            if (tmp___6 == 0){
                                                                                                                                                                                                                                                                                                                                {
                                                                                                                                                                                                                                                                                                                                    diagnostics(1, (char*)"Incomplete support for package/option \'%s\' ", option);
                                                                                                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                                                                                            }else{
                                                                                                                                                                                                                                                                                                                                {
                                                                                                                                                                                                                                                                                                                                    tmp___7 = strcmp((const char*)option, "html");
                                                                                                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                                                                                                if (tmp___7 == 0){
                                                                                                                                                                                                                                                                                                                                    {
                                                                                                                                                                                                                                                                                                                                        diagnostics(1, (char*)"Incomplete support for package/option \'%s\' ", option);
                                                                                                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                                                                                                }else{
                                                                                                                                                                                                                                                                                                                                    {
                                                                                                                                                                                                                                                                                                                                        tmp___8 = strcmp((const char*)option, "epsf");
                                                                                                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                                                                                                    if (tmp___8 == 0){
                                                                                                                                                                                                                                                                                                                                        {
                                                                                                                                                                                                                                                                                                                                            diagnostics(1, (char*)"Incomplete support for package/option \'%s\' ", option);
                                                                                                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                                                                                                    }else{
                                                                                                                                                                                                                                                                                                                                        {
                                                                                                                                                                                                                                                                                                                                            tmp___9 = strcmp((const char*)option, "psfig");
                                                                                                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                                                                                                        if (tmp___9 == 0){
                                                                                                                                                                                                                                                                                                                                            {
                                                                                                                                                                                                                                                                                                                                                diagnostics(1, (char*)"Incomplete support for package/option \'%s\' ", option);
                                                                                                                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                                                                                                                        }else{
                                                                                                                                                                                                                                                                                                                                            {
                                                                                                                                                                                                                                                                                                                                                tmp___10 = strcmp((const char*)option, "verbatim");
                                                                                                                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                                                                                                                            if (tmp___10 == 0){
                                                                                                                                                                                                                                                                                                                                                {
                                                                                                                                                                                                                                                                                                                                                    diagnostics(1, (char*)"Incomplete support for package/option \'%s\' ", option);
                                                                                                                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                                                                                                            }else{
                                                                                                                                                                                                                                                                                                                                                {
                                                                                                                                                                                                                                                                                                                                                    tmp___11 = strcmp((const char*)option, "paralist");
                                                                                                                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                                                                                                                if (tmp___11 == 0){
                                                                                                                                                                                                                                                                                                                                                    {
                                                                                                                                                                                                                                                                                                                                                        diagnostics(1, (char*)"Incomplete support for package/option \'%s\' ", option);
                                                                                                                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                                                                                                                }else{
                                                                                                                                                                                                                                                                                                                                                    {
                                                                                                                                                                                                                                                                                                                                                        tmp___3 = strcmp((const char*)option, "color");
                                                                                                                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                                                                                                                    if (tmp___3 == 0){
                                                                                                                                                                                                                                                                                                                                                        gColorPackage = 1;
                                                                                                                                                                                                                                                                                                                                                    }else{
                                                                                                                                                                                                                                                                                                                                                        {
                                                                                                                                                                                                                                                                                                                                                            tmp___1 = strcmp((const char*)option, "man");
                                                                                                                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                                                                                                                        if (tmp___1 == 0){
                                                                                                                                                                                                                                                                                                                                                            {
                                                                                                                                                                                                                                                                                                                                                                diagnostics(1, (char*)"ignoring [%s], assuming [doc]", option);
                                                                                                                                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                                                                                                                                        }else{
                                                                                                                                                                                                                                                                                                                                                            {
                                                                                                                                                                                                                                                                                                                                                                tmp___2 = strcmp((const char*)option, "jou");
                                                                                                                                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                                                                                                                                            if (tmp___2 == 0){
                                                                                                                                                                                                                                                                                                                                                                {
                                                                                                                                                                                                                                                                                                                                                                    diagnostics(1, (char*)"ignoring [%s], assuming [doc]", option);
                                                                                                                                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                                                                                                                            }else{
                                                                                                                                                                                                                                                                                                                                                                {
                                                                                                                                                                                                                                                                                                                                                                    tmp___0 = strcmp((const char*)option, "doc");
                                                                                                                                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                                                                                                                                if (tmp___0 == 0){
                                                                                                                                                                                                                                                                                                                                                                    {
                                                                                                                                                                                                                                                                                                                                                                        diagnostics(1, (char*)"Some support for apa class");
                                                                                                                                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                                                                                                                                }else{
                                                                                                                                                                                                                                                                                                                                                                    {
                                                                                                                                                                                                                                                                                                                                                                        tmp = strcmp((const char*)option, "ifpdf");
                                                                                                                                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                                                                                                                                    if (tmp == 0){
                                                                                                                                                                                                                                                                                                                                                                        {
                                                                                                                                                                                                                                                                                                                                                                            diagnostics(1, (char*)"Trivial support for the ifpdf package");
                                                                                                                                                                                                                                                                                                                                                                            ConvertString("\\newif\\ifpdf");
                                                                                                                                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                                                                                                                                    }else{
                                                                                                                                                                                                                                                                                                                                                                        {
                                                                                                                                                                                                                                                                                                                                                                            diagnostics(1, (char*)"Package/option \'%s\' unknown.", option);
                                                                                                                                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                }
                                                                                                                                                                                                                            }
                                                                                                                                                                                                                        }
                                                                                                                                                                                                                    }
                                                                                                                                                                                                                }
                                                                                                                                                                                                            }
                                                                                                                                                                                                        }
                                                                                                                                                                                                    }
                                                                                                                                                                                                }
                                                                                                                                                                                            }
                                                                                                                                                                                        }
                                                                                                                                                                                    }
                                                                                                                                                                                }
                                                                                                                                                                            }
                                                                                                                                                                        }
                                                                                                                                                                    }
                                                                                                                                                                }
                                                                                                                                                            }
                                                                                                                                                        }
                                                                                                                                                    }
                                                                                                                                                }
                                                                                                                                            }
                                                                                                                                        }
                                                                                                                                    }
                                                                                                                                }
                                                                                                                            }
                                                                                                                        }
                                                                                                                    }
                                                                                                                }
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                {
                    option = strtok((char*)((void*)0), (const char*)",");
                }
            }
            while_break:
            ;
        }
        return;
    }
}

void CmdDocumentStyle(int code)
{
    char* format;
    char* format_with_spaces;
    char* options;
    char* options_with_spaces;
    int tmp;
    int tmp___0;
    int tmp___1;
    int tmp___2;
    int tmp___3;
    int tmp___4;
    {
        {
            options_with_spaces = getBracketParam();
            format_with_spaces = getBraceParam();
            format = strdup_noblanks((const char*)format_with_spaces);
            free((void*)format_with_spaces);
        }
        if (options_with_spaces){
            {
                diagnostics(4, (char*)"Documentstyle/class[%s]{%s}", options_with_spaces, format);
            }
        }else{
            {
                diagnostics(4, (char*)"Documentstyle/class{%s}", format);
            }
        }
        {
            g_document_type = 1;
            tmp___4 = strcmp((const char*)format, "book");
        }
        if (tmp___4 == 0){
            g_document_type = 3;
        }else{
            {
                tmp___3 = strcmp((const char*)format, "report");
            }
            if (tmp___3 == 0){
                g_document_type = 2;
            }else{
                {
                    tmp___2 = strcmp((const char*)format, "letter");
                }
                if (tmp___2 == 0){
                    g_document_type = 5;
                }else{
                    {
                        tmp___1 = strcmp((const char*)format, "article");
                    }
                    if (tmp___1 == 0){
                        g_document_type = 1;
                    }else{
                        {
                            tmp___0 = strcmp((const char*)format, "slides");
                        }
                        if (tmp___0 == 0){
                            g_document_type = 4;
                        }else{
                            {
                                tmp = strcmp((const char*)format, "apa");
                            }
                            if (tmp == 0){
                                {
                                    g_document_type = 6;
                                    g_document_bibstyle = 3;
                                    PushEnvironment(17);
                                    diagnostics(1, (char*)"Meager support for \\documentclass{apa}");
                                }
                            }else{
                                {
                                    diagnostics(1, (char*)"Document format <%s> unknown, using article format", format);
                                }
                            }
                        }
                    }
                }
            }
        }
        if (options_with_spaces){
            {
                options = strdup_noblanks((const char*)options_with_spaces);
                free((void*)options_with_spaces);
                setDocumentOptions(options);
                free((void*)options);
            }
        }
        {
            free((void*)format);
        }
        return;
    }
}

static void CmdUseOnepackage(char* package, char* options)
{
    int tmp;
    char* tmp___0;
    char* tmp___1;
    char* tmp___2;
    char* tmp___3;
    char* tmp___4;
    char* tmp___5;
    char* tmp___6;
    char* tmp___7;
    char* tmp___8;
    char* tmp___9;
    char* tmp___10;
    int tmp___11;
    int tmp___12;
    int tmp___13;
    int tmp___14;
    int tmp___15;
    int tmp___16;
    int tmp___17;
    int tmp___18;
    int tmp___19;
    int tmp___20;
    int tmp___21;
    int tmp___22;
    int tmp___23;
    int tmp___24;
    int tmp___25;
    int tmp___26;
    int tmp___27;
    char* tmp___28;
    char* tmp___29;
    char* tmp___30;
    int tmp___31;
    int tmp___32;
    int tmp___33;
    int tmp___34;
    int tmp___35;
    int tmp___36;
    int tmp___37;
    int tmp___38;
    int tmp___39;
    int tmp___40;
    int tmp___41;
    {
        {
            diagnostics(2, (char*)"CmdUseOnepackage \\usepackage[%s]{%s}", options, package);
            tmp = TryPackageIgnore((const char*)package);
        }
        if (tmp == 1){
            return;
        }
        {
            tmp___41 = strcmp((const char*)package, "inputenc");
        }
        if (tmp___41 == 0){
            if (options){
                {
                    setPackageInputenc(options);
                }
            }else{
                goto _L;
            }
        }else{
            _L:
            {
                tmp___40 = strcmp((const char*)package, "graphics");
            }
            if (tmp___40 == 0){
                g_graphics_package = 1;
            }else{
                {
                    tmp___39 = strcmp((const char*)package, "graphicx");
                }
                if (tmp___39 == 0){
                    g_graphics_package = 2;
                }else{
                    {
                        tmp___38 = strcmp((const char*)package, "isolatin1");
                    }
                    if (tmp___38 == 0){
                        {
                            setPackageInputenc((char*)"latin1");
                        }
                    }else{
                        {
                            tmp___37 = strcmp((const char*)package, "spanish");
                        }
                        if (tmp___37 == 0){
                            {
                                setPackageBabel(package);
                            }
                        }else{
                            {
                                tmp___36 = strcmp((const char*)package, "babel");
                            }
                            if (tmp___36 == 0){
                                if (options){
                                    if (*options){
                                        {
                                            setPackageBabel(options);
                                        }
                                    }
                                }
                            }else{
                                {
                                    tmp___31 = strcmp((const char*)package, "german");
                                }
                                if (tmp___31 == 0){
                                    {
                                        setPackageBabel(package);
                                    }
                                }else{
                                    {
                                        tmp___32 = strcmp((const char*)package, "ngerman");
                                    }
                                    if (tmp___32 == 0){
                                        {
                                            setPackageBabel(package);
                                        }
                                    }else{
                                        {
                                            tmp___33 = strcmp((const char*)package, "czech");
                                        }
                                        if (tmp___33 == 0){
                                            {
                                                setPackageBabel(package);
                                            }
                                        }else{
                                            {
                                                tmp___34 = strcmp((const char*)package, "frenchb");
                                            }
                                            if (tmp___34 == 0){
                                                {
                                                    setPackageBabel(package);
                                                }
                                            }else{
                                                {
                                                    tmp___35 = strcmp((const char*)package, "french");
                                                }
                                                if (tmp___35 == 0){
                                                    {
                                                        setPackageBabel(package);
                                                    }
                                                }else{
                                                    {
                                                        tmp___23 = strcmp((const char*)package, "palatino");
                                                    }
                                                    if (tmp___23 == 0){
                                                        {
                                                            setPackageFont(package);
                                                        }
                                                    }else{
                                                        {
                                                            tmp___24 = strcmp((const char*)package, "times");
                                                        }
                                                        if (tmp___24 == 0){
                                                            {
                                                                setPackageFont(package);
                                                            }
                                                        }else{
                                                            {
                                                                tmp___25 = strcmp((const char*)package, "bookman");
                                                            }
                                                            if (tmp___25 == 0){
                                                                {
                                                                    setPackageFont(package);
                                                                }
                                                            }else{
                                                                {
                                                                    tmp___26 = strcmp((const char*)package, "chancery");
                                                                }
                                                                if (tmp___26 == 0){
                                                                    {
                                                                        setPackageFont(package);
                                                                    }
                                                                }else{
                                                                    {
                                                                        tmp___27 = strcmp((const char*)package, "courier");
                                                                    }
                                                                    if (tmp___27 == 0){
                                                                        {
                                                                            setPackageFont(package);
                                                                        }
                                                                    }else{
                                                                        {
                                                                            tmp___28 = strstr((const char*)package, "avant");
                                                                        }
                                                                        if (tmp___28){
                                                                            {
                                                                                setPackageFont(package);
                                                                            }
                                                                        }else{
                                                                            {
                                                                                tmp___29 = strstr((const char*)package, "newcen");
                                                                            }
                                                                            if (tmp___29){
                                                                                {
                                                                                    setPackageFont(package);
                                                                                }
                                                                            }else{
                                                                                {
                                                                                    tmp___30 = strstr((const char*)package, "helvet");
                                                                                }
                                                                                if (tmp___30){
                                                                                    {
                                                                                        setPackageFont(package);
                                                                                    }
                                                                                }else{
                                                                                    {
                                                                                        tmp___22 = strcmp((const char*)package, "endfloat");
                                                                                    }
                                                                                    if (tmp___22 == 0){
                                                                                        g_endfloat_figures = 1;
                                                                                        g_endfloat_tables = 1;
                                                                                        if (options){
                                                                                            {
                                                                                                tmp___0 = strstr((const char*)options, "nomarkers");
                                                                                            }
                                                                                            if (tmp___0){
                                                                                                g_endfloat_markers = 0;
                                                                                            }
                                                                                        }
                                                                                    }else{
                                                                                        {
                                                                                            tmp___21 = strcmp((const char*)package, "cite");
                                                                                        }
                                                                                        if (tmp___21 == 0){
                                                                                            {
                                                                                                set_sorted_citations();
                                                                                                set_compressed_citations();
                                                                                            }
                                                                                        }else{
                                                                                            {
                                                                                                tmp___20 = strcmp((const char*)package, "subfigure");
                                                                                            }
                                                                                            if (tmp___20 == 0){
                                                                                                {
                                                                                                    diagnostics(1, (char*)"partial support for subfigure package");
                                                                                                }
                                                                                            }else{
                                                                                                {
                                                                                                    tmp___19 = strcmp((const char*)package, "natbib");
                                                                                                }
                                                                                                if (tmp___19 == 0){
                                                                                                    if (options){
                                                                                                        {
                                                                                                            tmp___1 = strstr((const char*)options, "longnamesfirst");
                                                                                                        }
                                                                                                        if (tmp___1){
                                                                                                            {
                                                                                                                set_longnamesfirst();
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                    if (options){
                                                                                                        {
                                                                                                            tmp___2 = strstr((const char*)options, "super");
                                                                                                        }
                                                                                                        if (tmp___2){
                                                                                                            {
                                                                                                                set_bibpunct_style_super();
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                    if (options){
                                                                                                        {
                                                                                                            tmp___3 = strstr((const char*)options, "comma");
                                                                                                        }
                                                                                                        if (tmp___3){
                                                                                                            {
                                                                                                                set_bibpunct_style_separator((char*)",");
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                    if (options){
                                                                                                        {
                                                                                                            tmp___4 = strstr((const char*)options, "colon");
                                                                                                        }
                                                                                                        if (tmp___4){
                                                                                                            {
                                                                                                                set_bibpunct_style_separator((char*)":");
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                    if (options){
                                                                                                        {
                                                                                                            tmp___5 = strstr((const char*)options, "round");
                                                                                                        }
                                                                                                        if (tmp___5){
                                                                                                            {
                                                                                                                set_bibpunct_style_paren((char*)"(", (char*)")");
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                    if (options){
                                                                                                        {
                                                                                                            tmp___6 = strstr((const char*)options, "square");
                                                                                                        }
                                                                                                        if (tmp___6){
                                                                                                            {
                                                                                                                set_bibpunct_style_paren((char*)"[", (char*)"]");
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                    if (options){
                                                                                                        {
                                                                                                            tmp___7 = strstr((const char*)options, "curly");
                                                                                                        }
                                                                                                        if (tmp___7){
                                                                                                            {
                                                                                                                set_bibpunct_style_paren((char*)"{", (char*)"}");
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                    if (options){
                                                                                                        {
                                                                                                            tmp___8 = strstr((const char*)options, "angle");
                                                                                                        }
                                                                                                        if (tmp___8){
                                                                                                            {
                                                                                                                set_bibpunct_style_paren((char*)"<", (char*)">");
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                    if (options){
                                                                                                        {
                                                                                                            tmp___9 = strstr((const char*)options, "sort");
                                                                                                        }
                                                                                                        if (tmp___9){
                                                                                                            {
                                                                                                                set_sorted_citations();
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                    if (options){
                                                                                                        {
                                                                                                            tmp___10 = strstr((const char*)options, "compress");
                                                                                                        }
                                                                                                        if (tmp___10){
                                                                                                            {
                                                                                                                set_compressed_citations();
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                    {
                                                                                                        PushEnvironment(18);
                                                                                                        g_document_bibstyle = 4;
                                                                                                    }
                                                                                                }else{
                                                                                                    {
                                                                                                        tmp___18 = strcmp((const char*)package, "geometry");
                                                                                                    }
                                                                                                    if (tmp___18 == 0){
                                                                                                        g_preambleGeometry = 1;
                                                                                                        if (g_preambleTwoside == 0){
                                                                                                            {
                                                                                                                tmp___11 = getLength((char*)"pagewidth");
                                                                                                                g_geomMargr = (int)((double)tmp___11 * 0.15);
                                                                                                                g_geomMargl = g_geomMargr;
                                                                                                            }
                                                                                                        }else{
                                                                                                            {
                                                                                                                tmp___12 = getLength((char*)"pagewidth");
                                                                                                                g_geomMargr = (int)(((double)tmp___12 * 0.3) * 0.4);
                                                                                                                tmp___13 = getLength((char*)"pagewidth");
                                                                                                                g_geomMargl = (int)(((double)tmp___13 * 0.3) * 0.6);
                                                                                                            }
                                                                                                        }
                                                                                                        {
                                                                                                            tmp___14 = getLength((char*)"pageheight");
                                                                                                            g_geomMargt = (int)(((double)tmp___14 * 0.3) * 0.4);
                                                                                                            tmp___15 = getLength((char*)"pageheight");
                                                                                                            g_geomMargb = (int)(((double)tmp___15 * 0.3) * 0.6);
                                                                                                        }
                                                                                                        if (options){
                                                                                                            {
                                                                                                                ParseOptGeometry(options);
                                                                                                            }
                                                                                                        }
                                                                                                    }else{
                                                                                                        {
                                                                                                            tmp___17 = strcmp((const char*)package, "acronym");
                                                                                                        }
                                                                                                        if (tmp___17 == 0){
                                                                                                            {
                                                                                                                UsePackageAcronym(options);
                                                                                                            }
                                                                                                        }else{
                                                                                                            {
                                                                                                                tmp___16 = strcmp((const char*)package, "ifpdf");
                                                                                                            }
                                                                                                            if (tmp___16 == 0){
                                                                                                                {
                                                                                                                    ConvertString("\\newif\\ifpdf");
                                                                                                                }
                                                                                                            }else{
                                                                                                                {
                                                                                                                    setDocumentOptions(package);
                                                                                                                }
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        return;
    }
}

void CmdGeometry(int code)
{
    char* options;
    {
        {
            options = getBraceParam();
        }
        if (options){
            {
                diagnostics(2, (char*)"geometry command, argument %s\n", options);
                ParseOptGeometry(options);
                free((void*)options);
            }
        }
        return;
    }
}

void ParseOptGeometry(char* options)
{
    char* key;
    char* value1;
    char* value2;
    char* next;
    char* comma;
    char* colon;
    char* tmp;
    {
        comma = (char*)", ";
        colon = (char*)": ";
        {
            while (1){
                while_continue:
                ;
                if (!options){
                    goto while_break;
                }
                {
                    next = keyvalue_pair(options, &key, &value1);
                }
                if ((unsigned long )value1 == (unsigned long )((void*)0)){
                    {
                        diagnostics(2, (char*)"geometry package, single option=[%s]", key);
                        ExecGeomOptions(key, (char*)((void*)0), (char*)((void*)0));
                    }
                }else
                    if ((int)*value1 == 123){
                        {
                            PushSource((const char*)((void*)0), (const char*)value1);
                            free((void*)value1);
                            value1 = getBraceParam();
                            PopSource();
                            value1 = strtok((char*)value1, (const char*)comma);
                            value2 = strtok((char*)((void*)0), (const char*)comma);
                            diagnostics(2, (char*)"option=%s with values %s and %s", key, value1, value2);
                            ExecGeomOptions(key, value1, value2);
                            free((void*)value1);
                        }
                    }else{
                        {
                            tmp = strchr((const char*)value1, ':');
                        }
                        if (tmp){
                            {
                                value1 = strtok((char*)value1, (const char*)colon);
                                value2 = strtok((char*)((void*)0), (const char*)colon);
                                diagnostics(2, (char*)"option=%s with ratio \'%s:%s\'", key, value1, value2);
                                ExecGeomOptions(key, value1, value2);
                                free((void*)value1);
                            }
                        }else{
                            {
                                diagnostics(2, (char*)"geometry package, option=[%s], value=%s", key, value1);
                                value2 = value1;
                                ExecGeomOptions(key, value1, value2);
                                free((void*)value1);
                            }
                        }
                    }

                if (key){
                    {
                        free((void*)key);
                    }
                }
                options = next;
            }
            while_break:
            ;
        }
        return;
    }
}

void ExecGeomOptions(char* key, char* value1, char* value2)
{
    int ratio_sum;
    int margin_sum;
    char* value1b;
    char* value2b;
    int dist1;
    int dist2;
    char* tmp;
    char* tmp___0;
    char* tmp___1;
    int tmp___2;
    int tmp___3;
    int tmp___4;
    int tmp___5;
    int tmp___6;
    int tmp___7;
    int tmp___8;
    int tmp___9;
    int tmp___10;
    int tmp___11;
    int tmp___12;
    int tmp___13;
    int tmp___14;
    int tmp___15;
    int tmp___16;
    int tmp___17;
    int tmp___18;
    int tmp___19;
    int tmp___20;
    int tmp___21;
    {
        {
            value1b = (char*)((void*)0);
            value2b = (char*)((void*)0);
            dist1 = 0;
            dist2 = 0;
            tmp___1 = strstr((const char*)key, "ratio");
        }
        if (tmp___1){
            {
                tmp = strchr((const char*)value1, ':');
            }
            if (tmp){
                {
                    value1 = strtok((char*)value1, (const char*)": ");
                    value1b = strtok((char*)((void*)0), (const char*)": ");
                    value2 = strtok((char*)value2, (const char*)": ");
                    value2b = strtok((char*)((void*)0), (const char*)": ");
                }
            }else{
                {
                    dist1 = atoi((const char*)value1);
                    dist2 = atoi((const char*)value2);
                    diagnostics(3, (char*)"one ratio parameter, %d:%d", dist1, dist2);
                }
            }
        }else{
            {
                tmp___0 = strstr((const char*)key, "centering");
            }
            if ((unsigned long )tmp___0 == (unsigned long )((void*)0)){
                {
                    dist1 = getStringDimension(value1);
                    dist2 = getStringDimension(value2);
                    diagnostics(3, (char*)"twips parameters, %d and %d", dist1, dist2);
                }
            }
        }
        {
            tmp___21 = strcmp((const char*)key, "vmargin");
        }
        if (tmp___21 == 0){
            {
                diagnostics(3, (char*)"vmargin distance(top)=%d, distance (bottom)=%d twips", dist1, dist2);
                g_geomMargt = dist1;
                g_geomMargb = dist2;
            }
        }else{
            {
                tmp___20 = strcmp((const char*)key, "hmargin");
            }
            if (tmp___20 == 0){
                {
                    diagnostics(3, (char*)"hmargin distance(left)=%d, distance (right)=%d twips", dist1, dist2);
                    g_geomMargl = dist1;
                    g_geomMargr = dist2;
                }
            }else{
                {
                    tmp___19 = strcmp((const char*)key, "margin");
                }
                if (tmp___19 == 0){
                    {
                        ExecGeomOptions((char*)"hmargin", value1, value2);
                        ExecGeomOptions((char*)"vmargin", value1, value2);
                    }
                }else{
                    {
                        tmp___16 = strcmp((const char*)key, "left");
                    }
                    if (tmp___16 == 0){
                        g_geomMargl = dist1;
                    }else{
                        {
                            tmp___17 = strcmp((const char*)key, "lmargin");
                        }
                        if (tmp___17 == 0){
                            g_geomMargl = dist1;
                        }else{
                            {
                                tmp___18 = strcmp((const char*)key, "inner");
                            }
                            if (tmp___18 == 0){
                                g_geomMargl = dist1;
                            }else{
                                {
                                    tmp___13 = strcmp((const char*)key, "right");
                                }
                                if (tmp___13 == 0){
                                    g_geomMargr = dist1;
                                }else{
                                    {
                                        tmp___14 = strcmp((const char*)key, "rmargin");
                                    }
                                    if (tmp___14 == 0){
                                        g_geomMargr = dist1;
                                    }else{
                                        {
                                            tmp___15 = strcmp((const char*)key, "outer");
                                        }
                                        if (tmp___15 == 0){
                                            g_geomMargr = dist1;
                                        }else{
                                            {
                                                tmp___11 = strcmp((const char*)key, "top");
                                            }
                                            if (tmp___11 == 0){
                                                g_geomMargt = dist1;
                                            }else{
                                                {
                                                    tmp___12 = strcmp((const char*)key, "tmargin");
                                                }
                                                if (tmp___12 == 0){
                                                    g_geomMargt = dist1;
                                                }else{
                                                    {
                                                        tmp___9 = strcmp((const char*)key, "bottom");
                                                    }
                                                    if (tmp___9 == 0){
                                                        g_geomMargb = dist1;
                                                    }else{
                                                        {
                                                            tmp___10 = strcmp((const char*)key, "bmargin");
                                                        }
                                                        if (tmp___10 == 0){
                                                            g_geomMargb = dist1;
                                                        }else{
                                                            {
                                                                tmp___8 = strcmp((const char*)key, "hmarginratio");
                                                            }
                                                            if (tmp___8 == 0){
                                                                {
                                                                    ratio_sum = dist1 + dist2;
                                                                    margin_sum = g_geomMargl + g_geomMargr;
                                                                    g_geomMargl = (int)(((float)dist1 / (float)ratio_sum) * (float)margin_sum);
                                                                    diagnostics(3, (char*)"g_geomMargl %d", g_geomMargl);
                                                                    g_geomMargr = (int)(((float)dist2 / (float)ratio_sum) * (float)margin_sum);
                                                                    diagnostics(3, (char*)"g_geomMargr %d", g_geomMargr);
                                                                }
                                                            }else{
                                                                {
                                                                    tmp___7 = strcmp((const char*)key, "vmarginratio");
                                                                }
                                                                if (tmp___7 == 0){
                                                                    ratio_sum = dist1 + dist2;
                                                                    margin_sum = g_geomMargt + g_geomMargb;
                                                                    g_geomMargt = (int)(((float)dist1 / (float)ratio_sum) * (float)margin_sum);
                                                                    g_geomMargb = (int)(((float)dist2 / (float)ratio_sum) * (float)margin_sum);
                                                                }else{
                                                                    {
                                                                        tmp___5 = strcmp((const char*)key, "marginratio");
                                                                    }
                                                                    if (tmp___5 == 0){
                                                                        {
                                                                            ExecGeomOptions((char*)"hmarginratio", value1, value1b);
                                                                            ExecGeomOptions((char*)"vmarginratio", value2, value2b);
                                                                        }
                                                                    }else{
                                                                        {
                                                                            tmp___6 = strcmp((const char*)key, "ratio");
                                                                        }
                                                                        if (tmp___6 == 0){
                                                                            {
                                                                                ExecGeomOptions((char*)"hmarginratio", value1, value1b);
                                                                                ExecGeomOptions((char*)"vmarginratio", value2, value2b);
                                                                            }
                                                                        }else{
                                                                            {
                                                                                tmp___4 = strcmp((const char*)key, "hcentering");
                                                                            }
                                                                            if (tmp___4 == 0){
                                                                                {
                                                                                    ExecGeomOptions((char*)"hmarginratio", (char*)"1", (char*)"1");
                                                                                }
                                                                            }else{
                                                                                {
                                                                                    tmp___3 = strcmp((const char*)key, "vcentering");
                                                                                }
                                                                                if (tmp___3 == 0){
                                                                                    {
                                                                                        ExecGeomOptions((char*)"vmarginratio", (char*)"1", (char*)"1");
                                                                                    }
                                                                                }else{
                                                                                    {
                                                                                        tmp___2 = strcmp((const char*)key, "centering");
                                                                                    }
                                                                                    if (tmp___2 == 0){
                                                                                        {
                                                                                            ExecGeomOptions((char*)"vmarginratio", (char*)"1", (char*)"1");
                                                                                            ExecGeomOptions((char*)"hmarginratio", (char*)"1", (char*)"1");
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        return;
    }
}

void CmdUsepackage(int code)
{
    char* package;
    char* package_with_spaces;
    char* options;
    char* options_with_spaces;
    char* p;
    char* comma;
    {
        {
            options = (char*)((void*)0);
            options_with_spaces = getBracketParam();
            package_with_spaces = getBraceParam();
            package = strdup_noblanks((const char*)package_with_spaces);
            free((void*)package_with_spaces);
        }
        if (options_with_spaces){
            {
                options = strdup_noblanks((const char*)options_with_spaces);
                free((void*)options_with_spaces);
                diagnostics(2, (char*)"Package {%s} with options [%s]", package, options);
            }
        }else{
            {
                diagnostics(2, (char*)"Package {%s} with no options", package);
            }
        }
        p = package;
        {
            while (1){
                while_continue:
                ;
                {
                    comma = strchr((const char*)p, ',');
                }
                if (comma){
                    *comma = (char)'\000';
                }
                {
                    CmdUseOnepackage(p, options);
                }
                if (comma){
                    p = comma + 1;
                }
                if (!((unsigned long )comma != (unsigned long )((void*)0))){
                    goto while_break;
                }
            }
            while_break:
            ;
        }
        if (options){
            {
                free((void*)options);
            }
        }
        {
            free((void*)package);
        }
        return;
    }
}

void CmdTitle(int code)
{
    {
        {
            if (code == 1){
                goto case_1;
            }
            if (code == 2){
                goto case_2;
            }
            if (code == 3){
                goto case_3;
            }
            if (code == 5){
                goto case_5;
            }
            if (code == 6){
                goto case_6;
            }
            if (code == 7){
                goto case_7;
            }
            if (code == 4){
                goto case_4;
            }
            goto switch_break;
            case_1:
            {
                g_preambleTitle = getBraceParam();
                UpdateLineNumber(g_preambleTitle);
            }
            goto switch_break;
            case_2:
            {
                g_preambleAuthor = getBraceParam();
                UpdateLineNumber(g_preambleAuthor);
            }
            goto switch_break;
            case_3:
            {
                g_preambleDate = getBraceParam();
                UpdateLineNumber(g_preambleDate);
            }
            goto switch_break;
            case_5:
            {
                g_preambleAffiliation = getBraceParam();
                UpdateLineNumber(g_preambleAffiliation);
            }
            goto switch_break;
            case_6:
            {
                g_preambleAbstract = getBraceParam();
                UpdateLineNumber(g_preambleAbstract);
            }
            goto switch_break;
            case_7:
            {
                g_preambleAck = getBraceParam();
                UpdateLineNumber(g_preambleAck);
            }
            goto switch_break;
            case_4:
            g_preambleTitlepage = 1;
            goto switch_break;
            switch_break:
            ;
        }
        return;
    }
}

void CmdTableOfContents(int code)
{
    {
        {
            startParagraph("contents", 3);
            fprintRTF((char*)" ");
            ConvertBabelName((char*)"CONTENTSNAME");
            CmdEndParagraph(0);
            g_tableofcontents = 1;
            startParagraph("Normal", 2);
            CmdVspace(1);
            fprintRTF((char*)"{\\field{\\*\\fldinst TOC \\\\o \"1-3\" }{\\fldrslt }}\n");
            CmdNewPage(1);
            CmdEndParagraph(0);
        }
        return;
    }
}

void CmdAnd(int code)
{
    {
        {
            startParagraph("author", 2);
        }
        return;
    }
}

void CmdMakeTitle(int code)
{
    char title_begin[10];
    char author_begin[10];
    char date_begin[10];
    int tmp;
    int tmp___0;
    int tmp___1;
    int tmp___2;
    int tmp___3;
    int tmp___4;
    int tmp___5;
    int tmp___6;
    char* s;
    char* tmp___7;
    int tmp___8;
    {
        {
            diagnostics(4, (char*)"CmdMakeTitle with  title =\'%s\'", g_preambleTitle);
            diagnostics(4, (char*)"CmdMakeTitle with author =\'%s\'", g_preambleAuthor);
            PushTrackLineNumber(0);
            tmp = CurrentFontSize();
            snprintf((char*)(title_begin), (size_t)10, (const char*)"%s%2d", "\\fs", (30 * tmp) / 20);
            tmp___0 = CurrentFontSize();
            snprintf((char*)(author_begin), (size_t)10, (const char*)"%s%2d", "\\fs", (24 * tmp___0) / 20);
            tmp___1 = CurrentFontSize();
            snprintf((char*)(date_begin), (size_t)10, (const char*)"%s%2d", "\\fs", (24 * tmp___1) / 20);
            setAlignment('c');
        }
        if ((unsigned long )g_preambleTitle != (unsigned long )((void*)0)){
            {
                tmp___2 = strcmp((const char*)g_preambleTitle, "");
            }
            if (tmp___2 != 0){
                {
                    startParagraph("title", 2);
                    ConvertString((const char*)g_preambleTitle);
                }
            }
        }
        if ((unsigned long )g_preambleAuthor != (unsigned long )((void*)0)){
            {
                tmp___3 = strcmp((const char*)g_preambleAuthor, "");
            }
            if (tmp___3 != 0){
                {
                    startParagraph("author", 2);
                    ConvertString((const char*)g_preambleAuthor);
                }
            }
        }
        if ((unsigned long )g_preambleAffiliation != (unsigned long )((void*)0)){
            {
                tmp___4 = strcmp((const char*)g_preambleAffiliation, "");
            }
            if (tmp___4 != 0){
                {
                    startParagraph("author", 2);
                    ConvertString((const char*)g_preambleAffiliation);
                }
            }
        }
        {
            startParagraph("author", 2);
        }
        if ((unsigned long )g_preambleDate == (unsigned long )((void*)0)){
            {
                fprintRTF((char*)"\\chdate ");
            }
        }else{
            {
                tmp___5 = strcmp((const char*)g_preambleDate, "");
            }
            if (tmp___5 == 0){
                {
                    fprintRTF((char*)"\\chdate ");
                }
            }else{
                {
                    ConvertString((const char*)g_preambleDate);
                }
            }
        }
        if ((unsigned long )g_preambleAck != (unsigned long )((void*)0)){
            {
                tmp___6 = strcmp((const char*)g_preambleAck, "");
            }
            if (tmp___6 != 0){
                {
                    startParagraph("author", 2);
                    ConvertString((const char*)g_preambleAck);
                }
            }
        }
        {
            CmdEndParagraph(0);
            setAlignment('j');
        }
        if ((unsigned long )g_preambleAbstract != (unsigned long )((void*)0)){
            {
                tmp___8 = strcmp((const char*)g_preambleAbstract, "");
            }
            if (tmp___8 != 0){
                {
                    tmp___7 = strdup_together3("{", (const char*)g_preambleAbstract, "}");
                    s = tmp___7;
                    CmdAbstract(3);
                    ConvertString("\\noindent");
                    ConvertString((const char*)s);
                    CmdAbstract(4);
                    free((void*)s);
                }
            }
        }
        if (g_preambleTitlepage){
            {
                fprintRTF((char*)"\\page ");
            }
        }
        if (g_document_type == 6){
            {
                startParagraph("Normal", 1);
            }
        }
        {
            PopTrackLineNumber();
        }
        return;
    }
}

void CmdPreambleBeginEnd(int code)
{
    char* cParam;
    char* tmp;
    int tmp___0;
    {
        {
            tmp = getBraceParam();
            cParam = tmp;
            tmp___0 = strcmp((const char*)cParam, "document");
        }
        if (tmp___0){
            {
                diagnostics(0, (char*)"\\begin{%s} found before \\begin{document}.  Giving up.  Sorry", cParam);
            }
        }
        {
            CallParamFunc(cParam, 16384);
            free((void*)cParam);
        }
        return;
    }
}

void PlainPagestyle(void)
{
    int fn;
    int tmp;
    {
        {
            tmp = DefaultFontFamily();
            fn = tmp;
            pagenumbering = 1;
        }
        if (g_preambleTwoside){
            {
                fprintRTF((char*)"\n{\\footerr");
                fprintRTF((char*)"\\pard\\plain\\f%d\\qc", fn);
                fprintRTF((char*)"{\\field{\\*\\fldinst PAGE}{\\fldrslt ?}}\\par}");
                fprintRTF((char*)"\n{\\footerl");
                fprintRTF((char*)"\\pard\\plain\\f%d\\qc", fn);
                fprintRTF((char*)"{\\field{\\*\\fldinst PAGE}{\\fldrslt ?}}\\par}");
            }
        }else{
            {
                fprintRTF((char*)"\n{\\footer");
                fprintRTF((char*)"\\pard\\plain\\f%d\\qc", fn);
                fprintRTF((char*)"{\\field{\\*\\fldinst PAGE}{\\fldrslt ?}}\\par}");
            }
        }
        return;
    }
}

static char* style = (char*)"";

void CmdPagestyle(int code)
{
    int tmp;
    int tmp___0;
    int tmp___1;
    int tmp___2;
    {
        {
            style = getBraceParam();
            tmp___2 = strcmp((const char*)style, "empty");
        }
        if (tmp___2 == 0){
            if (pagenumbering){
                {
                    fprintRTF((char*)"{\\footer}");
                    pagenumbering = 0;
                }
            }
        }else{
            {
                tmp___1 = strcmp((const char*)style, "plain");
            }
            if (tmp___1 == 0){
                {
                    PlainPagestyle();
                }
            }else{
                {
                    tmp___0 = strcmp((const char*)style, "headings");
                }
                if (tmp___0 == 0){
                    headings = 1;
                }else{
                    {
                        tmp = strcmp((const char*)style, "myheadings");
                    }
                    if (tmp == 0){
                        headings = 1;
                    }else{
                        {
                            diagnostics(1, (char*)"\\pagestyle{%s} unknown", style);
                        }
                    }
                }
            }
        }
        return;
    }
}

void CmdHeader(int code)
{
    {
        if (code == 348){
            if (g_preambleTwoside){
                {
                    RtfHeader(349, (char*)((void*)0));
                    RtfHeader(347, (char*)((void*)0));
                }
            }else{
                {
                    diagnostics(1, (char*)"\\markboth used in onesided documentstyle");
                }
            }
        }else{
            {
                RtfHeader(348, (char*)((void*)0));
            }
        }
        return;
    }
}

void CmdThePage(int code)
{
    {
        {
            diagnostics(4, (char*)"CmdThePage");
            fprintRTF((char*)"\\chpgn ");
        }
        return;
    }
}

void RtfHeader(int where, char* what)
{
    int fn;
    int tmp;
    {
        {
            tmp = TexFontNumber("Roman");
            fn = tmp;
        }
        {
            if (where == 347){
                goto case_347;
            }
            if (where == 349){
                goto case_349;
            }
            if (where == 348){
                goto case_348;
            }
            goto switch_default;
            case_347:
            {
                fprintRTF((char*)"\n{\\headerr \\pard\\plain\\f%d ", fn);
            }
            goto switch_break;
            case_349:
            {
                fprintRTF((char*)"\n{\\headerl \\pard\\plain\\f%d ", fn);
            }
            goto switch_break;
            case_348:
            {
                fprintRTF((char*)"\n{\\header \\pard\\plain\\f%d ", fn);
            }
            goto switch_break;
            switch_default:
            {
                diagnostics(0, (char*)"\n error -> called RtfHeader with illegal parameter\n ");
            }
            switch_break:
            ;
        }
        if ((unsigned long )what == (unsigned long )((void*)0)){
            {
                diagnostics(4, (char*)"Entering Convert() from RtfHeader");
                Convert();
                diagnostics(4, (char*)"Exiting Convert() from RtfHeader");
                fprintRTF((char*)"}");
            }
        }else{
            {
                fprintRTF((char*)"%s}", what);
            }
        }
        return;
    }
}

void CmdHyphenation(int code)
{
    char* hyphenparameter;
    char* tmp;
    {
        {
            tmp = getBraceParam();
            hyphenparameter = tmp;
            free((void*)hyphenparameter);
        }
        return;
    }
}

static void WriteFontHeader(void)
{
    int num;
    ConfigEntryT** config_handle;
    char* font_name;
    {
        {
            num = 0;
            fprintRTF((char*)"{\\fonttbl");
            config_handle = CfgStartIterate();
        }
        {
            while (1){
                while_continue:
                ;
                {
                    config_handle = CfgNextByInsertion(1, config_handle);
                }
                if (!((unsigned long )config_handle != (unsigned long )((void*)0))){
                    goto while_break;
                }
                {
                    font_name = (char*)(*config_handle)->RtfCommand;
                    fprintRTF((char*)"{\\f%d\\fnil\\fcharset0 %s;}\n", num, font_name);
                    num++;
                }
            }
            while_break:
            ;
        }
        {
            fprintRTF((char*)"}\n");
        }
        return;
    }
}

static void WriteStyleHeader(void)
{
    ConfigEntryT** style___0;
    const char* rtf;
    {
        {
            fprintRTF((char*)"{\\stylesheet\n");
            style___0 = CfgStartIterate();
        }
        {
            while (1){
                while_continue:
                ;
                {
                    style___0 = CfgNextByInsertion(3, style___0);
                }
                if (!((unsigned long )style___0 != (unsigned long )((void*)0))){
                    goto while_break;
                }
                {
                    rtf = (*style___0)->RtfCommand;
                    diagnostics(5, (char*)"style <%s>=<%s>", (*style___0)->TexCommand, rtf);
                    fprintRTF((char*)"{");
                    InsertBasicStyle(rtf, 2);
                    fprintRTF((char*)";}\n");
                }
            }
            while_break:
            ;
        }
        {
            fprintRTF((char*)"}\n");
        }
        return;
    }
}

static void WritePageSize(void)
{
    int n;
    int family;
    int tmp;
    int tmp___0;
    int tmp___1;
    int tmp___2;
    int tmp___3;
    int tmp___4;
    int tmp___5;
    int tmp___6;
    int tmp___7;
    int tmp___8;
    int tmp___9;
    int tmp___10;
    int tmp___11;
    int tmp___12;
    int tmp___13;
    {
        {
            tmp = DefaultFontFamily();
            family = tmp;
            tmp___0 = getLength((char*)"pagewidth");
            fprintRTF((char*)"\\paperw%d", tmp___0);
            tmp___1 = getLength((char*)"pageheight");
            fprintRTF((char*)"\\paperh%d", tmp___1);
        }
        if (g_preambleTwoside){
            {
                fprintRTF((char*)"\\facingp");
            }
        }
        if (g_preambleLandscape){
            {
                fprintRTF((char*)"\\landscape");
            }
        }
        if (g_preambleTwocolumn){
            {
                fprintRTF((char*)"\\cols2\\colsx709");
            }
        }
        if (!g_preambleGeometry){
            {
                tmp___2 = getLength((char*)"hoffset");
                tmp___3 = getLength((char*)"oddsidemargin");
                n = (tmp___2 + 1440) + tmp___3;
                fprintRTF((char*)"\\margl%d", n);
                diagnostics(4, (char*)"Writepagesize left margin   =%d pt", n / 20);
                tmp___4 = getLength((char*)"pagewidth");
                tmp___5 = getLength((char*)"textwidth");
                n = tmp___4 - (n + tmp___5);
                fprintRTF((char*)"\\margr%d", n);
                diagnostics(4, (char*)"Writepagesize right margin  =%d pt", n / 20);
                tmp___6 = getLength((char*)"voffset");
                tmp___7 = getLength((char*)"topmargin");
                tmp___8 = getLength((char*)"headheight");
                tmp___9 = getLength((char*)"headsep");
                n = (((tmp___6 + 1440) + tmp___7) + tmp___8) + tmp___9;
                fprintRTF((char*)"\\margt%d", n);
                diagnostics(4, (char*)"Writepagesize top    margin =%d pt", n / 20);
                tmp___10 = getLength((char*)"pageheight");
                tmp___11 = getLength((char*)"textheight");
                tmp___12 = getLength((char*)"footskip");
                n = tmp___10 - ((n + tmp___11) + tmp___12);
                fprintRTF((char*)"\\margb%d", n);
                diagnostics(4, (char*)"Writepagesize bottom margin =%d pt", n / 20);
            }
        }else{
            {
                diagnostics(2, (char*)"Using geometry package");
                diagnostics(2, (char*)"[l,r,t,b] = [%d,%d,%d,%d]", g_geomMargl, g_geomMargr, g_geomMargt, g_geomMargb);
                fprintRTF((char*)"\\margl%d", g_geomMargl);
                fprintRTF((char*)"\\margr%d", g_geomMargr);
                fprintRTF((char*)"\\margt%d", g_geomMargt);
                fprintRTF((char*)"\\margb%d", g_geomMargb);
            }
        }
        {
            tmp___13 = getCounter((char*)"page");
            fprintRTF((char*)"\\pgnstart%d", tmp___13);
            fprintRTF((char*)"\\widowctrl\\qj\\ftnbj\\f%d\\aftnnar\n", family);
        }
        return;
    }
}

static void WriteHeadFoot(void)
{
    int family;
    int tmp;
    int size;
    int tmp___0;
    int textwidth;
    int tmp___1;
    {
        {
            tmp = DefaultFontFamily();
            family = tmp;
            tmp___0 = DefaultFontSize();
            size = tmp___0;
            tmp___1 = getLength((char*)"textwidth");
            textwidth = tmp___1;
        }
        if (g_preambleLFOOT){
            goto _L;
        }else
            if (g_preambleCFOOT){
                goto _L;
            }else
                if (g_preambleRFOOT){
                    _L:
                    {
                        fprintRTF((char*)"{\\footer\\pard\\plain\\tqc\\tx%d\\tqr\\tx%d ", textwidth / 2, textwidth);
                        setTexMode(2);
                    }
                    if (g_preambleLFOOT){
                        {
                            ConvertString((const char*)g_preambleLFOOT);
                        }
                    }
                    {
                        fprintRTF((char*)"\\tab\n");
                    }
                    if (g_preambleCFOOT){
                        {
                            ConvertString((const char*)g_preambleCFOOT);
                        }
                    }
                    if (g_preambleRFOOT){
                        {
                            fprintRTF((char*)"\\tab\n");
                            ConvertString((const char*)g_preambleRFOOT);
                        }
                    }
                    {
                        fprintRTF((char*)"\\par}\n");
                    }
                }else{
                    {
                        fprintRTF((char*)"{\\footer\\pard\\plain\\f%d\\fs%d\\qc\\chpgn\\par}\n", family, size);
                    }
                }

        if (g_preambleLHEAD){
            goto _L___0;
        }else
            if (g_preambleCHEAD){
                goto _L___0;
            }else
                if (g_preambleRHEAD){
                    _L___0:
                    {
                        fprintRTF((char*)"{\\header\\pard\\plain\\tqc\\tx%d\\tqr\\tx%d ", textwidth / 2, textwidth);
                        setTexMode(2);
                    }
                    if (g_preambleLHEAD){
                        {
                            ConvertString((const char*)g_preambleLHEAD);
                        }
                    }
                    {
                        fprintRTF((char*)"\\tab\n");
                    }
                    if (g_preambleCHEAD){
                        {
                            ConvertString((const char*)g_preambleCHEAD);
                        }
                    }
                    if (g_preambleRHEAD){
                        {
                            fprintRTF((char*)"\\tab\n");
                            ConvertString((const char*)g_preambleRHEAD);
                        }
                    }
                    {
                        fprintRTF((char*)"\\par}\n");
                    }
                }

        {
            setTexMode(6);
        }
        return;
    }
}

void CmdHeadFoot(int code)
{
    char* HeaderText;
    char* AlternText;
    {
        {
            HeaderText = (char*)((void*)0);
            AlternText = (char*)((void*)0);
            AlternText = getBracketParam();
        }
        if (AlternText){
            {
                free((void*)AlternText);
            }
        }
        {
            HeaderText = getBraceParam();
            diagnostics(4, (char*)"CmdHeadFoot code=%d <%s>", code, HeaderText);
        }
        {
            if (code == 1){
                goto case_1;
            }
            if (code == 2){
                goto case_2;
            }
            if (code == 3){
                goto case_3;
            }
            if (code == 5){
                goto case_5;
            }
            if (code == 4){
                goto case_4;
            }
            if (code == 6){
                goto case_6;
            }
            goto switch_break;
            case_1:
            g_preambleCFOOT = HeaderText;
            goto switch_break;
            case_2:
            g_preambleLFOOT = HeaderText;
            goto switch_break;
            case_3:
            g_preambleRFOOT = HeaderText;
            goto switch_break;
            case_5:
            g_preambleCHEAD = HeaderText;
            goto switch_break;
            case_4:
            g_preambleLHEAD = HeaderText;
            goto switch_break;
            case_6:
            g_preambleRHEAD = HeaderText;
            goto switch_break;
            switch_break:
            ;
        }
        if (!g_processing_preamble){
            {
                WriteHeadFoot();
            }
        }
        return;
    }
}

static void WriteColorTable(void)
{
    {
        {
            fprintRTF((char*)"{\\colortbl;\n");
            fprintRTF((char*)"\\red0\\green0\\blue0;\n");
            fprintRTF((char*)"\\red0\\green0\\blue255;\n");
            fprintRTF((char*)"\\red0\\green255\\blue255;\n");
            fprintRTF((char*)"\\red0\\green255\\blue0;\n");
            fprintRTF((char*)"\\red255\\green0\\blue255;\n");
            fprintRTF((char*)"\\red255\\green0\\blue0;\n");
            fprintRTF((char*)"\\red255\\green255\\blue0;\n");
            fprintRTF((char*)"\\red255\\green255\\blue255;\n");
        }
        if (!gColorPackage){
            {
                fprintRTF((char*)"}\n");
            }
            return;
        }
        {
            fprintRTF((char*)"\\red0\\green0\\blue128;\n");
            fprintRTF((char*)"\\red0\\green128\\blue128;\n");
            fprintRTF((char*)"\\red0\\green128\\blue0;\n");
            fprintRTF((char*)"\\red128\\green0\\blue128;\n");
            fprintRTF((char*)"\\red128\\green0\\blue0;\n");
            fprintRTF((char*)"\\red128\\green128\\blue0;\n");
            fprintRTF((char*)"\\red128\\green128\\blue128;\n");
            fprintRTF((char*)"\\red192\\green192\\blue192;\n");
            fprintRTF((char*)"\\red239\\green219\\blue197;\n");
            fprintRTF((char*)"\\red205\\green149\\blue117;\n");
            fprintRTF((char*)"\\red253\\green217\\blue181;\n");
            fprintRTF((char*)"\\red120\\green219\\blue226;\n");
            fprintRTF((char*)"\\red135\\green169\\blue107;\n");
            fprintRTF((char*)"\\red255\\green164\\blue116;\n");
            fprintRTF((char*)"\\red250\\green231\\blue181;\n");
            fprintRTF((char*)"\\red159\\green129\\blue112;\n");
            fprintRTF((char*)"\\red253\\green124\\blue110;\n");
            fprintRTF((char*)"\\red35\\green35\\blue35;\n");
            fprintRTF((char*)"\\red31\\green117\\blue254;\n");
            fprintRTF((char*)"\\red173\\green173\\blue214;\n");
            fprintRTF((char*)"\\red25\\green158\\blue189;\n");
            fprintRTF((char*)"\\red115\\green102\\blue189;\n");
            fprintRTF((char*)"\\red222\\green93\\blue131;\n");
            fprintRTF((char*)"\\red203\\green65\\blue84;\n");
            fprintRTF((char*)"\\red180\\green103\\blue77;\n");
            fprintRTF((char*)"\\red255\\green127\\blue73;\n");
            fprintRTF((char*)"\\red234\\green126\\blue93;\n");
            fprintRTF((char*)"\\red176\\green183\\blue198;\n");
            fprintRTF((char*)"\\red255\\green255\\blue153;\n");
            fprintRTF((char*)"\\red28\\green211\\blue162;\n");
            fprintRTF((char*)"\\red255\\green170\\blue204;\n");
            fprintRTF((char*)"\\red221\\green68\\blue146;\n");
            fprintRTF((char*)"\\red29\\green172\\blue214;\n");
            fprintRTF((char*)"\\red188\\green93\\blue88;\n");
            fprintRTF((char*)"\\red221\\green148\\blue117;\n");
            fprintRTF((char*)"\\red154\\green206\\blue235;\n");
            fprintRTF((char*)"\\red255\\green188\\blue217;\n");
            fprintRTF((char*)"\\red253\\green219\\blue109;\n");
            fprintRTF((char*)"\\red43\\green108\\blue196;\n");
            fprintRTF((char*)"\\red239\\green205\\blue184;\n");
            fprintRTF((char*)"\\red110\\green81\\blue96;\n");
            fprintRTF((char*)"\\red29\\green249\\blue20;\n");
            fprintRTF((char*)"\\red113\\green188\\blue120;\n");
            fprintRTF((char*)"\\red109\\green174\\blue129;\n");
            fprintRTF((char*)"\\red195\\green100\\blue197;\n");
            fprintRTF((char*)"\\red204\\green102\\blue102;\n");
            fprintRTF((char*)"\\red231\\green198\\blue151;\n");
            fprintRTF((char*)"\\red252\\green217\\blue117;\n");
            fprintRTF((char*)"\\red168\\green228\\blue160;\n");
            fprintRTF((char*)"\\red149\\green145\\blue140;\n");
            fprintRTF((char*)"\\red28\\green172\\blue120;\n");
            fprintRTF((char*)"\\red240\\green232\\blue145;\n");
            fprintRTF((char*)"\\red255\\green29\\blue206;\n");
            fprintRTF((char*)"\\red178\\green236\\blue93;\n");
            fprintRTF((char*)"\\red93\\green118\\blue203;\n");
            fprintRTF((char*)"\\red202\\green55\\blue103;\n");
            fprintRTF((char*)"\\red59\\green176\\blue143;\n");
            fprintRTF((char*)"\\red253\\green252\\blue116;\n");
            fprintRTF((char*)"\\red252\\green180\\blue213;\n");
            fprintRTF((char*)"\\red255\\green189\\blue136;\n");
            fprintRTF((char*)"\\red246\\green100\\blue175;\n");
            fprintRTF((char*)"\\red205\\green74\\blue74;\n");
            fprintRTF((char*)"\\red151\\green154\\blue170;\n");
            fprintRTF((char*)"\\red255\\green130\\blue67;\n");
            fprintRTF((char*)"\\red200\\green56\\blue90;\n");
            fprintRTF((char*)"\\red239\\green152\\blue170;\n");
            fprintRTF((char*)"\\red253\\green188\\blue180;\n");
            fprintRTF((char*)"\\red26\\green72\\blue118;\n");
            fprintRTF((char*)"\\red48\\green186\\blue143;\n");
            fprintRTF((char*)"\\red25\\green116\\blue210;\n");
            fprintRTF((char*)"\\red255\\green163\\blue67;\n");
            fprintRTF((char*)"\\red186\\green184\\blue108;\n");
            fprintRTF((char*)"\\red255\\green117\\blue56;\n");
            fprintRTF((char*)"\\red230\\green168\\blue215;\n");
            fprintRTF((char*)"\\red65\\green74\\blue76;\n");
            fprintRTF((char*)"\\red255\\green110\\blue74;\n");
            fprintRTF((char*)"\\red28\\green169\\blue201;\n");
            fprintRTF((char*)"\\red255\\green207\\blue171;\n");
            fprintRTF((char*)"\\red197\\green208\\blue230;\n");
            fprintRTF((char*)"\\red253\\green215\\blue228;\n");
            fprintRTF((char*)"\\red21\\green128\\blue120;\n");
            fprintRTF((char*)"\\red252\\green116\\blue253;\n");
            fprintRTF((char*)"\\red247\\green128\\blue161;\n");
            fprintRTF((char*)"\\red142\\green69\\blue133;\n");
            fprintRTF((char*)"\\red116\\green66\\blue200;\n");
            fprintRTF((char*)"\\red157\\green129\\blue186;\n");
            fprintRTF((char*)"\\red255\\green29\\blue206;\n");
            fprintRTF((char*)"\\red255\\green73\\blue108;\n");
            fprintRTF((char*)"\\red214\\green138\\blue89;\n");
            fprintRTF((char*)"\\red255\\green72\\blue208;\n");
            fprintRTF((char*)"\\red227\\green37\\blue107;\n");
            fprintRTF((char*)"\\red238\\green32\\blue77;\n");
            fprintRTF((char*)"\\red255\\green83\\blue73;\n");
            fprintRTF((char*)"\\red192\\green68\\blue143;\n");
            fprintRTF((char*)"\\red31\\green206\\blue203;\n");
            fprintRTF((char*)"\\red120\\green81\\blue169;\n");
            fprintRTF((char*)"\\red255\\green155\\blue170;\n");
            fprintRTF((char*)"\\red252\\green40\\blue71;\n");
            fprintRTF((char*)"\\red118\\green255\\blue122;\n");
            fprintRTF((char*)"\\red159\\green226\\blue191;\n");
            fprintRTF((char*)"\\red165\\green105\\blue79;\n");
            fprintRTF((char*)"\\red138\\green121\\blue93;\n");
            fprintRTF((char*)"\\red69\\green206\\blue162;\n");
            fprintRTF((char*)"\\red251\\green126\\blue253;\n");
            fprintRTF((char*)"\\red205\\green197\\blue194;\n");
            fprintRTF((char*)"\\red128\\green218\\blue235;\n");
            fprintRTF((char*)"\\red236\\green234\\blue190;\n");
            fprintRTF((char*)"\\red255\\green207\\blue72;\n");
            fprintRTF((char*)"\\red253\\green94\\blue83;\n");
            fprintRTF((char*)"\\red250\\green167\\blue108;\n");
            fprintRTF((char*)"\\red252\\green137\\blue172;\n");
            fprintRTF((char*)"\\red219\\green215\\blue210;\n");
            fprintRTF((char*)"\\red23\\green128\\blue109;\n");
            fprintRTF((char*)"\\red222\\green170\\blue136;\n");
            fprintRTF((char*)"\\red119\\green221\\blue231;\n");
            fprintRTF((char*)"\\red253\\green252\\blue116;\n");
            fprintRTF((char*)"\\red146\\green110\\blue174;\n");
            fprintRTF((char*)"\\red247\\green83\\blue148;\n");
            fprintRTF((char*)"\\red255\\green160\\blue137;\n");
            fprintRTF((char*)"\\red143\\green80\\blue157;\n");
            fprintRTF((char*)"\\red237\\green237\\blue237;\n");
            fprintRTF((char*)"\\red162\\green173\\blue208;\n");
            fprintRTF((char*)"\\red255\\green67\\blue164;\n");
            fprintRTF((char*)"\\red252\\green108\\blue133;\n");
            fprintRTF((char*)"\\red205\\green164\\blue222;\n");
            fprintRTF((char*)"\\red252\\green232\\blue131;\n");
            fprintRTF((char*)"\\red197\\green227\\blue132;\n");
            fprintRTF((char*)"\\red255\\green182\\blue83;\n");
            fprintRTF((char*)"}\n");
        }
        return;
    }
}

static void WriteInfo(void)
{
    time_t tm;
    char* tmp;
    char* tmp___0;
    {
        {
            tmp = CurrentFileName();
            fprintRTF((char*)"{\\info\n{\\title Original file was %s}\n", tmp);
            tm = time((time_t*)((void*)0));
            tmp___0 = ctime((const time_t*)(&tm));
            fprintRTF((char*)"{\\doccomm Created using latex2rtf %s on %s}\n", Version, tmp___0);
            fprintRTF((char*)"}\n");
        }
        return;
    }
}

void WriteRtfHeader(void)
{
    int family;
    int tmp;
    {
        {
            tmp = DefaultFontFamily();
            family = tmp;
            diagnostics(4, (char*)"Writing header for RTF file");
            fprintRTF((char*)"{\\rtf1\\ansi\\uc1\\deff%d\\deflang1024\n", family);
            WriteFontHeader();
            WriteColorTable();
            WriteStyleHeader();
            WriteInfo();
            WriteHeadFoot();
            WritePageSize();
        }
        return;
    }
}

void zeroKeyCounters(char* key);
counter_type Counters[500];
static int iCounterCount = 0;

static int existsCounter(char* s)
{
    int i;
    char* tmp;
    {
        i = 0;
        {
            while (1){
                while_continue:
                ;
                if (i < iCounterCount){
                    {
                        tmp = strstr((const char*)Counters[i].name, (const char*)s);
                    }
                    if (!((unsigned long )tmp == (unsigned long )((void*)0))){
                        goto while_break;
                    }
                }else{
                    goto while_break;
                }
                i++;
            }
            while_break:
            ;
        }
        if (i == iCounterCount){
            return (-1);
        }else{
            return (i);
        }
    }
}

static void newCounter(char* s, int n)
{
    {
        if (iCounterCount == 500){
            {
                diagnostics(1, (char*)"Too many counters, ignoring %s", s);
            }
            return;
        }
        {
            Counters[iCounterCount].number = n;
            Counters[iCounterCount].name = strdup((const char*)s);
        }
        if ((unsigned long )Counters[iCounterCount].name == (unsigned long )((void*)0)){
            {
                diagnostics(1, (char*)"\nCannot allocate name for counter \\%s\n", s);
                exit(1);
            }
        }
        iCounterCount++;
        return;
    }
}

void incrementCounter(char* s)
{
    int i;
    {
        {
            i = existsCounter(s);
        }
        if (i < 0){
            {
                newCounter(s, 1);
            }
        }else{
            (Counters[i].number)++;
        }
        return;
    }
}

void setCounter(char* s, int n)
{
    int i;
    {
        {
            i = existsCounter(s);
        }
        if (i < 0){
            {
                newCounter(s, n);
            }
        }else{
            Counters[i].number = n;
        }
        return;
    }
}

int getCounter(char* s)
{
    int i;
    {
        {
            i = existsCounter(s);
        }
        if (i < 0){
            {
                diagnostics(2, (char*)"No counter of type <%s>", s);
            }
            return (0);
        }
        return (Counters[i].number);
    }
}

void zeroKeyCounters(char* key)
{
    int i;
    char* tmp;
    {
        i = 0;
        {
            while (1){
                while_continue:
                ;
                if (!(i < iCounterCount)){
                    goto while_break;
                }
                {
                    tmp = strstr((const char*)Counters[i].name, (const char*)key);
                }
                if ((unsigned long )tmp != (unsigned long )Counters[i].name){
                    Counters[i].number = 0;
                }
                i++;
            }
            while_break:
            ;
        }
        return;
    }
}

void CmdSetTexLength(int code);
length_type Lengths[50];
static int iLengthCount = 0;

static int existsLength(char* s)
{
    int i;
    char* tmp;
    {
        i = 0;
        {
            while (1){
                while_continue:
                ;
                if (i < iLengthCount){
                    {
                        tmp = strstr((const char*)Lengths[i].name, (const char*)s);
                    }
                    if (!((unsigned long )tmp == (unsigned long )((void*)0))){
                        goto while_break;
                    }
                }else{
                    goto while_break;
                }
                i++;
            }
            while_break:
            ;
        }
        if (i == iLengthCount){
            return (-1);
        }else{
            return (i);
        }
    }
}

static void newLength(char* s, int d)
{
    {
        if (iLengthCount == 50){
            {
                diagnostics(1, (char*)"Too many lengths, ignoring %s", s);
            }
            return;
        }
        {
            Lengths[iLengthCount].distance = d;
            Lengths[iLengthCount].name = strdup((const char*)s);
        }
        if ((unsigned long )Lengths[iLengthCount].name == (unsigned long )((void*)0)){
            {
                diagnostics(0, (char*)"Cannot allocate name for length \\%s", s);
            }
        }
        iLengthCount++;
        return;
    }
}

void setLength(char* s, int d)
{
    int i;
    {
        {
            i = existsLength(s);
        }
        if (i < 0){
            {
                newLength(s, d);
            }
        }else{
            Lengths[i].distance = d;
        }
        return;
    }
}

int getLength(char* s)
{
    int i;
    {
        {
            i = existsLength(s);
        }
        if (i < 0){
            {
                diagnostics(1, (char*)"No length of type %s", s);
            }
            return (0);
        }
        return (Lengths[i].distance);
    }
}

void CmdSetTexLength(int code)
{
    int d;
    char c;
    {
        {
            c = getNonSpace();
        }
        if ((int)c == 61){
            {
                skipSpaces();
            }
        }else{
            {
                ungetTexChar(c);
            }
        }
        {
            d = getDimension();
            diagnostics(4, (char*)"CmdSetTexLength size = %d", d);
        }
        {
            if (code == 1){
                goto case_1;
            }
            if (code == 2){
                goto case_2;
            }
            if (code == 3){
                goto case_3;
            }
            if (code == 4){
                goto case_4;
            }
            if (code == 5){
                goto case_5;
            }
            if (code == 6){
                goto case_6;
            }
            if (code == 7){
                goto case_7;
            }
            if (code == 8){
                goto case_8;
            }
            if (code == 9){
                goto case_9;
            }
            if (code == 10){
                goto case_10;
            }
            if (code == 11){
                goto case_11;
            }
            if (code == 12){
                goto case_12;
            }
            if (code == 13){
                goto case_13;
            }
            goto switch_break;
            case_1:
            {
                setLength((char*)"hoffset", d);
            }
            goto switch_break;
            case_2:
            {
                setLength((char*)"voffset", d);
            }
            goto switch_break;
            case_3:
            {
                setLength((char*)"parindent", d);
            }
            goto switch_break;
            case_4:
            {
                setLength((char*)"parskip", d);
            }
            goto switch_break;
            case_5:
            {
                setLength((char*)"baselineskip", d);
            }
            goto switch_break;
            case_6:
            {
                setLength((char*)"topmargin", d);
            }
            goto switch_break;
            case_7:
            {
                setLength((char*)"textheight", d);
            }
            goto switch_break;
            case_8:
            {
                setLength((char*)"headheight", d);
            }
            goto switch_break;
            case_9:
            {
                setLength((char*)"headsep", d);
            }
            goto switch_break;
            case_10:
            {
                setLength((char*)"textwidth", d);
            }
            goto switch_break;
            case_11:
            {
                setLength((char*)"oddsidemargin", d);
            }
            goto switch_break;
            case_12:
            {
                setLength((char*)"evensidemargin", d);
            }
            goto switch_break;
            case_13:
            {
                setLength((char*)"linewidth", d);
            }
            goto switch_break;
            switch_break:
            ;
        }
        return;
    }
}

extern struct _IO_FILE* stdin;
extern int (fileno)(FILE* __stream);
extern int (tolower)(int __c);
void skipToEOL(void);
void skipWhiteSpace(void);
void CmdIgnoreParameter(int code);
char* getSpacedTexUntil(char* target, int raw);
void parseBrace(void);
int CurrentLineNumber(void);
void EndSource(void);
int CurrentFileDescriptor(void);
static InputStackType g_parser_stack[100];
static int g_parser_depth = -1;
static char* g_parser_string = (char*)"stdin";
static FILE* g_parser_file = (FILE*)((void*)0);
static int g_parser_line = 1;
static int g_parser_include_level = 0;
static char g_parser_currentChar;
static char g_parser_lastChar;
static char g_parser_penultimateChar;
static int g_parser_backslashes;
static int g_track_line_number_stack[10];
static int g_track_line_number = -1;
static void parseBracket(void);

void PushTrackLineNumber(int flag)
{
    {
        if (g_track_line_number >= 10){
            {
                diagnostics(0, (char*)"scan ahead stack too large! Sorry.");
            }
        }
        g_track_line_number++;
        g_track_line_number_stack[g_track_line_number] = flag;
        return;
    }
}

void PopTrackLineNumber(void)
{
    {
        if (g_track_line_number < 0){
            {
                diagnostics(0, (char*)"scan ahead stack too small! Sorry.");
            }
        }
        g_track_line_number--;
        return;
    }
}

int CurrentLineNumber(void)
{
    {
        return (g_parser_line);
    }
}

void UpdateLineNumber(char* s)
{
    {
        if ((unsigned long )s == (unsigned long )((void*)0)){
            return;
        }
        {
            while (1){
                while_continue:
                ;
                if (!((int)*s != 0)){
                    goto while_break;
                }
                if ((int)*s == 10){
                    g_parser_line++;
                }
                s++;
            }
            while_break:
            ;
        }
        return;
    }
}

int CurrentFileDescriptor(void)
{
    int fd;
    {
        fd = 0;
        if (g_parser_file){
            {
                fd = fileno(g_parser_file);
            }
        }
        return (fd);
    }
}

char* CurrentFileName(void)
{
    char* s;
    {
        s = (char*)"(Not set)";
        if (g_parser_stack[g_parser_depth].file_name){
            return (g_parser_stack[g_parser_depth].file_name);
        }else{
            return (s);
        }
    }
}

int PushSource(const char* filename, const char* string)
{
    FILE* p;
    char* name;
    int line;
    int tmp;
    char* tmp___0;
    {
        p = (FILE*)((void*)0);
        name = (char*)((void*)0);
        line = 1;
        if (g_parser_depth >= 0){
            g_parser_stack[g_parser_depth].file_line = g_parser_line;
            g_parser_stack[g_parser_depth].string = g_parser_string;
        }
        if ((unsigned long )filename == (unsigned long )((void*)0)){
            goto _L___0;
        }else{
            {
                tmp = strcmp(filename, "-");
            }
            if (tmp == 0){
                _L___0:
                if ((unsigned long )string == (unsigned long )((void*)0)){
                    {
                        g_parser_include_level++;
                        g_parser_line = 1;
                        name = strdup("stdin");
                        p = stdin;
                    }
                }else{
                    goto _L;
                }
            }else
                _L:
                if (filename){
                    {
                        p = my_fopen((char*)filename, (char*)"rb");
                    }
                    if ((unsigned long )p == (unsigned long )((void*)0)){
                        return (1);
                    }
                    {
                        g_parser_include_level++;
                        g_parser_line = 1;
                        name = strdup(filename);
                    }
                }else{
                    {
                        name = CurrentFileName();
                        line = CurrentLineNumber();
                    }
                }
        }
        g_parser_depth++;
        if (g_parser_depth >= 100){
            {
                diagnostics(0, (char*)"More than %d PushSource() calls", 100);
            }
        }
        if (string){
            {
                tmp___0 = strdup(string);
                g_parser_string = tmp___0;
            }
        }else{
            g_parser_string = (char*)((void*)0);
        }
        g_parser_stack[g_parser_depth].string = g_parser_string;
        g_parser_stack[g_parser_depth].string_start = g_parser_string;
        g_parser_stack[g_parser_depth].file = p;
        g_parser_stack[g_parser_depth].file_line = line;
        g_parser_stack[g_parser_depth].file_name = name;
        g_parser_file = p;
        g_parser_string = g_parser_stack[g_parser_depth].string;
        if (g_parser_file){
            {
                diagnostics(3, (char*)"Opening Source File %s", g_parser_stack[g_parser_depth].file_name);
            }
        }else{
            {
                diagnostics(4, (char*)"Opening Source string");
                show_string(5, (const char*)g_parser_string, "opening");
            }
        }
        return (0);
    }
}

int StillSource(void)
{
    int tmp;
    int tmp___0;
    {
        if (g_parser_file){
            {
                tmp = feof(g_parser_file);
            }
            if (tmp){
                tmp___0 = 0;
            }else{
                tmp___0 = 1;
            }
            return (tmp___0);
        }else{
            return ((int)*g_parser_string != 0);
        }
    }
}

void EndSource(void)
{
    {
        if (g_parser_file){
            {
                fseek(g_parser_file, 0L, 2);
            }
        }else{
            *g_parser_string = (char)'\000';
        }
        return;
    }
}

void PopSource(void)
{
    char s[50];
    size_t tmp;
    {
        if (g_parser_depth < 0){
            {
                diagnostics(1, (char*)"Hmmm.  More PopSource() calls than PushSource() calls");
            }
            return;
        }
        if (g_parser_file){
            {
                diagnostics(3, (char*)"Closing Source File \'%s\'", g_parser_stack[g_parser_depth].file_name);
                fclose(g_parser_file);
                free((void*)g_parser_stack[g_parser_depth].file_name);
                g_parser_stack[g_parser_depth].file_name = (char*)((void*)0);
                g_parser_include_level--;
            }
        }
        if (g_parser_string){
            {
                tmp = strlen((const char*)g_parser_stack[g_parser_depth].string_start);
            }
            if (tmp < 49UL){
                {
                    strcpy((char*)(s), (const char*)g_parser_stack[g_parser_depth].string_start);
                }
            }else{
                {
                    strncpy((char*)(s), (const char*)g_parser_stack[g_parser_depth].string_start, (size_t)49);
                    s[49] = (char)'\000';
                }
            }
            {
                show_string(5, (const char*)(s), "closing");
                free((void*)g_parser_stack[g_parser_depth].string_start);
                g_parser_stack[g_parser_depth].string_start = (char*)((void*)0);
            }
        }
        g_parser_depth--;
        if (g_parser_depth >= 0){
            g_parser_string = g_parser_stack[g_parser_depth].string;
            g_parser_file = g_parser_stack[g_parser_depth].file;
        }
        if (g_parser_file){
        }
        if (g_parser_file){
            {
                diagnostics(4, (char*)"Resuming Source File \'%s\'", g_parser_stack[g_parser_depth].file_name);
            }
        }else{
            {
                diagnostics(5, (char*)"Resuming Source string");
                show_string(5, (const char*)g_parser_string, "resuming");
            }
        }
        return;
    }
}

void CmdInclude(int code)
{
    int cNext;
    char name[100];
    int i;
    char* basename;
    char* texname;
    char tmp;
    char tmp___0;
    const unsigned short **tmp___1;
    char* tmp___2;
    char* tmp___3;
    char* tmp___4;
    char* tmp___5;
    int tmp___6;
    int tmp___7;
    {
        {
            basename = (char*)((void*)0);
            texname = (char*)((void*)0);
            tmp = getNonSpace();
            cNext = (int)tmp;
        }
        if (cNext == 123){
            {
                ungetTexChar((char)cNext);
                basename = getBraceParam();
            }
        }else{
            i = 0;
            {
                while (1){
                    while_continue:
                    ;
                    if (cNext != 0){
                        {
                            tmp___1 = __ctype_b_loc();
                        }
                        if ((const int)*(*tmp___1 + cNext) & 8192){
                            goto while_break;
                        }
                    }else{
                        goto while_break;
                    }
                    if (i < 99){
                        name[i] = (char)cNext;
                    }
                    {
                        i++;
                        tmp___0 = getTexChar();
                        cNext = (int)tmp___0;
                    }
                }
                while_break:
                ;
            }
            if (i < 99){
                name[i] = (char)'\000';
            }else{
                {
                    name[99] = (char)'\000';
                    diagnostics(1, (char*)"\\input filename \'%s\' more than 100 chars, skipping", name);
                }
                return;
            }
            {
                basename = strdup((const char*)(name));
            }
        }
        {
            tmp___3 = strstr((const char*)basename, "german.sty");
        }
        if ((unsigned long )tmp___3 != (unsigned long )((void*)0)){
            {
                GermanMode = 1;
                PushEnvironment(12);
                free((void*)basename);
            }
            return;
        }else{
            {
                tmp___2 = strstr((const char*)basename, "french.sty");
            }
            if ((unsigned long )tmp___2 != (unsigned long )((void*)0)){
                {
                    FrenchMode = 1;
                    PushEnvironment(13);
                    free((void*)basename);
                }
                return;
            }
        }
        if (basename){
            {
                tmp___4 = strstr((const char*)basename, ".tex");
            }
            if ((unsigned long )tmp___4 == (unsigned long )((void*)0)){
                {
                    tmp___5 = strstr((const char*)basename, ".ltx");
                }
                if ((unsigned long )tmp___5 == (unsigned long )((void*)0)){
                    {
                        texname = strdup_together((const char*)basename, ".tex");
                    }
                }
            }
        }
        if (texname){
            {
                tmp___7 = PushSource((const char*)texname, (const char*)((void*)0));
            }
            if (tmp___7 == 0){
                {
                    diagnostics(1, (char*)"Including file <%s> (.tex appended)", texname);
                }
            }else{
                goto _L;
            }
        }else
            _L:
            if (basename){
                {
                    tmp___6 = PushSource((const char*)basename, (const char*)((void*)0));
                }
                if (tmp___6 == 0){
                    {
                        diagnostics(1, (char*)"Including file <%s>", basename);
                    }
                }
            }

        if (code == 0){
            {
                PushSource((const char*)((void*)0), "\\pagebreak ");
            }
        }
        if (basename){
            {
                free((void*)basename);
            }
        }
        if (texname){
            {
                free((void*)texname);
            }
        }
        return;
    }
}

int getParserDepth(void)
{
    {
        return (g_parser_depth);
    }
}

char getRawTexChar(void)
{
    int thechar;
    char tmp;
    int tmp___0;
    int tmp___1;
    {
        if (g_parser_file){
            {
                thechar = _IO_getc(g_parser_file);
            }
            {
                while (1){
                    while_continue:
                    ;
                    if (!(thechar == -1)){
                        goto while_break;
                    }
                    {
                        tmp___0 = feof(g_parser_file);
                    }
                    if (tmp___0){
                        if (g_parser_include_level > 1){
                            {
                                PopSource();
                                tmp = getRawTexChar();
                                thechar = (int)tmp;
                            }
                        }else{
                            thechar = '\000';
                        }
                    }else{
                        {
                            diagnostics(0, (char*)"Unknown file I/O error reading latex file\n");
                        }
                    }
                }
                while_break:
                ;
            }
            if (thechar == 13){
                {
                    thechar = _IO_getc(g_parser_file);
                }
                if (thechar != 10){
                    {
                        tmp___1 = feof(g_parser_file);
                    }
                    if (!tmp___1){
                        {
                            ungetc(thechar, g_parser_file);
                        }
                    }
                }
                thechar = '\n';
            }else
                if (thechar == 10){
                    thechar = '\n';
                }else
                    if (thechar == 9){
                        thechar = ' ';
                    }

            g_parser_currentChar = (char)thechar;
        }else
            if (g_parser_string){
                if (*g_parser_string){
                    thechar = (int)*g_parser_string;
                    if (thechar == 13){
                        g_parser_string++;
                        thechar = (int)*g_parser_string;
                        if (thechar != 10){
                            g_parser_string--;
                        }
                        thechar = '\n';
                    }else
                        if (thechar == 10){
                            thechar = '\n';
                        }else
                            if (thechar == 9){
                                thechar = ' ';
                            }

                    g_parser_currentChar = (char)thechar;
                    g_parser_string++;
                }else{
                    goto _L;
                }
            }else
                _L:
                if (g_parser_depth > 15){
                    {
                        PopSource();
                        g_parser_currentChar = getRawTexChar();
                    }
                }else{
                    g_parser_currentChar = (char)'\000';
                }

        if ((int)g_parser_currentChar == 10){
            if (g_track_line_number_stack[g_track_line_number]){
                g_parser_line++;
            }
        }
        g_parser_penultimateChar = g_parser_lastChar;
        g_parser_lastChar = g_parser_currentChar;
        return (g_parser_currentChar);
    }
}

void ungetTexChar(char c)
{
    {
        if ((int)c == 0){
            return;
        }
        if (g_parser_file){
            {
                ungetc((int)c, g_parser_file);
            }
        }else{
            g_parser_string--;
            if (g_parser_string){
                if (*g_parser_string){
                    *g_parser_string = c;
                }
            }
        }
        if ((int)c == 10){
            if (g_track_line_number_stack[g_track_line_number]){
                g_parser_line--;
            }
        }
        {
            g_parser_currentChar = g_parser_lastChar;
            g_parser_lastChar = g_parser_penultimateChar;
            g_parser_penultimateChar = (char)'\000';
            g_parser_backslashes = 0;
            diagnostics(6, (char*)"after ungetTexChar=<%c> backslashes=%d line=%ld", (int)c, g_parser_backslashes, g_parser_line);
        }
        return;
    }
}

char getTexChar(void)
{
    char cThis;
    char cSave;
    char cSave2;
    int tmp;
    {
        {
            cSave = g_parser_lastChar;
            cSave2 = g_parser_penultimateChar;
            cThis = getRawTexChar();
        }
        {
            while (1){
                while_continue:
                ;
                if ((int)cThis == 37){
                    {
                        tmp = even((long )g_parser_backslashes);
                    }
                    if (!tmp){
                        goto while_break;
                    }
                }else{
                    goto while_break;
                }
                {
                    skipToEOL();
                    g_parser_penultimateChar = cSave2;
                    g_parser_lastChar = cSave;
                    cThis = getRawTexChar();
                }
            }
            while_break:
            ;
        }
        if ((int)cThis == 92){
            g_parser_backslashes++;
        }else{
            g_parser_backslashes = 0;
        }
        return (cThis);
    }
}

void skipToEOL(void)
{
    char cThis;
    {
        {
            while (1){
                while_continue:
                ;
                {
                    cThis = getRawTexChar();
                }
                if (cThis){
                    if (!((int)cThis != 10)){
                        goto while_break;
                    }
                }else{
                    goto while_break;
                }
            }
            while_break:
            ;
        }
        return;
    }
}

char getNonBlank(void)
{
    char c;
    {
        {
            c = getTexChar();
        }
        {
            while (1){
                while_continue:
                ;
                if (!((int)c == 32)){
                    if (!((int)c == 10)){
                        goto while_break;
                    }
                }
                {
                    c = getTexChar();
                }
            }
            while_break:
            ;
        }
        return (c);
    }
}

char getNonSpace(void)
{
    char c;
    {
        {
            while (1){
                while_continue:
                ;
                {
                    c = getTexChar();
                }
                if (c){
                    if (!((int)c == 32)){
                        goto while_break;
                    }
                }else{
                    goto while_break;
                }
            }
            while_break:
            ;
        }
        return (c);
    }
}

void skipSpaces(void)
{
    char c;
    {
        {
            while (1){
                while_continue:
                ;
                {
                    c = getTexChar();
                }
                if (c){
                    if (!((int)c == 32)){
                        goto while_break;
                    }
                }else{
                    goto while_break;
                }
            }
            while_break:
            ;
        }
        {
            ungetTexChar(c);
        }
        return;
    }
}

void skipWhiteSpace(void)
{
    char c;
    char tmp;
    {
        {
            tmp = getNonBlank();
            c = tmp;
            ungetTexChar(c);
        }
        return;
    }
}

int getSameChar(char c)
{
    char cThis;
    int count;
    {
        count = -1;
        {
            while (1){
                while_continue:
                ;
                {
                    cThis = getTexChar();
                    count++;
                }
                if (!((int)cThis == (int)c)){
                    goto while_break;
                }
            }
            while_break:
            ;
        }
        {
            ungetTexChar(cThis);
        }
        return (count);
    }
}

char* getDelimitedText(char left, char right, int raw)
{
    char buffer___0[5000];
    int size;
    int lefts_needed;
    int brace_level;
    int last_char_was_backslash;
    char tmp;
    char tmp___0;
    char* tmp___1;
    char* tmp___2;
    {
        size = -1;
        lefts_needed = 1;
        brace_level = 0;
        last_char_was_backslash = 0;
        {
            while (1){
                while_continue:
                ;
                if (lefts_needed){
                    if (!(size < 4999)){
                        goto while_break;
                    }
                }else{
                    goto while_break;
                }
                size++;
                if (raw){
                    {
                        tmp = getRawTexChar();
                        buffer___0[size] = tmp;
                    }
                }else{
                    {
                        tmp___0 = getTexChar();
                        buffer___0[size] = tmp___0;
                    }
                }
                if (last_char_was_backslash){
                    if ((int)buffer___0[size] == 92){
                        last_char_was_backslash = 0;
                        goto while_continue;
                    }
                }else
                    if ((int)buffer___0[size] == (int)right){
                        if (brace_level == 0){
                            lefts_needed--;
                        }else{
                            goto _L;
                        }
                    }else
                        _L:
                        if ((int)buffer___0[size] == 123){
                            brace_level++;
                        }else
                            if ((int)buffer___0[size] == 125){
                                brace_level--;
                            }

                if ((int)buffer___0[size] == 92){
                    last_char_was_backslash = 1;
                }else{
                    last_char_was_backslash = 0;
                }
            }
            while_break:
            ;
        }
        buffer___0[size] = (char)'\000';
        if (size == 4999){
            {
                diagnostics(1, (char*)"Could not find closing \'%c\' in %d chars", (int)right, 5000);
                tmp___1 = strdup(" NOT FOUND ");
            }
            return (tmp___1);
        }
        {
            tmp___2 = strdup((const char*)(buffer___0));
        }
        return (tmp___2);
    }
}

void parseBrace(void)
{
    char* s;
    char* tmp;
    {
        {
            tmp = getDelimitedText((char)'{', (char)'}', 0);
            s = tmp;
            free((void*)s);
        }
        return;
    }
}

static void parseBracket(void)
{
    char* s;
    char* tmp;
    {
        {
            tmp = getDelimitedText((char)'[', (char)']', 0);
            s = tmp;
            free((void*)s);
        }
        return;
    }
}

void CmdIgnoreParameter(int code)
{
    int optParmCount;
    int regParmCount;
    char cThis;
    {
        {
            optParmCount = code / 10;
            regParmCount = code % 10;
            diagnostics(4, (char*)"CmdIgnoreParameter [%d] {%d}", optParmCount, regParmCount);
        }
        {
            while (1){
                while_continue:
                ;
                if (!regParmCount){
                    goto while_break;
                }
                {
                    cThis = getNonBlank();
                }
                {
                    if ((int)cThis == 123){
                        goto case_123;
                    }
                    if ((int)cThis == 91){
                        goto case_91;
                    }
                    goto switch_default;
                    case_123:
                    {
                        regParmCount--;
                        parseBrace();
                    }
                    goto switch_break;
                    case_91:
                    {
                        optParmCount--;
                        parseBracket();
                    }
                    goto switch_break;
                    switch_default:
                    {
                        diagnostics(1, (char*)"Ignored command missing {} expected %d - found %d", code % 10, code % 10 - regParmCount);
                        ungetTexChar(cThis);
                    }
                    return;
                    switch_break:
                    ;
                }
            }
            while_break:
            ;
        }
        if (optParmCount > 0){
            {
                cThis = getNonSpace();
            }
            if ((int)cThis == 91){
                {
                    parseBracket();
                }
            }else{
                {
                    ungetTexChar(cThis);
                }
                return;
            }
        }
        return;
    }
}

char* getSimpleCommand(void)
{
    char buffer___0[128];
    int size;
    const unsigned short **tmp;
    char* tmp___0;
    {
        {
            buffer___0[0] = getTexChar();
        }
        if ((int)buffer___0[0] != 92){
            return ((char*)((void*)0));
        }
        {
            buffer___0[1] = getTexChar();
            size = 2;
        }
        {
            while (1){
                while_continue:
                ;
                if (!(size < 127)){
                    goto while_break;
                }
                {
                    buffer___0[size] = getRawTexChar();
                    tmp = __ctype_b_loc();
                }
                if (!((const int)*(*tmp + (int)buffer___0[size]) & 1024)){
                    {
                        ungetTexChar(buffer___0[size]);
                    }
                    goto while_break;
                }
                size++;
            }
            while_break:
            ;
        }
        buffer___0[size] = (char)'\000';
        if (size == 127){
            {
                diagnostics(1, (char*)"Misplaced brace.");
                diagnostics(0, (char*)"Cannot find close brace in 127 characters");
            }
        }
        {
            diagnostics(5, (char*)"getSimpleCommand result <%s>", buffer___0);
            tmp___0 = strdup((const char*)(buffer___0));
        }
        return (tmp___0);
    }
}

char* getBracketParam(void)
{
    char c;
    char* text;
    {
        {
            c = getNonBlank();
            PushTrackLineNumber(0);
        }
        if ((int)c == 91){
            {
                text = getDelimitedText((char)'[', (char)']', 0);
                diagnostics(6, (char*)"getBracketParam [%s]", text);
            }
        }else{
            {
                ungetTexChar(c);
                text = (char*)((void*)0);
                diagnostics(6, (char*)"getBracketParam []");
            }
        }
        {
            PopTrackLineNumber();
        }
        return (text);
    }
}

static char* getBraceParam0(int raw_flag)
{
    char s[2];
    char* text;
    {
        {
            s[0] = getNonSpace();
        }
        if ((int)s[0] == 10){
            {
                s[0] = getNonSpace();
            }
        }
        {
            PushTrackLineNumber(0);
        }
        if ((int)s[0] == 92){
            {
                ungetTexChar(s[0]);
                text = getSimpleCommand();
            }
        }else
            if ((int)s[0] == 123){
                {
                    text = getDelimitedText((char)'{', (char)'}', raw_flag);
                }
            }else{
                {
                    s[1] = (char)'\000';
                    text = strdup((const char*)(s));
                }
            }

        {
            PopTrackLineNumber();
            diagnostics(6, (char*)"Leaving getBraceParam {%s}", text);
        }
        return (text);
    }
}

char* getBraceParam(void)
{
    char* tmp;
    {
        {
            tmp = getBraceParam0(0);
        }
        return (tmp);
    }
}

char* getBraceRawParam(void)
{
    char* tmp;
    {
        {
            tmp = getBraceParam0(1);
        }
        return (tmp);
    }
}

char* getLeftRightParam(void)
{
    char text[5000];
    char s;
    char* command;
    int i;
    int lrdepth;
    char* tmp;
    int tmp___0;
    size_t tmp___1;
    int tmp___2;
    {
        i = 0;
        lrdepth = 1;
        text[0] = (char)'\000';
        {
            while (1){
                while_continue:
                ;
                {
                    s = getTexChar();
                }
                if ((int)s == 92){
                    {
                        ungetTexChar(s);
                        command = getSimpleCommand();
                        tmp___0 = strcmp((const char*)command, "\\right");
                    }
                    if (tmp___0 == 0){
                        lrdepth--;
                        if (lrdepth == 0){
                            {
                                free((void*)command);
                                tmp = strdup((const char*)(text));
                            }
                            return (tmp);
                        }
                    }
                    {
                        my_strlcat(text + i, (const char*)command, (size_t)5000);
                        tmp___1 = strlen((const char*)command);
                        i += (int)tmp___1;
                    }
                    if (i > 4950){
                        {
                            diagnostics(0, (char*)"Contents of \\left .. \\right too large.");
                        }
                    }
                    {
                        tmp___2 = strcmp((const char*)command, "\\left");
                    }
                    if (tmp___2 == 0){
                        lrdepth++;
                    }
                    {
                        free((void*)command);
                    }
                }else{
                    text[i] = s;
                    i++;
                    text[i] = (char)'\000';
                }
            }
            while_break:
            ;
        }
        return ((char*)((void*)0));
    }
}

char* getTexUntil(char* target, int raw)
{
    char* s;
    char buffer___0[16000];
    int last_i;
    int i;
    int j;
    int end_of_file_reached;
    int len;
    size_t tmp;
    char tmp___0;
    char tmp___1;
    size_t tmp___2;
    {
        {
            last_i = -1;
            i = 0;
            j = 0;
            end_of_file_reached = 0;
            tmp = strlen((const char*)target);
            len = (int)tmp;
            PushTrackLineNumber(0);
            diagnostics(5, (char*)"getTexUntil target = <%s> raw_search = %d ", target, raw);
        }
        {
            while (1){
                while_continue:
                ;
                if (j < len){
                    if (!(i < 16000)){
                        goto while_break;
                    }
                }else{
                    goto while_break;
                }
                if (i > last_i){
                    if (raw){
                        {
                            tmp___0 = getRawTexChar();
                            buffer___0[i] = tmp___0;
                        }
                    }else{
                        {
                            tmp___1 = getTexChar();
                            buffer___0[i] = tmp___1;
                        }
                    }
                    last_i = i;
                    if ((int)buffer___0[i] != 10){
                        {
                            diagnostics(7, (char*)"next char = <%c>, %d, %d, %d", (int)buffer___0[i], i, j, last_i);
                        }
                    }else{
                        {
                            diagnostics(7, (char*)"next char = <\\n>");
                        }
                    }
                }
                if ((int)buffer___0[i] == 0){
                    {
                        end_of_file_reached = 1;
                        diagnostics(7, (char*)"end of file reached");
                    }
                    goto while_break;
                }
                if ((int)buffer___0[i] != (int)*(target + j)){
                    if (j > 0){
                        {
                            diagnostics(8, (char*)"failed to match target[%d]=<%c> != buffer[%d]=<%c>", j, (int)*(target + j), i, (int)buffer___0[i]);
                            i -= j;
                            j = 0;
                        }
                    }
                }else{
                    j++;
                }
                i++;
            }
            while_break:
            ;
        }
        if (i == 16000){
            {
                diagnostics(0, (char*)"Could not find <%s> in %d characters \n        Recompile with larger BUFFSIZE in getTexUntil() in parser.c", target, 16000);
            }
        }
        if (!end_of_file_reached){
            buffer___0[i - len] = (char)'\000';
        }else{
            {
                diagnostics(0, (char*)"Could not find <%s>", target);
                exit(1);
            }
        }
        {
            PopTrackLineNumber();
            tmp___2 = strlen((const char*)(buffer___0));
            diagnostics(6, (char*)"buffer size =[%d], actual=[%d]", tmp___2, i - len);
            s = strdup((const char*)(buffer___0));
            diagnostics(6, (char*)"getTexUntil result = %s", s);
        }
        return (s);
    }
}

char* getSpacedTexUntil(char* target, int raw)
{
    char buffer___0[16000];
    char* s;
    int buffer_pos;
    int target_pos;
    int target_len;
    int max_buffer_pos;
    int start_pos;
    size_t tmp;
    char tmp___0;
    char tmp___1;
    {
        {
            PushTrackLineNumber(0);
            diagnostics(5, (char*)"getSpacedTexUntil target = <%s> raw_search = %d ", target, raw);
            buffer_pos = 0;
            target_pos = 0;
            start_pos = 0;
            tmp = strlen((const char*)target);
            target_len = (int)tmp;
            max_buffer_pos = -1;
        }
        {
            while (1){
                while_continue:
                ;
                if (buffer_pos > max_buffer_pos){
                    if (raw){
                        {
                            tmp___0 = getRawTexChar();
                            buffer___0[buffer_pos] = tmp___0;
                        }
                    }else{
                        {
                            tmp___1 = getTexChar();
                            buffer___0[buffer_pos] = tmp___1;
                        }
                    }
                    max_buffer_pos = buffer_pos;
                }
                if ((int)buffer___0[buffer_pos] == 0){
                    {
                        diagnostics(0, (char*)"end of file reached before \'%s\' was found", target);
                    }
                }
                if ((int)buffer___0[buffer_pos] == (int)*(target + target_pos)){
                    if (target_pos == 0){
                        start_pos = buffer_pos;
                    }
                    target_pos++;
                }else
                    if ((int)*(target + target_pos) != 124){
                        if (target_pos > 0){
                            buffer_pos = start_pos;
                        }
                        target_pos = 0;
                    }else
                        if ((int)buffer___0[buffer_pos] != 32){
                            if ((int)buffer___0[buffer_pos] != 10){
                                target_pos++;
                                if ((int)buffer___0[buffer_pos] == (int)*(target + target_pos)){
                                    target_pos++;
                                }else{
                                    buffer_pos = start_pos;
                                    target_pos = 0;
                                }
                            }
                        }

                buffer_pos++;
                if (buffer_pos == 16000){
                    {
                        diagnostics(0, (char*)"Could not find <%s> in %d characters \n            Recompile with larger BUFFSIZE in getTexUntil() in parser.c", target, 16000);
                    }
                }
                if (!(target_pos < target_len)){
                    goto while_break;
                }
            }
            while_break:
            ;
        }
        {
            buffer___0[start_pos] = (char)'\000';
            PopTrackLineNumber();
            s = strdup((const char*)(buffer___0));
            diagnostics(6, (char*)"getSpacedTexUntil result = %s", s);
        }
        return (s);
    }
}

int getDimension(void)
{
    char cThis;
    char buffer___0[20];
    int i;
    float num;
    int tmp;
    int tmp___0;
    int tmp___1;
    const unsigned short **tmp___2;
    int tmp___3;
    char tmp___4;
    int tmp___5;
    char tmp___6;
    int tmp___7;
    char tmp___8;
    int tmp___9;
    int tmp___10;
    int tmp___11;
    char* tmp___12;
    char* tmp___13;
    char* tmp___14;
    char* tmp___15;
    char* tmp___16;
    char* tmp___17;
    char* tmp___18;
    char* tmp___19;
    char* tmp___20;
    char* tmp___21;
    char* tmp___22;
    char* tmp___23;
    char* tmp___24;
    char* s;
    char* t;
    int tmp___25;
    {
        {
            i = 0;
            skipSpaces();
            cThis = getTexChar();
        }
        if ((int)cThis == 116){
            {
                getTexChar();
                cThis = getTexChar();
            }
        }
        if ((int)cThis == 115){
            {
                getTexChar();
                getTexChar();
                getTexChar();
                getTexChar();
                getTexChar();
                cThis = getTexChar();
            }
        }
        if ((int)cThis == 45){
            {
                tmp = i;
                i++;
                buffer___0[tmp] = cThis;
                skipSpaces();
                cThis = getTexChar();
            }
        }else
            if ((int)cThis == 43){
                {
                    tmp = i;
                    i++;
                    buffer___0[tmp] = cThis;
                    skipSpaces();
                    cThis = getTexChar();
                }
            }

        if ((int)cThis == 92){
            tmp___0 = i;
            i++;
            buffer___0[tmp___0] = (char)'1';
        }else{
            {
                while (1){
                    while_continue:
                    ;
                    if (i < 19){
                        {
                            tmp___2 = __ctype_b_loc();
                        }
                        if (!((const int)*(*tmp___2 + (int)cThis) & 2048)){
                            if (!((int)cThis == 46)){
                                if (!((int)cThis == 44)){
                                    goto while_break;
                                }
                            }
                        }
                    }else{
                        goto while_break;
                    }
                    if ((int)cThis == 44){
                        cThis = (char)'.';
                    }
                    {
                        tmp___1 = i;
                        i++;
                        buffer___0[tmp___1] = cThis;
                        cThis = getTexChar();
                    }
                }
                while_break:
                ;
            }
        }
        {
            ungetTexChar(cThis);
            buffer___0[i] = (char)'\000';
            diagnostics(4, (char*)"getDimension() raw number is <%s>", buffer___0);
        }
        if (i == 19){
            {
                diagnostics(1, (char*)"Screwy number in TeX dimension");
                diagnostics(1, (char*)"getDimension() number is <%s>", buffer___0);
            }
            return (0);
        }else{
            {
                tmp___3 = sscanf((const char*)(buffer___0), (const char*)"%f", &num);
            }
            if (tmp___3 != 1){
                {
                    diagnostics(1, (char*)"Screwy number in TeX dimension");
                    diagnostics(1, (char*)"getDimension() number is <%s>", buffer___0);
                }
                return (0);
            }
        }
        {
            skipSpaces();
            tmp___4 = getTexChar();
            tmp___5 = tolower((int)tmp___4);
            buffer___0[0] = (char)tmp___5;
        }
        if ((int)buffer___0[0] == 0){
            return ((int)(num * (float)20));
        }
        if ((int)buffer___0[0] == 116){
            {
                getTexChar();
                getTexChar();
                getTexChar();
                skipSpaces();
                tmp___6 = getTexChar();
                tmp___7 = tolower((int)tmp___6);
                buffer___0[0] = (char)tmp___7;
            }
        }
        if ((int)buffer___0[0] != 92){
            {
                tmp___8 = getTexChar();
                tmp___9 = tolower((int)tmp___8);
                buffer___0[1] = (char)tmp___9;
                buffer___0[2] = (char)'\000';
                diagnostics(4, (char*)"getDimension() dimension is <%s>", buffer___0);
                tmp___24 = strstr((const char*)(buffer___0), "pt");
            }
            if (tmp___24){
                return ((int)(num * (float)20));
            }else{
                {
                    tmp___23 = strstr((const char*)(buffer___0), "pc");
                }
                if (tmp___23){
                    return ((int)((num * (float)12) * (float)20));
                }else{
                    {
                        tmp___22 = strstr((const char*)(buffer___0), "in");
                    }
                    if (tmp___22){
                        return ((int)(((double)num * 72.27) * (double)20));
                    }else{
                        {
                            tmp___21 = strstr((const char*)(buffer___0), "bp");
                        }
                        if (tmp___21){
                            return ((int)((((double)num * 72.27) / (double)72) * (double)20));
                        }else{
                            {
                                tmp___20 = strstr((const char*)(buffer___0), "cm");
                            }
                            if (tmp___20){
                                return ((int)((((double)num * 72.27) / 2.54) * (double)20));
                            }else{
                                {
                                    tmp___19 = strstr((const char*)(buffer___0), "mm");
                                }
                                if (tmp___19){
                                    return ((int)((((double)num * 72.27) / 25.4) * (double)20));
                                }else{
                                    {
                                        tmp___18 = strstr((const char*)(buffer___0), "dd");
                                    }
                                    if (tmp___18){
                                        return ((int)((((double)num * 1238.0) / 1157.0) * (double)20));
                                    }else{
                                        {
                                            tmp___17 = strstr((const char*)(buffer___0), "dd");
                                        }
                                        if (tmp___17){
                                            return ((int)((((double)num * 1238.0) / (double)1157) * (double)20));
                                        }else{
                                            {
                                                tmp___16 = strstr((const char*)(buffer___0), "cc");
                                            }
                                            if (tmp___16){
                                                return ((int)(((((double)num * 1238.0) / 1157.0) * 12.0) * (double)20));
                                            }else{
                                                {
                                                    tmp___15 = strstr((const char*)(buffer___0), "sp");
                                                }
                                                if (tmp___15){
                                                    return ((int)(((double)num / 65536.0) * (double)20));
                                                }else{
                                                    {
                                                        tmp___14 = strstr((const char*)(buffer___0), "ex");
                                                    }
                                                    if (tmp___14){
                                                        {
                                                            tmp___10 = CurrentFontSize();
                                                        }
                                                        return ((int)((double)(num * (float)tmp___10) * 0.5));
                                                    }else{
                                                        {
                                                            tmp___13 = strstr((const char*)(buffer___0), "em");
                                                        }
                                                        if (tmp___13){
                                                            {
                                                                tmp___11 = CurrentFontSize();
                                                            }
                                                            return ((int)(num * (float)tmp___11));
                                                        }else{
                                                            {
                                                                tmp___12 = strstr((const char*)(buffer___0), "in");
                                                            }
                                                            if (tmp___12){
                                                                return ((int)(((double)num * 72.27) * (double)20));
                                                            }else{
                                                                {
                                                                    ungetTexChar(buffer___0[1]);
                                                                    ungetTexChar(buffer___0[0]);
                                                                }
                                                                return ((int)num);
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }else{
            {
                ungetTexChar(buffer___0[0]);
                s = getSimpleCommand();
                t = s + 1;
                diagnostics(4, (char*)"getDimension() dimension is <%s>", t);
                tmp___25 = getLength(t);
                num *= (float)tmp___25;
                free((void*)s);
            }
            return ((int)num);
        }
    }
}

int getSlashSlashParam(void)
{
    char cThis;
    char* vertical_space;
    int height;
    {
        {
            height = 0;
            cThis = getTexChar();
        }
        if ((int)cThis != 42){
            {
                ungetTexChar(cThis);
            }
        }
        {
            vertical_space = getBracketParam();
        }
        if (vertical_space){
            {
                height = getStringDimension(vertical_space);
                free((void*)vertical_space);
            }
        }
        return (height);
    }
}

extern double (ceil)(double __x);
extern double (floor)(double __x);
extern int (stat)(const char*restrict  __file, struct stat*restrict  __buf);
extern struct _IO_FILE* stderr;
int g_verbosity_level;
int strstr_count(const char* s, char* t);
char* my_strndup(const char* src, size_t n);
char* strdup_printable(const char* s);
void strncpy_printable(char* dst, char* src, int n);
char* ExtractLabelTag(const char* text);
char* ExtractAndRemoveTag(char* tag, char* text);
void str_blank_out(char* s, const char* target);

int odd(long  n)
{
    {
        return ((int)(n & 1L));
    }
}

int even(long  n)
{
    {
        return (!(n & 1L));
    }
}

double my_rint(double nr)
{
    double f;
    double tmp;
    double c;
    double tmp___0;
    double tmp___1;
    {
        {
            tmp = floor(nr);
            f = tmp;
            tmp___0 = ceil(nr);
            c = tmp___0;
        }
        if (c - nr >= nr - f){
            tmp___1 = f;
        }else{
            tmp___1 = c;
        }
        return (tmp___1);
    }
}

char* my_strcpy(char* dest, const char* src)
{
    char* save;
    char* tmp;
    char tmp___0;
    const char* tmp___1;
    {
        save = dest;
        {
            while (1){
                while_continue:
                ;
                tmp = dest;
                dest++;
                tmp___1 = src;
                src++;
                tmp___0 = (char)*tmp___1;
                *tmp = tmp___0;
                if (!tmp___0){
                    goto while_break;
                }
            }
            while_break:
            ;
        }
        return (save);
    }
}

int strstr_count(const char* s, char* t)
{
    int n;
    size_t len;
    char* p;
    {
        n = 0;
        if ((unsigned long )t == (unsigned long )((void*)0)){
            return (n);
        }else
            if ((unsigned long )s == (unsigned long )((void*)0)){
                return (n);
            }

        {
            len = strlen((const char*)t);
            p = strstr(s, (const char*)t);
        }
        {
            while (1){
                while_continue:
                ;
                if (!p){
                    goto while_break;
                }
                {
                    n++;
                    p = strstr((const char*)((p + len) - 1), (const char*)t);
                }
            }
            while_break:
            ;
        }
        return (n);
    }
}

char* my_strndup(const char* src, size_t n)
{
    char* dst;
    void* tmp;
    {
        {
            tmp = calloc(n + 1UL, sizeof (char));
            dst = (char*)tmp;
        }
        if ((unsigned long )dst == (unsigned long )((void*)0)){
            return ((char*)((void*)0));
        }
        {
            strncpy((char*)dst, (const char*)src, n);
        }
        return (dst);
    }
}

char* strdup_together(const char* s, const char* t)
{
    char* both;
    size_t siz;
    char* tmp;
    char* tmp___0;
    size_t tmp___1;
    size_t tmp___2;
    void* tmp___3;
    {
        if ((unsigned long )s == (unsigned long )((void*)0)){
            if ((unsigned long )t == (unsigned long )((void*)0)){
                return ((char*)((void*)0));
            }
            {
                tmp = strdup(t);
            }
            return (tmp);
        }
        if ((unsigned long )t == (unsigned long )((void*)0)){
            {
                tmp___0 = strdup(s);
            }
            return (tmp___0);
        }
        {
            tmp___1 = strlen(s);
            tmp___2 = strlen(t);
            siz = (tmp___1 + tmp___2) + 1UL;
            tmp___3 = malloc(siz);
            both = (char*)tmp___3;
        }
        if ((unsigned long )both == (unsigned long )((void*)0)){
            {
                diagnostics(0, (char*)"Could not allocate memory for both strings.");
            }
        }
        {
            my_strlcpy(both, s, siz);
            my_strlcat(both, t, siz);
        }
        return (both);
    }
}

char* strdup_together3(const char* s, const char* t, const char* u)
{
    char* two;
    char* three;
    {
        {
            two = strdup_together(s, t);
            three = strdup_together((const char*)two, u);
            free((void*)two);
        }
        return (three);
    }
}

char* strdup_together4(const char* s, const char* t, const char* u, const char* v)
{
    char* four;
    char* three;
    {
        {
            three = strdup_together3(s, t, u);
            four = strdup_together((const char*)three, v);
            free((void*)three);
        }
        return (four);
    }
}

char* strdup_nocomments(const char* s)
{
    char* p;
    char* dup___0;
    size_t tmp;
    void* tmp___0;
    {
        if ((unsigned long )s == (unsigned long )((void*)0)){
            return ((char*)((void*)0));
        }
        {
            tmp = strlen(s);
            tmp___0 = malloc(tmp + 1UL);
            dup___0 = (char*)tmp___0;
            p = dup___0;
        }
        {
            while (1){
                while_continue:
                ;
                if (!*s){
                    goto while_break;
                }
                {
                    while (1){
                        while_continue___0:
                        ;
                        if (!((const int)*s == 37)){
                            goto while_break___0;
                        }
                        s++;
                        {
                            while (1){
                                while_continue___1:
                                ;
                                if (*s){
                                    if (!((const int)*s != 10)){
                                        goto while_break___1;
                                    }
                                }else{
                                    goto while_break___1;
                                }
                                s++;
                            }
                            while_break___1:
                            ;
                        }
                        if ((const int)*s == 0){
                            goto done;
                        }
                        s++;
                    }
                    while_break___0:
                    ;
                }
                *p = (char)*s;
                p++;
                s++;
            }
            while_break:
            ;
        }
        done:
        *p = (char)'\000';
        return (dup___0);
    }
}

char* strdup_noblanks(const char* s)
{
    char* p;
    char* dup___0;
    size_t tmp;
    void* tmp___0;
    {
        if ((unsigned long )s == (unsigned long )((void*)0)){
            return ((char*)((void*)0));
        }
        {
            while (1){
                while_continue:
                ;
                if (!((const int)*s == 32)){
                    if (!((const int)*s == 10)){
                        goto while_break;
                    }
                }
                s++;
            }
            while_break:
            ;
        }
        {
            tmp = strlen(s);
            tmp___0 = malloc(tmp + 1UL);
            dup___0 = (char*)tmp___0;
            p = dup___0;
        }
        {
            while (1){
                while_continue___0:
                ;
                if (!*s){
                    goto while_break___0;
                }
                *p = (char)*s;
                if ((int)*p != 32){
                    if ((int)*p != 10){
                        p++;
                    }
                }
                s++;
            }
            while_break___0:
            ;
        }
        *p = (char)'\000';
        return (dup___0);
    }
}

char* strdup_nobadchars(const char* text)
{
    char* dup___0;
    char* s;
    {
        {
            dup___0 = strdup_noblanks(text);
            s = dup___0;
        }
        {
            while (1){
                while_continue:
                ;
                if (!*s){
                    goto while_break;
                }
                if (97 <= (int)*s){
                    if (!((int)*s <= 122)){
                        goto _L___0;
                    }
                }else
                    _L___0:
                    if (65 <= (int)*s){
                        if (!((int)*s <= 90)){
                            goto _L;
                        }
                    }else
                        _L:
                        if (48 <= (int)*s){
                            if (!((int)*s <= 57)){
                                *s = (char)'_';
                            }
                        }else{
                            *s = (char)'_';
                        }

                s++;
            }
            while_break:
            ;
        }
        return (dup___0);
    }
}

char* strdup_printable(const char* s)
{
    char* dup___0;
    int i;
    size_t tmp;
    void* tmp___0;
    int tmp___1;
    int tmp___2;
    int tmp___3;
    int tmp___4;
    int tmp___5;
    int tmp___6;
    int tmp___7;
    {
        if ((unsigned long )s == (unsigned long )((void*)0)){
            return ((char*)((void*)0));
        }
        {
            tmp = strlen(s);
            tmp___0 = malloc(2UL * tmp);
            dup___0 = (char*)tmp___0;
            i = 0;
        }
        {
            while (1){
                while_continue:
                ;
                if (!*s){
                    goto while_break;
                }
                if ((const int)*s == 13){
                    tmp___1 = i;
                    i++;
                    *(dup___0 + tmp___1) = (char)'\\';
                    tmp___2 = i;
                    i++;
                    *(dup___0 + tmp___2) = (char)'r';
                }else
                    if ((const int)*s == 10){
                        tmp___3 = i;
                        i++;
                        *(dup___0 + tmp___3) = (char)'\\';
                        tmp___4 = i;
                        i++;
                        *(dup___0 + tmp___4) = (char)'n';
                    }else
                        if ((const int)*s == 9){
                            tmp___5 = i;
                            i++;
                            *(dup___0 + tmp___5) = (char)'\\';
                            tmp___6 = i;
                            i++;
                            *(dup___0 + tmp___6) = (char)'t';
                        }else{
                            tmp___7 = i;
                            i++;
                            *(dup___0 + tmp___7) = (char)*s;
                        }

                s++;
            }
            while_break:
            ;
        }
        *(dup___0 + i) = (char)'\000';
        return (dup___0);
    }
}

void strncpy_printable(char* dst, char* src, int n)
{
    int i;
    int tmp;
    int tmp___0;
    int tmp___1;
    int tmp___2;
    int tmp___3;
    int tmp___4;
    int tmp___5;
    {
        i = 0;
        if ((unsigned long )dst == (unsigned long )((void*)0)){
            return;
        }
        {
            while (1){
                while_continue:
                ;
                if (i < n - 1){
                    if (!*src){
                        goto while_break;
                    }
                }else{
                    goto while_break;
                }
                if ((int)*src == 13){
                    tmp = i;
                    i++;
                    *(dst + tmp) = (char)'\\';
                    tmp___0 = i;
                    i++;
                    *(dst + tmp___0) = (char)'r';
                }else
                    if ((int)*src == 10){
                        tmp___1 = i;
                        i++;
                        *(dst + tmp___1) = (char)'\\';
                        tmp___2 = i;
                        i++;
                        *(dst + tmp___2) = (char)'n';
                    }else
                        if ((int)*src == 9){
                            tmp___3 = i;
                            i++;
                            *(dst + tmp___3) = (char)'\\';
                            tmp___4 = i;
                            i++;
                            *(dst + tmp___4) = (char)'t';
                        }else{
                            tmp___5 = i;
                            i++;
                            *(dst + tmp___5) = *src;
                        }

                src++;
            }
            while_break:
            ;
        }
        *(dst + i) = (char)'\000';
        return;
    }
}

char* strdup_noendblanks(const char* s)
{
    char* p;
    char* t;
    char* tmp;
    size_t tmp___0;
    char* tmp___1;
    char* tmp___2;
    {
        if ((unsigned long )s == (unsigned long )((void*)0)){
            return ((char*)((void*)0));
        }
        if ((const int)*s == 0){
            {
                tmp = strdup("");
            }
            return (tmp);
        }
        t = (char*)s;
        {
            while (1){
                while_continue:
                ;
                if (!((int)*t == 32)){
                    if (!((int)*t == 10)){
                        goto while_break;
                    }
                }
                t++;
            }
            while_break:
            ;
        }
        {
            tmp___0 = strlen(s);
            p = ((char*)s + tmp___0) - 1;
        }
        {
            while (1){
                while_continue___0:
                ;
                if ((unsigned long )p >= (unsigned long )t){
                    if (!((int)*p == 32)){
                        if (!((int)*p == 10)){
                            goto while_break___0;
                        }
                    }
                }else{
                    goto while_break___0;
                }
                p--;
            }
            while_break___0:
            ;
        }
        if ((unsigned long )t > (unsigned long )p){
            {
                tmp___1 = strdup("");
            }
            return (tmp___1);
        }
        {
            tmp___2 = my_strndup((const char*)t, (size_t)((p - t) + 1L));
        }
        return (tmp___2);
    }
}

void str_blank_out(char* s, const char* target)
{
    char* p;
    int i;
    int n;
    size_t tmp;
    {
        if ((unsigned long )s == (unsigned long )((void*)0)){
            return;
        }else
            if ((unsigned long )target == (unsigned long )((void*)0)){
                return;
            }else
                if ((const int)*target == 0){
                    return;
                }

        {
            tmp = strlen(target);
            n = (int)tmp;
            p = strstr((const char*)s, target);
        }
        {
            while (1){
                while_continue:
                ;
                if (!p){
                    goto while_break;
                }
                i = 0;
                {
                    while (1){
                        while_continue___0:
                        ;
                        if (!(i < n)){
                            goto while_break___0;
                        }
                        *(p + i) = (char)' ';
                        i++;
                    }
                    while_break___0:
                    ;
                }
                {
                    p = strstr((const char*)(p + n), target);
                }
            }
            while_break:
            ;
        }
        return;
    }
}

void str_delete(char* s, const char* target)
{
    char* p;
    int n;
    size_t tmp;
    {
        if ((unsigned long )s == (unsigned long )((void*)0)){
            return;
        }else
            if ((unsigned long )target == (unsigned long )((void*)0)){
                return;
            }else
                if ((const int)*target == 0){
                    return;
                }

        {
            tmp = strlen(target);
            n = (int)tmp;
            p = s;
        }
        {
            while (1){
                while_continue:
                ;
                {
                    p = strstr((const char*)p, target);
                }
                if (!p){
                    goto while_break;
                }
                {
                    p = my_strcpy(p, (const char*)(p + n));
                }
            }
            while_break:
            ;
        }
        return;
    }
}

char* ExtractLabelTag(const char* text)
{
    char* s;
    char* label_with_spaces;
    char* label;
    size_t tmp;
    const char* tmp___0;
    {
        {
            s = strstr(text, "\\label{");
        }
        if (!s){
            {
                s = strstr(text, "\\label ");
            }
        }
        if (!s){
            return ((char*)((void*)0));
        }
        {
            tmp = strlen("\\label");
            s += tmp;
            PushSource((const char*)((void*)0), (const char*)s);
            label_with_spaces = getBraceParam();
            PopSource();
            label = strdup_nobadchars((const char*)label_with_spaces);
            free((void*)label_with_spaces);
        }
        if (label){
            tmp___0 = (const char*)label;
        }else{
            tmp___0 = "missing";
        }
        {
            diagnostics(4, (char*)"LabelTag = <%s>", tmp___0);
        }
        return (label);
    }
}

char* getStringBraceParam(char** s)
{
    char* p_start;
    char* p;
    char* parameter;
    char last;
    int braces;
    char* tmp;
    const unsigned short **tmp___0;
    char* tmp___1;
    char* tmp___2;
    {
        if ((unsigned long )*s == (unsigned long )((void*)0)){
            {
                tmp = strdup("");
            }
            return (tmp);
        }
        {
            while (1){
                while_continue:
                ;
                if (!((int)*(*s) == 32)){
                    goto while_break;
                }
                (*s)++;
            }
            while_break:
            ;
        }
        if ((int)*(*s) == 10){
            {
                while (1){
                    while_continue___0:
                    ;
                    if (!((int)*(*s) == 32)){
                        goto while_break___0;
                    }
                    (*s)++;
                }
                while_break___0:
                ;
            }
        }
        p_start = *s;
        if ((int)*(*s) == 92){
            {
                while (1){
                    while_continue___1:
                    ;
                    {
                        (*s)++;
                        tmp___0 = __ctype_b_loc();
                    }
                    if (!((const int)*(*tmp___0 + (int)*(*s)) & 1024)){
                        goto while_break___1;
                    }
                }
                while_break___1:
                ;
            }
            {
                diagnostics(1, (char*)"getstringbraceparam \\ before=\'%s\'", *s);
                tmp___1 = my_strndup((const char*)p_start, (size_t)(*s - p_start));
            }
            return (tmp___1);
        }
        if ((int)*(*s) != 123){
            {
                (*s)++;
                tmp___2 = my_strndup((const char*)p_start, (size_t)1);
            }
            return (tmp___2);
        }
        p_start++;
        p = p_start;
        last = (char)'\000';
        braces = 1;
        {
            while (1){
                while_continue___2:
                ;
                if ((int)*p != 0){
                    if (!(braces > 0)){
                        goto while_break___2;
                    }
                }else{
                    goto while_break___2;
                }
                if ((int)*p == 123){
                    if ((int)last != 92){
                        braces++;
                    }
                }
                if ((int)*p == 125){
                    if ((int)last != 92){
                        braces--;
                    }
                }
                last = *p;
                p++;
            }
            while_break___2:
            ;
        }
        {
            parameter = my_strndup((const char*)p_start, (size_t)((p - p_start) - 1L));
            *s = p;
            diagnostics(6, (char*)"Extract parameter=<%s> after=<%s>", parameter, *s);
        }
        return (parameter);
    }
}

char* ExtractAndRemoveTag(char* tag, char* text)
{
    char* s;
    char* contents;
    char* start;
    size_t tmp;
    char* tmp___0;
    char* tmp___1;
    {
        start = (char*)((void*)0);
        if ((unsigned long )text == (unsigned long )((void*)0)){
            return ((char*)((void*)0));
        }else
            if ((int)*text == 0){
                return ((char*)((void*)0));
            }

        {
            s = text;
            diagnostics(5, (char*)"target tag = <%s>", tag);
            diagnostics(5, (char*)"original text = <%s>", text);
        }
        {
            while (1){
                while_continue:
                ;
                if (!s){
                    goto while_break;
                }
                {
                    start = strstr((const char*)s, (const char*)tag);
                }
                if (!start){
                    return ((char*)((void*)0));
                }
                {
                    tmp = strlen((const char*)tag);
                    s = start + tmp;
                }
                if ((int)*s == 32){
                    goto while_break;
                }else
                    if ((int)*s == 123){
                        goto while_break;
                    }
            }
            while_break:
            ;
        }
        {
            contents = getStringBraceParam(&s);
        }
        if ((unsigned long )contents == (unsigned long )((void*)0)){
            return ((char*)((void*)0));
        }
        {
            while (1){
                while_continue___0:
                ;
                tmp___0 = start;
                start++;
                tmp___1 = s;
                s++;
                *tmp___0 = *tmp___1;
                if (!*s){
                    goto while_break___0;
                }
            }
            while_break___0:
            ;
        }
        {
            *start = (char)'\000';
            diagnostics(5, (char*)"final contents = <%s>", contents);
            diagnostics(5, (char*)"final text = <%s>", text);
        }
        return (contents);
    }
}

char* keyvalue_pair(char* s, char** key, char** value)
{
    char* k;
    char* v;
    {
        *key = (char*)((void*)0);
        *value = (char*)((void*)0);
        if ((unsigned long )s == (unsigned long )((void*)0)){
            return ((char*)((void*)0));
        }
        {
            while (1){
                while_continue:
                ;
                if (!((int)*s == 32)){
                    goto while_break;
                }
                s++;
            }
            while_break:
            ;
        }
        if ((int)*s == 0){
            return ((char*)((void*)0));
        }
        k = s;
        {
            while (1){
                while_continue___0:
                ;
                if ((int)*k != 61){
                    if ((int)*k != 44){
                        if (!((int)*k != 0)){
                            goto while_break___0;
                        }
                    }else{
                        goto while_break___0;
                    }
                }else{
                    goto while_break___0;
                }
                k++;
            }
            while_break___0:
            ;
        }
        {
            *key = my_strndup((const char*)s, (size_t)(k - s));
        }
        if ((int)*k == 0){
            return ((char*)((void*)0));
        }
        if ((int)*k == 44){
            return (k + 1);
        }
        s = k + 1;
        {
            while (1){
                while_continue___1:
                ;
                if (!((int)*s == 32)){
                    goto while_break___1;
                }
                s++;
            }
            while_break___1:
            ;
        }
        v = s;
        {
            while (1){
                while_continue___2:
                ;
                if ((int)*v != 44){
                    if (!((int)*v != 0)){
                        goto while_break___2;
                    }
                }else{
                    goto while_break___2;
                }
                if ((int)*v == 123){
                    {
                        while (1){
                            while_continue___3:
                            ;
                            v++;
                            if (!((int)*v != 125)){
                                goto while_break___3;
                            }
                        }
                        while_break___3:
                        ;
                    }
                }else{
                    v++;
                }
            }
            while_break___2:
            ;
        }
        {
            *value = my_strndup((const char*)s, (size_t)(v - s));
        }
        if ((int)*v == 0){
            return ((char*)((void*)0));
        }
        return (v + 1);
    }
}

int getStringDimension(char* s)
{
    int size;
    {
        size = 0;
        if ((unsigned long )s != (unsigned long )((void*)0)){
            {
                PushSource((const char*)((void*)0), (const char*)s);
                size = getDimension();
                PopSource();
            }
        }
        {
            diagnostics(5, (char*)"getStringDimension fore \'%s\' is %d twips", s, size);
        }
        return (size);
    }
}

void show_string(int level, const char* s, const char* label)
{
    int width;
    long i;
    char c;
    long len;
    size_t tmp;
    size_t tmp___0;
    size_t tmp___1;
    {
        width = 100;
        if (g_verbosity_level < level){
            return;
        }
        if ((unsigned long )s == (unsigned long )((void*)0)){
            {
                diagnostics(1, (char*)"\n%s: NULL", label);
            }
            return;
        }
        {
            tmp = strlen(s);
            len = (long )tmp;
            fprintf((FILE*)stderr, (const char*)"\n%s: ", label);
            i = 0L;
        }
        {
            while (1){
                while_continue:
                ;
                if (!(i < len)){
                    goto while_break;
                }
                if (i == (long )width){
                    {
                        tmp___0 = strlen(s);
                        tmp___1 = strlen(label);
                        fprintf((FILE*)stderr, (const char*)"\n%-*d: ", (int)tmp___1, (int)tmp___0);
                    }
                }else
                    if (i > 1L){
                        if (i % (long )width == 0L){
                            {
                                fprintf((FILE*)stderr, (const char*)"\n%s: ", label);
                            }
                        }
                    }

                c = (char)*(s + i);
                if ((int)c == 10){
                    c = (char)'=';
                }
                if ((int)c == 0){
                    c = (char)'*';
                }
                {
                    fprintf((FILE*)stderr, (const char*)"%c", (int)c);
                    i++;
                }
            }
            while_break:
            ;
        }
        return;
    }
}

size_t my_strlcpy(char* dst, const char* src, size_t siz)
{
    char* d;
    const char* s;
    size_t n;
    char* tmp;
    char tmp___0;
    const char* tmp___1;
    const char* tmp___2;
    {
        d = dst;
        s = src;
        n = siz;
        if (n != 0UL){
            {
                while (1){
                    while_continue:
                    ;
                    n--;
                    if (!(n != 0UL)){
                        goto while_break;
                    }
                    tmp = d;
                    d++;
                    tmp___1 = s;
                    s++;
                    tmp___0 = (char)*tmp___1;
                    *tmp = tmp___0;
                    if ((int)tmp___0 == 0){
                        goto while_break;
                    }
                }
                while_break:
                ;
            }
        }
        if (n == 0UL){
            if (siz != 0UL){
                *d = (char)'\000';
            }
            {
                while (1){
                    while_continue___0:
                    ;
                    tmp___2 = s;
                    s++;
                    if (!*tmp___2){
                        goto while_break___0;
                    }
                }
                while_break___0:
                ;
            }
        }
        return ((size_t)((s - src) - 1L));
    }
}

size_t my_strlcat(char* dst, const char* src, size_t siz)
{
    char* d;
    const char* s;
    size_t n;
    size_t dlen;
    size_t tmp;
    size_t tmp___0;
    char* tmp___1;
    {
        d = dst;
        s = src;
        n = siz;
        {
            while (1){
                while_continue:
                ;
                tmp = n;
                n--;
                if (tmp != 0UL){
                    if (!((int)*d != 0)){
                        goto while_break;
                    }
                }else{
                    goto while_break;
                }
                d++;
            }
            while_break:
            ;
        }
        dlen = (size_t)(d - dst);
        n = siz - dlen;
        if (n == 0UL){
            {
                tmp___0 = strlen(s);
            }
            return (dlen + tmp___0);
        }
        {
            while (1){
                while_continue___0:
                ;
                if (!((const int)*s != 0)){
                    goto while_break___0;
                }
                if (n != 1UL){
                    tmp___1 = d;
                    d++;
                    *tmp___1 = (char)*s;
                    n--;
                }
                s++;
            }
            while_break___0:
            ;
        }
        *d = (char)'\000';
        return (dlen + (size_t)(s - src));
    }
}

int file_exists(char* fname)
{
    int result;
    struct stat fStat;
    int tmp;
    {
        {
            result = 0;
            tmp = stat((const char*)fname, (struct stat*)(&fStat));
            result = tmp == 0;
            diagnostics(5, (char*)"file_exists(%s) returns %d", fname, result);
        }
        return (result);
    }
}

int my_fgetc(FILE* f)
{
    int c;
    int tmp;
    {
        {
            c = fgetc(f);
            tmp = feof(f);
        }
        if (tmp){
            return ('\000');
        }
        if (c == 13){
            {
                c = fgetc(f);
            }
            if (c == 10){
                return ('\n');
            }
            {
                ungetc(c, f);
            }
            return ('\n');
        }
        if (c == 10){
            return ('\n');
        }
        if (c == 9){
            return (' ');
        }
        return (c);
    }
}

int xmy_fgets(char* buffer___0, int maxBuffer, FILE* f)
{
    int i;
    int tmp;
    {
        i = 0;
        {
            while (1){
                while_continue:
                ;
                if (!(i < maxBuffer)){
                    goto while_break;
                }
                {
                    tmp = my_fgetc(f);
                    *(buffer___0 + i) = (char)tmp;
                }
                if ((int)*(buffer___0 + i) == 0){
                    return (i);
                }
                if ((int)*(buffer___0 + i) == 10){
                    *(buffer___0 + i) = (char)'\000';
                    i--;
                    if (i >= 0){
                        if ((int)*(buffer___0 + i) != 92){
                            return (i);
                        }
                        i--;
                    }
                }
                i++;
            }
            while_break:
            ;
        }
        *(buffer___0 + maxBuffer) = (char)'\000';
        return (maxBuffer);
    }
}

char* my_fgets(char* buffer___0, int maxBuffer, FILE* f)
{
    int i;
    int cLast;
    int tmp;
    int tmp___0;
    {
        cLast = '\000';
        if ((unsigned long )f == (unsigned long )((void*)0)){
            return ((char*)((void*)0));
        }else{
            {
                tmp = feof(f);
            }
            if (tmp){
                return ((char*)((void*)0));
            }
        }
        i = 0;
        {
            while (1){
                while_continue:
                ;
                if (!(i < maxBuffer)){
                    goto while_break;
                }
                {
                    tmp___0 = my_fgetc(f);
                    *(buffer___0 + i) = (char)tmp___0;
                }
                if ((int)*(buffer___0 + i) == 0){
                    return (buffer___0);
                }
                if ((int)*(buffer___0 + i) == 10){
                    if (cLast == 92){
                        *(buffer___0 + i) = (char)' ';
                    }else{
                        goto while_break;
                    }
                }
                cLast = (int)*(buffer___0 + i);
                i++;
            }
            while_break:
            ;
        }
        *(buffer___0 + i) = (char)'\000';
        return (buffer___0);
    }
}

extern struct _IO_FILE* stdout;
extern int fflush(FILE* __stream);
extern int printf(const char*restrict  __format, ...);
extern int vfprintf(FILE*restrict  __s, const char*restrict  __format, __gnuc_va_list __arg);
extern int (vsnprintf)(char*restrict  __s, size_t __maxlen, const char*restrict  __format, __gnuc_va_list __arg);
extern char* (getenv)(const char* __name);
char* g_toc_name;
char* g_lof_name;
char* g_lot_name;
char* progname;
int twocolumn;
int titlepage;
int g_processing_equation;
int g_enumerate_depth;
int g_aux_file_missing;
char* g_config_path;
int g_latex_figures;
int g_tabular_display_rtf;
int g_tabular_display_bitmap;
char* my_strdup(const char* str);
void debug_malloc(void);
int CurrentEnvironmentCount(void);
void PushFontSettings(void);
void PopFontSettings(void);
void MonitorFontChanges(const unsigned char* text);
int BraceLevel;
void InitializeStack(void);
char* Version = (char*)"2.1.1 r1179 (2012-05-29 14:14:00 UTC)";
void ReadCfg(void);
FILE* open_cfg(const char* name, int quit_on_error);
void WriteEightBitChar(unsigned char cThis, FILE* f);
FILE* fRtf = (FILE*)((void*)0);
char* g_tex_name = (char*)((void*)0);
char* g_rtf_name = (char*)((void*)0);
char* g_aux_name = (char*)((void*)0);
char* g_toc_name = (char*)((void*)0);
char* g_lof_name = (char*)((void*)0);
char* g_lot_name = (char*)((void*)0);
char* g_fff_name = (char*)((void*)0);
char* g_ttt_name = (char*)((void*)0);
char* g_bbl_name = (char*)((void*)0);
char* g_home_dir = (char*)((void*)0);
int SpanishMode = 0;
int GermanMode = 0;
int FrenchMode = 0;
int RussianMode = 0;
int CzechMode = 0;
int twoside = 0;
int g_verbosity_level = 1;
int g_little_endian = 0;
uint16_t g_dots_per_inch = (uint16_t)300;
int pagenumbering = 1;
int headings = 0;
int g_processing_preamble = 1;
int g_processing_figure = 0;
int g_processing_eqnarray = 0;
int g_processing_arrays = 0;
int g_show_equation_number = 0;
int g_enumerate_depth = 0;
int g_suppress_equation_number = 0;
int g_aux_file_missing = 0;
int g_bbl_file_missing = 0;
int g_document_type = 1;
int g_document_bibstyle = 1;
int g_safety_braces = 0;
int g_processing_equation = 0;
int g_RTF_warnings = 0;
char* g_config_path = (char*)((void*)0);
char* g_script_dir = (char*)((void*)0);
char* g_tmp_dir = (char*)((void*)0);
char* g_preamble = (char*)((void*)0);
int g_escape_parens = 0;
char* g_package_babel = (char*)((void*)0);
int g_equation_display_rtf = 1;
int g_equation_inline_rtf = 1;
int g_equation_inline_bitmap = 0;
int g_equation_display_bitmap = 0;
int g_equation_comment = 0;
int g_equation_raw_latex = 0;
int g_tableofcontents = 0;
int g_tabular_display_rtf = 1;
int g_tabular_display_bitmap = 0;
int g_tab_counter = 0;
int g_processing_table = 0;
int g_processing_tabbing = 0;
int g_processing_tabular = 0;
double g_png_equation_scale = 1.00;
double g_png_figure_scale = 1.00;
int g_latex_figures = 0;
int g_endfloat_figures = 0;
int g_endfloat_tables = 0;
int g_endfloat_markers = 1;
int g_graphics_package = 0;
int indent = 0;
char alignment = (char)'j';
int RecursionLevel = 0;
int twocolumn = 0;
int titlepage = 0;
static void OpenRtfFile(char* filename, FILE** f);
static void CloseRtf(FILE** f);
static void ConvertLatexPreamble(void);
static void InitializeLatexLengths(void);
static void SetEndianness(void);
static void ConvertWholeDocument(void);
static void print_usage(void);
static void print_version(void);

int main(int argc, char** argv)
{
    int c;
    int x;
    char* p;
    char* basename;
    double xx;
    int tmp;
    int tmp___0;
    char* s;
    char* t;
    char* ext;
    size_t tmp___1;
    int tmp___2;
    int tmp___3;
    int tmp___4;
    const char* tmp___5;
    int tmp___6;
    int tmp___7;
    {
        {
            basename = (char*)((void*)0);
            SetEndianness();
            progname = *(argv + 0);
            InitializeStack();
            InitializeLatexLengths();
            InitializeBibliography();
        }
        {
            while (1){
                while_continue:
                ;
                {
                    c = my_getopt(argc, argv, (char*)"lhpuvFSVWZ:o:a:b:d:f:i:s:u:C:D:M:P:T:t:");
                }
                if (!(c != -1)){
                    goto while_break;
                }
                {
                    if (c == 97){
                        goto case_97;
                    }
                    if (c == 98){
                        goto case_98;
                    }
                    if (c == 100){
                        goto case_100;
                    }
                    if (c == 102){
                        goto case_102;
                    }
                    if (c == 105){
                        goto case_105;
                    }
                    if (c == 108){
                        goto case_108;
                    }
                    if (c == 111){
                        goto case_111;
                    }
                    if (c == 112){
                        goto case_112;
                    }
                    if (c == 118){
                        goto case_118;
                    }
                    if (c == 67){
                        goto case_67;
                    }
                    if (c == 68){
                        goto case_68;
                    }
                    if (c == 70){
                        goto case_70;
                    }
                    if (c == 77){
                        goto case_77;
                    }
                    if (c == 116){
                        goto case_116;
                    }
                    if (c == 80){
                        goto case_80;
                    }
                    if (c == 115){
                        goto case_115;
                    }
                    if (c == 83){
                        goto case_83;
                    }
                    if (c == 84){
                        goto case_84;
                    }
                    if (c == 86){
                        goto case_86;
                    }
                    if (c == 87){
                        goto case_87;
                    }
                    if (c == 90){
                        goto case_90;
                    }
                    goto switch_default;
                    case_97:
                    g_aux_name = optarg;
                    goto switch_break;
                    case_98:
                    g_bbl_name = optarg;
                    goto switch_break;
                    case_100:
                    g_verbosity_level = (int)*optarg - 48;
                    if (g_verbosity_level < 0){
                        {
                            diagnostics(1, (char*)"debug level (-d# option) must be 0-7");
                            print_usage();
                        }
                    }else
                        if (g_verbosity_level > 7){
                            {
                                diagnostics(1, (char*)"debug level (-d# option) must be 0-7");
                                print_usage();
                            }
                        }

                    goto switch_break;
                    case_102:
                    {
                        sscanf((const char*)optarg, (const char*)"%d", &x);
                        set_fields_use_EQ(x & 1);
                        set_fields_use_REF(x & 2);
                    }
                    goto switch_break;
                    case_105:
                    {
                        g_package_babel = strdup((const char*)optarg);
                    }
                    goto switch_break;
                    case_108:
                    {
                        g_package_babel = strdup("latin");
                    }
                    goto switch_break;
                    case_111:
                    {
                        g_rtf_name = strdup((const char*)optarg);
                    }
                    goto switch_break;
                    case_112:
                    g_escape_parens = 1;
                    goto switch_break;
                    case_118:
                    {
                        print_version();
                    }
                    return (0);
                    case_67:
                    {
                        setPackageInputenc(optarg);
                    }
                    goto switch_break;
                    case_68:
                    {
                        sscanf((const char*)optarg, (const char*)"%d", &x);
                        g_dots_per_inch = (uint16_t)x;
                    }
                    if ((int)g_dots_per_inch < 25){
                        {
                            diagnostics(1, (char*)"Dots per inch must be between 25 and 600 dpi\n");
                        }
                    }else
                        if ((int)g_dots_per_inch > 600){
                            {
                                diagnostics(1, (char*)"Dots per inch must be between 25 and 600 dpi\n");
                            }
                        }

                    goto switch_break;
                    case_70:
                    g_latex_figures = 1;
                    goto switch_break;
                    case_77:
                    {
                        sscanf((const char*)optarg, (const char*)"%d", &x);
                        diagnostics(3, (char*)"Math option = %s x=%d", optarg, x);
                    }
                    if (x & 1){
                        g_equation_display_rtf = 1;
                    }else{
                        g_equation_display_rtf = 0;
                    }
                    if (x & 2){
                        g_equation_inline_rtf = 1;
                    }else{
                        g_equation_inline_rtf = 0;
                    }
                    if (x & 4){
                        g_equation_display_bitmap = 1;
                    }else{
                        g_equation_display_bitmap = 0;
                    }
                    if (x & 8){
                        g_equation_inline_bitmap = 1;
                    }else{
                        g_equation_inline_bitmap = 0;
                    }
                    if (x & 16){
                        g_equation_comment = 1;
                    }else{
                        g_equation_comment = 0;
                    }
                    if (x & 32){
                        g_equation_raw_latex = 1;
                    }else{
                        g_equation_raw_latex = 0;
                    }
                    {
                        diagnostics(3, (char*)"Math option g_equation_display_rtf    = %d", g_equation_display_rtf);
                        diagnostics(3, (char*)"Math option g_equation_inline_rtf     = %d", g_equation_inline_rtf);
                        diagnostics(3, (char*)"Math option g_equation_display_bitmap = %d", g_equation_display_bitmap);
                        diagnostics(3, (char*)"Math option g_equation_inline_bitmap  = %d", g_equation_inline_bitmap);
                        diagnostics(3, (char*)"Math option g_equation_comment        = %d", g_equation_comment);
                        diagnostics(3, (char*)"Math option g_equation_raw_latex      = %d", g_equation_raw_latex);
                    }
                    if (!g_equation_comment){
                        if (!g_equation_inline_rtf){
                            if (!g_equation_inline_bitmap){
                                if (!g_equation_raw_latex){
                                    g_equation_inline_rtf = 1;
                                }
                            }
                        }
                    }
                    if (!g_equation_comment){
                        if (!g_equation_display_rtf){
                            if (!g_equation_display_bitmap){
                                if (!g_equation_raw_latex){
                                    g_equation_display_rtf = 1;
                                }
                            }
                        }
                    }
                    goto switch_break;
                    case_116:
                    {
                        sscanf((const char*)optarg, (const char*)"%d", &x);
                        diagnostics(3, (char*)"Table option = %s x=%d", optarg, x);
                    }
                    if (x & 1){
                        g_tabular_display_rtf = 1;
                    }else{
                        g_tabular_display_rtf = 0;
                    }
                    if (x & 2){
                        g_tabular_display_bitmap = 1;
                    }else{
                        g_tabular_display_bitmap = 0;
                    }
                    {
                        diagnostics(3, (char*)"Table option g_tabular_display_rtf     = %d", g_tabular_display_rtf);
                        diagnostics(3, (char*)"Table option g_tabular_display_bitmap  = %d", g_tabular_display_bitmap);
                    }
                    goto switch_break;
                    case_80:
                    {
                        p = strchr((const char*)optarg, ':');
                    }
                    if (p){
                        {
                            *p = (char)'\000';
                            g_script_dir = strdup((const char*)(p + 1));
                        }
                    }
                    if ((unsigned long )p != (unsigned long )optarg){
                        {
                            g_config_path = strdup((const char*)optarg);
                        }
                    }
                    {
                        diagnostics(2, (char*)"cfg=%s, script=%s", g_config_path, g_script_dir);
                    }
                    goto switch_break;
                    case_115:
                    if (optarg){
                        if ((int)*(optarg + 0) == 101){
                            {
                                tmp = sscanf((const char*)optarg, (const char*)"e%lf", &xx);
                            }
                            if (tmp == 1){
                                if (xx > (double)0){
                                    g_png_equation_scale = xx;
                                }else{
                                    {
                                        diagnostics(1, (char*)"Mistake in command line number for scaling equations");
                                        diagnostics(1, (char*)"Either use no spaces: \'-se1.22\' or write as \'-s e1.22\'");
                                    }
                                }
                            }else{
                                {
                                    diagnostics(1, (char*)"Mistake in command line number for scaling equations");
                                    diagnostics(1, (char*)"Either use no spaces: \'-se1.22\' or write as \'-s e1.22\'");
                                }
                            }
                        }else{
                            goto _L;
                        }
                    }else
                        _L:
                        if (optarg){
                            if ((int)*(optarg + 0) == 102){
                                {
                                    tmp___0 = sscanf((const char*)optarg, (const char*)"f%lf", &xx);
                                }
                                if (tmp___0 == 1){
                                    if (xx > (double)0){
                                        g_png_figure_scale = xx;
                                    }else{
                                        {
                                            diagnostics(1, (char*)"Mistake in command line number for scaling figures");
                                            diagnostics(1, (char*)"Either use no spaces: \'-sf1.35\' or write as \'-s f1.35\'");
                                        }
                                    }
                                }else{
                                    {
                                        diagnostics(1, (char*)"Mistake in command line number for scaling figures");
                                        diagnostics(1, (char*)"Either use no spaces: \'-sf1.35\' or write as \'-s f1.35\'");
                                    }
                                }
                            }else{
                                {
                                    diagnostics(1, (char*)"Unknown option \'-s\' use \'-se#\' or \'-sf#\'");
                                }
                            }
                        }else{
                            {
                                diagnostics(1, (char*)"Unknown option \'-s\' use \'-se#\' or \'-sf#\'");
                            }
                        }
                    goto switch_break;
                    case_83:
                    g_field_separator = (char)';';
                    goto switch_break;
                    case_84:
                    {
                        g_tmp_dir = strdup((const char*)optarg);
                    }
                    goto switch_break;
                    case_86:
                    {
                        print_version();
                    }
                    return (0);
                    case_87:
                    g_RTF_warnings = 1;
                    goto switch_break;
                    case_90:
                    g_safety_braces = 0;
                    g_safety_braces = (int)*optarg - 48;
                    if (g_safety_braces < 0){
                        {
                            diagnostics(1, (char*)"Number of safety braces (-Z#) must be 0-9");
                            print_usage();
                        }
                    }else
                        if (g_safety_braces > 9){
                            {
                                diagnostics(1, (char*)"Number of safety braces (-Z#) must be 0-9");
                                print_usage();
                            }
                        }

                    goto switch_break;
                    switch_default:
                    {
                        print_usage();
                    }
                    switch_break:
                    ;
                }
            }
            while_break:
            ;
        }
        argc -= optind;
        argv += optind;
        if (argc > 1){
            {
                diagnostics(1, (char*)"Only a single file can be processed at a time");
                diagnostics(0, (char*)" Type \"latex2rtf -h\" for help");
            }
        }
        if (argc == 1){
            {
                tmp___4 = strcmp((const char*)*argv, "-");
            }
            if (tmp___4 != 0){
                {
                    basename = strdup((const char*)*argv);
                    s = strrchr((const char*)basename, '/');
                }
                if ((unsigned long )s != (unsigned long )((void*)0)){
                    {
                        g_home_dir = strdup((const char*)basename);
                        t = strdup((const char*)(s + 1));
                        free((void*)basename);
                        basename = t;
                        s = strrchr((const char*)g_home_dir, '/');
                        *(s + 1) = (char)'\000';
                    }
                }
                {
                    tmp___1 = strlen((const char*)basename);
                    ext = (basename + tmp___1) - 4;
                    tmp___2 = strcmp((const char*)ext, ".tex");
                }
                if (tmp___2 == 0){
                    {
                        g_tex_name = strdup((const char*)basename);
                        *ext = (char)'\000';
                    }
                }else{
                    {
                        tmp___3 = strcmp((const char*)ext, ".ltx");
                    }
                    if (tmp___3 == 0){
                        {
                            g_tex_name = strdup((const char*)basename);
                            *ext = (char)'\000';
                        }
                    }else{
                        {
                            g_tex_name = strdup_together((const char*)basename, ".tex");
                        }
                    }
                }
                if ((unsigned long )g_rtf_name == (unsigned long )((void*)0)){
                    {
                        g_rtf_name = strdup_together3((const char*)g_home_dir, (const char*)basename, ".rtf");
                    }
                }
            }
        }
        if ((unsigned long )g_aux_name == (unsigned long )((void*)0)){
            if ((unsigned long )basename != (unsigned long )((void*)0)){
                {
                    g_aux_name = strdup_together((const char*)basename, ".aux");
                }
            }
        }
        if ((unsigned long )g_bbl_name == (unsigned long )((void*)0)){
            if ((unsigned long )basename != (unsigned long )((void*)0)){
                {
                    g_bbl_name = strdup_together((const char*)basename, ".bbl");
                }
            }
        }
        if ((unsigned long )g_toc_name == (unsigned long )((void*)0)){
            if ((unsigned long )basename != (unsigned long )((void*)0)){
                {
                    g_toc_name = strdup_together((const char*)basename, ".toc");
                }
            }
        }
        if ((unsigned long )g_lof_name == (unsigned long )((void*)0)){
            if ((unsigned long )basename != (unsigned long )((void*)0)){
                {
                    g_lof_name = strdup_together((const char*)basename, ".lof");
                }
            }
        }
        if ((unsigned long )g_lot_name == (unsigned long )((void*)0)){
            if ((unsigned long )basename != (unsigned long )((void*)0)){
                {
                    g_lot_name = strdup_together((const char*)basename, ".lot");
                }
            }
        }
        if ((unsigned long )g_fff_name == (unsigned long )((void*)0)){
            if ((unsigned long )basename != (unsigned long )((void*)0)){
                {
                    g_fff_name = strdup_together((const char*)basename, ".fff");
                }
            }
        }
        if ((unsigned long )g_ttt_name == (unsigned long )((void*)0)){
            if ((unsigned long )basename != (unsigned long )((void*)0)){
                {
                    g_ttt_name = strdup_together((const char*)basename, ".ttt");
                }
            }
        }
        if (basename){
            {
                diagnostics(2, (char*)"latex filename is <%s>", g_tex_name);
                diagnostics(2, (char*)"  rtf filename is <%s>", g_rtf_name);
                diagnostics(2, (char*)"  aux filename is <%s>", g_aux_name);
                diagnostics(2, (char*)"  bbl filename is <%s>", g_bbl_name);
            }
            if (g_home_dir){
                tmp___5 = (const char*)g_home_dir;
            }else{
                tmp___5 = "";
            }
            {
                diagnostics(2, (char*)"home directory is <%s>", tmp___5);
            }
        }
        {
            ReadCfg();
            tmp___7 = PushSource((const char*)g_tex_name, (const char*)((void*)0));
        }
        if (tmp___7 == 0){
            {
                OpenRtfFile(g_rtf_name, &fRtf);
                tmp___6 = TexFontNumber("Roman");
                InitializeDocumentFont(tmp___6, 20, 13, 1, 11);
                PushTrackLineNumber(1);
                ConvertWholeDocument();
                PopSource();
                CloseRtf(&fRtf);
                printf((const char*)"\n");
            }
            return (0);
        }else{
            {
                printf((const char*)"\n");
            }
            return (1);
        }
    }
}

static void SetEndianness(void)
{
    unsigned int endian_test;
    unsigned char endian_test_char;
    {
        endian_test = 2864434397U;
        endian_test_char = *((unsigned char*)(&endian_test));
        if ((int)endian_test_char == 221){
            g_little_endian = 1;
        }
        return;
    }
}

static void ConvertWholeDocument(void)
{
    char* body;
    char* sec_head;
    char* sec_head2;
    char* label;
    char t[17];
    int tmp;
    int tmp___0;
    int tmp___1;
    int tmp___2;
    {
        {
            t[0] = (char)'\\';
            t[1] = (char)'b';
            t[2] = (char)'e';
            t[3] = (char)'g';
            t[4] = (char)'i';
            t[5] = (char)'n';
            t[6] = (char)'{';
            t[7] = (char)'d';
            t[8] = (char)'o';
            t[9] = (char)'c';
            t[10] = (char)'u';
            t[11] = (char)'m';
            t[12] = (char)'e';
            t[13] = (char)'n';
            t[14] = (char)'t';
            t[15] = (char)'}';
            t[16] = (char)'\000';
            PushEnvironment(2);
            PushEnvironment(1);
            setTexMode(6);
            ConvertLatexPreamble();
            setPackageBabel(g_package_babel);
            WriteRtfHeader();
            ConvertString((const char*)(t));
            g_processing_preamble = 0;
            preParse(&body, &sec_head, &label);
            diagnostics(2, (char*)"\\begin{document}");
            diagnostics(5, (char*)"label for this section is\'%s\'", label);
            diagnostics(5, (char*)"next section \'%s\'", sec_head);
            show_string(2, (const char*)body, "body ");
            ConvertString((const char*)body);
            free((void*)body);
        }
        if (label){
            {
                free((void*)label);
            }
        }
        {
            while (1){
                while_continue:
                ;
                {
                    tmp = strcmp((const char*)sec_head, "\\end{document}");
                }
                if (!(tmp != 0)){
                    goto while_break;
                }
                {
                    preParse(&body, &sec_head2, &g_section_label);
                    label = ExtractLabelTag((const char*)sec_head);
                }
                if (label){
                    if (g_section_label){
                        {
                            free((void*)g_section_label);
                        }
                    }
                    g_section_label = label;
                }
                {
                    diagnostics(2, (char*)"processing \'%s\'", sec_head);
                    diagnostics(5, (char*)"label is   \'%s\'", g_section_label);
                    diagnostics(5, (char*)"next  is   \'%s\'", sec_head2);
                    show_string(2, (const char*)body, "body ");
                    ConvertString((const char*)sec_head);
                    ConvertString((const char*)body);
                    free((void*)body);
                    free((void*)sec_head);
                    sec_head = sec_head2;
                }
            }
            while_break:
            ;
        }
        if (g_endfloat_figures){
            if (g_fff_name){
                {
                    g_endfloat_figures = 0;
                    tmp___0 = PushSource((const char*)g_fff_name, (const char*)((void*)0));
                }
                if (tmp___0 == 0){
                    {
                        CmdNewPage(1);
                        CmdListOf(1);
                        Convert();
                    }
                }
            }
        }
        if (g_endfloat_tables){
            if (g_ttt_name){
                {
                    g_endfloat_tables = 0;
                    tmp___1 = PushSource((const char*)g_ttt_name, (const char*)((void*)0));
                }
                if (tmp___1 == 0){
                    {
                        CmdNewPage(1);
                        CmdListOf(2);
                        Convert();
                    }
                }
            }
        }
        {
            tmp___2 = strcmp((const char*)sec_head, "\\end{document}");
        }
        if (tmp___2 == 0){
            {
                diagnostics(2, (char*)"\\end{document}");
                ConvertString((const char*)sec_head);
            }
        }
        return;
    }
}

static void print_version(void)
{
    {
        {
            fprintf((FILE*)stdout, (const char*)"latex2rtf %s\n\n", Version);
            fprintf((FILE*)stdout, (const char*)"Copyright (C) 2010 Free Software Foundation, Inc.\n");
            fprintf((FILE*)stdout, (const char*)"This is free software; see the source for copying conditions.  There is NO\n");
            fprintf((FILE*)stdout, (const char*)"warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n\n");
            fprintf((FILE*)stdout, (const char*)"Written by Prahl, Lehner, Granzer, Dorner, Polzer, Trisko, Schlatterbeck.\n");
        }
        return;
    }
}

static void print_usage(void)
{
    char* s;
    const char* tmp;
    const char* tmp___0;
    {
        {
            fprintf((FILE*)stdout, (const char*)"`%s\' converts text files in LaTeX format to rich text format (RTF).\n\n", progname);
            fprintf((FILE*)stdout, (const char*)"Usage:  %s [options] input[.tex]\n\n", progname);
            fprintf((FILE*)stdout, (const char*)"Options:\n");
            fprintf((FILE*)stdout, (const char*)"  -a auxfile       use LaTeX auxfile rather than input.aux\n");
            fprintf((FILE*)stdout, (const char*)"  -b bblfile       use BibTex bblfile rather than input.bbl\n");
            fprintf((FILE*)stdout, (const char*)"  -C codepage      charset used by the latex document (latin1, cp850, raw, etc.)\n");
            fprintf((FILE*)stdout, (const char*)"  -d level         debugging output (level is 0-6)\n");
            fprintf((FILE*)stdout, (const char*)"  -f#              field handling\n");
            fprintf((FILE*)stdout, (const char*)"       -f0          do not use fields\n");
            fprintf((FILE*)stdout, (const char*)"       -f1          use fields for equations but not \\ref{} & \\cite{}\n");
            fprintf((FILE*)stdout, (const char*)"       -f2          use fields for \\cite{} & \\ref{}, but not equations\n");
            fprintf((FILE*)stdout, (const char*)"       -f3          use fields when possible (default)\n");
            fprintf((FILE*)stdout, (const char*)"  -F               use LaTeX to convert all figures to bitmaps\n");
            fprintf((FILE*)stdout, (const char*)"  -D dpi           number of dots per inch for bitmaps\n");
            fprintf((FILE*)stdout, (const char*)"  -h               display help\n");
            fprintf((FILE*)stdout, (const char*)"  -i language      idiom or language (e.g., german, french)\n");
            fprintf((FILE*)stdout, (const char*)"  -l               use latin1 encoding (default)\n");
            fprintf((FILE*)stdout, (const char*)"  -M#              math equation handling\n");
            fprintf((FILE*)stdout, (const char*)"       -M1          displayed equations to RTF\n");
            fprintf((FILE*)stdout, (const char*)"       -M2          inline equations to RTF\n");
            fprintf((FILE*)stdout, (const char*)"       -M3          inline and displayed equations to RTF (default)\n");
            fprintf((FILE*)stdout, (const char*)"       -M4          displayed equations to bitmap\n");
            fprintf((FILE*)stdout, (const char*)"       -M6          inline equations to RTF and displayed equations to bitmaps\n");
            fprintf((FILE*)stdout, (const char*)"       -M8          inline equations to bitmap\n");
            fprintf((FILE*)stdout, (const char*)"       -M12         inline and displayed equations to bitmaps\n");
            fprintf((FILE*)stdout, (const char*)"       -M16         insert Word comment field that the original equation text\n");
            fprintf((FILE*)stdout, (const char*)"       -M32         insert the raw LaTeX equation delimited by $...$ and \\[...\\]\n");
            fprintf((FILE*)stdout, (const char*)"  -o outputfile    file for RTF output\n");
            fprintf((FILE*)stdout, (const char*)"  -p               option to avoid bug in Word for some equations\n");
            fprintf((FILE*)stdout, (const char*)"  -P path          paths to *.cfg & latex2png\n");
            fprintf((FILE*)stdout, (const char*)"  -S               use \';\' to separate args in RTF fields\n");
            fprintf((FILE*)stdout, (const char*)"  -se#             scale factor for bitmap equations\n");
            fprintf((FILE*)stdout, (const char*)"  -sf#             scale factor for bitmap figures\n");
            fprintf((FILE*)stdout, (const char*)"  -t#              table handling\n");
            fprintf((FILE*)stdout, (const char*)"       -t1          tabular and tabbing environments as RTF\n");
            fprintf((FILE*)stdout, (const char*)"       -t2          tabular and tabbing environments as bitmaps\n");
            fprintf((FILE*)stdout, (const char*)"  -T /path/to/tmp  temporary directory\n");
            fprintf((FILE*)stdout, (const char*)"  -v               version information\n");
            fprintf((FILE*)stdout, (const char*)"  -V               version information\n");
            fprintf((FILE*)stdout, (const char*)"  -W               include warnings in RTF\n");
            fprintf((FILE*)stdout, (const char*)"  -Z#              add # of \'}\'s at end of rtf file (# is 0-9)\n\n");
            fprintf((FILE*)stdout, (const char*)"Examples:\n");
            fprintf((FILE*)stdout, (const char*)"  latex2rtf foo                       convert foo.tex to foo.rtf\n");
            fprintf((FILE*)stdout, (const char*)"  latex2rtf <foo >foo.RTF             convert foo to foo.RTF\n");
            fprintf((FILE*)stdout, (const char*)"  latex2rtf -P ./cfg/:./scripts/ foo  use alternate cfg and latex2png files\n");
            fprintf((FILE*)stdout, (const char*)"  latex2rtf -M12 foo                  replace equations with bitmaps\n");
            fprintf((FILE*)stdout, (const char*)"  latex2rtf -t3  foo                  tables as RTF *and* bitmaps\n");
            fprintf((FILE*)stdout, (const char*)"  latex2rtf -i russian foo            assume russian tex conventions\n");
            fprintf((FILE*)stdout, (const char*)"  latex2rtf -C raw foo                retain font encoding in rtf file\n");
            fprintf((FILE*)stdout, (const char*)"  latex2rtf -f0 foo                   create foo.rtf without fields\n");
            fprintf((FILE*)stdout, (const char*)"  latex2rtf -d4 foo                   lots of debugging information\n\n");
            fprintf((FILE*)stdout, (const char*)"Report bugs to <latex2rtf-developers@lists.sourceforge.net>\n\n");
            fprintf((FILE*)stdout, (const char*)"$RTFPATH designates the directory for configuration files (*.cfg)\n");
            s = getenv("RTFPATH");
        }
        if (s){
            tmp = (const char*)s;
        }else{
            tmp = "not defined";
        }
        {
            fprintf((FILE*)stdout, (const char*)"$RTFPATH = \'%s\'\n\n", tmp);
            s = (char*)"/usr/local/share/latex2rtf/cfg";
            fprintf((FILE*)stdout, (const char*)"CFGDIR compiled-in directory for configuration files (*.cfg)\n");
        }
        if (s){
            tmp___0 = (const char*)s;
        }else{
            tmp___0 = "not defined";
        }
        {
            fprintf((FILE*)stdout, (const char*)"CFGDIR  = \'%s\'\n\n", tmp___0);
            fprintf((FILE*)stdout, (const char*)"latex2rtf %s\n", Version);
            exit(1);
        }
    }
}

static int first = 1;

void diagnostics(int level, char* format, ...)
{
    char buffer___0[512];
    char* buff_ptr;
    va_list apf;
    int i;
    int tmp;
    char* tmp___0;
    {
        {
            buff_ptr = buffer___0;
            __builtin_va_start(apf, format);
        }
        if (level <= g_verbosity_level){
            {
                CurrentEnvironmentCount();
            }
            if (!first){
                {
                    fprintf((FILE*)stderr, (const char*)"\n");
                }
            }
            {
                tmp = CurrentLineNumber();
                tmp___0 = CurrentFileName();
                fprintf((FILE*)stderr, (const char*)"%s:%-3d ", tmp___0, tmp);
            }
            {
                if (level == 0){
                    goto case_0;
                }
                if (level == 1){
                    goto case_1;
                }
                if (level == 6){
                    goto case_6;
                }
                if (level == 5){
                    goto case_6;
                }
                if (level == 4){
                    goto case_4;
                }
                if (level == 3){
                    goto case_4;
                }
                if (level == 2){
                    goto case_4;
                }
                goto switch_default;
                case_0:
                {
                    fprintf((FILE*)stderr, (const char*)"Error! ");
                }
                goto switch_break;
                case_1:
                if (g_RTF_warnings){
                    {
                        vsnprintf((char*)(buffer___0), (size_t)512, (const char*)format, apf);
                        fprintRTF((char*)"{\\plain\\cf2 [latex2rtf:");
                    }
                    {
                        while (1){
                            while_continue:
                            ;
                            if (!*buff_ptr){
                                goto while_break;
                            }
                            {
                                putRtfCharEscaped(*buff_ptr);
                                buff_ptr++;
                            }
                        }
                        while_break:
                        ;
                    }
                    {
                        fprintRTF((char*)"]}");
                    }
                }
                goto switch_break;
                case_6:
                case_5:
                {
                    fprintf((FILE*)stderr, (const char*)" rec=%d ", RecursionLevel);
                }
                case_4:
                case_3:
                case_2:
                i = 0;
                {
                    while (1){
                        while_continue___0:
                        ;
                        if (!(i < BraceLevel)){
                            goto while_break___0;
                        }
                        {
                            fprintf((FILE*)stderr, (const char*)"{");
                            i++;
                        }
                    }
                    while_break___0:
                    ;
                }
                i = 8;
                {
                    while (1){
                        while_continue___1:
                        ;
                        if (!(i > BraceLevel)){
                            goto while_break___1;
                        }
                        {
                            fprintf((FILE*)stderr, (const char*)" ");
                            i--;
                        }
                    }
                    while_break___1:
                    ;
                }
                i = 0;
                {
                    while (1){
                        while_continue___2:
                        ;
                        if (!(i < RecursionLevel)){
                            goto while_break___2;
                        }
                        {
                            fprintf((FILE*)stderr, (const char*)"  ");
                            i++;
                        }
                    }
                    while_break___2:
                    ;
                }
                goto switch_break;
                switch_default:
                goto switch_break;
                switch_break:
                ;
            }
            {
                vfprintf((FILE*)stderr, (const char*)format, apf);
                first = 0;
            }
        }
        {
            __builtin_va_end(apf);
        }
        if (level == 0){
            {
                fprintf((FILE*)stderr, (const char*)"\n");
                fflush(stderr);
            }
            if (fRtf){
                {
                    fflush(fRtf);
                }
            }
            {
                exit(1);
            }
        }
        return;
    }
}

static void InitializeLatexLengths(void)
{
    {
        {
            setLength((char*)"pageheight", 15900);
            setLength((char*)"hoffset", 0);
            setLength((char*)"oddsidemargin", 1240);
            setLength((char*)"headheight", 240);
            setLength((char*)"textheight", 11000);
            setLength((char*)"footskip", 600);
            setLength((char*)"marginparpush", 100);
            setLength((char*)"pagewidth", 12280);
            setLength((char*)"voffset", 0);
            setLength((char*)"topmargin", 360);
            setLength((char*)"headsep", 500);
            setLength((char*)"textwidth", 6900);
            setLength((char*)"columnwidth", 6900);
            setLength((char*)"linewidth", 6900);
            setLength((char*)"columnsep", 200);
            setLength((char*)"evensidemargin", 220);
            setLength((char*)"baselineskip", 240);
            setLength((char*)"parindent", 300);
            setLength((char*)"parskip", 0);
            setCounter((char*)"page", 0);
            setCounter((char*)"part", 0);
            setCounter((char*)"chapter", 0);
            setCounter((char*)"section", 0);
            setCounter((char*)"subsection", 0);
            setCounter((char*)"subsubsection", 0);
            setCounter((char*)"paragraph", 0);
            setCounter((char*)"subparagraph", 0);
            setCounter((char*)"figure", 0);
            setCounter((char*)"table", 0);
            setCounter((char*)"equation", 0);
            setCounter((char*)"footnote", 0);
            setCounter((char*)"mpfootnote", 0);
            setCounter((char*)"secnumdepth", 2);
            setCounter((char*)"endfloatfigure", 0);
            setCounter((char*)"endfloattable", 0);
            setLength((char*)"topsep", 60);
            setLength((char*)"partopsep", 40);
            setLength((char*)"parsep", (int)(2.5 * (double)20));
            setLength((char*)"itemsep", 0);
            setLength((char*)"labelwidth", 0);
            setLength((char*)"labelsep", 0);
            setLength((char*)"itemindent", 0);
            setLength((char*)"listparindent", 0);
            setLength((char*)"leftmargin", 0);
            setLength((char*)"floatsep", 0);
            setLength((char*)"intextsep", 0);
            setLength((char*)"textfloatsep", 0);
            setLength((char*)"abovedisplayskip", 0);
            setLength((char*)"belowdisplayskip", 0);
            setLength((char*)"abovecaptionskip", 0);
            setLength((char*)"belowcaptionskip", 0);
            setLength((char*)"intextsep", 0);
            setLength((char*)"smallskipamount", 60);
            setLength((char*)"medskipamount", 120);
            setLength((char*)"bigskipamount", 240);
            setLength((char*)"marginparsep", 200);
        }
        return;
    }
}

static void ConvertLatexPreamble(void)
{
    char t[20];
    FILE* rtf_file;
    {
        {
            t[0] = (char)'\\';
            t[1] = (char)'b';
            t[2] = (char)'e';
            t[3] = (char)'g';
            t[4] = (char)'i';
            t[5] = (char)'n';
            t[6] = (char)'|';
            t[7] = (char)'{';
            t[8] = (char)'|';
            t[9] = (char)'d';
            t[10] = (char)'o';
            t[11] = (char)'c';
            t[12] = (char)'u';
            t[13] = (char)'m';
            t[14] = (char)'e';
            t[15] = (char)'n';
            t[16] = (char)'t';
            t[17] = (char)'|';
            t[18] = (char)'}';
            t[19] = (char)'\000';
            rtf_file = fRtf;
            fRtf = stderr;
            g_preamble = getSpacedTexUntil(t, 1);
            diagnostics(2, (char*)"Read LaTeX Preamble");
            diagnostics(5, (char*)"Entering ConvertString() from ConvertLatexPreamble");
            show_string(5, (const char*)g_preamble, "preamble");
            ConvertString((const char*)g_preamble);
            diagnostics(5, (char*)"Exiting ConvertString() from ConvertLatexPreamble");
            fRtf = rtf_file;
        }
        return;
    }
}

static void OpenRtfFile(char* filename, FILE** f)
{
    {
        if ((unsigned long )filename == (unsigned long )((void*)0)){
            {
                diagnostics(4, (char*)"Writing RTF to stdout");
                *f = stdout;
            }
        }else{
            {
                *f = fopen((const char*)filename, (const char*)"w");
            }
            if ((unsigned long )*f == (unsigned long )((void*)0)){
                {
                    diagnostics(0, (char*)"Error opening RTF file <%s>\n", filename);
                }
            }
            {
                diagnostics(2, (char*)"Opened RTF file <%s>", filename);
            }
        }
        return;
    }
}

static void CloseRtf(FILE** f)
{
    int i;
    int tmp;
    {
        {
            CmdEndParagraph(0);
        }
        if (BraceLevel > 1){
            {
                diagnostics(1, (char*)"Mismatched \'{\' in RTF file, Conversion may cause problems.");
                diagnostics(1, (char*)"This is often caused by having environments that span ");
                diagnostics(1, (char*)"\\section{}s.  For example ");
                diagnostics(1, (char*)"   \\begin{small} ... \\section{A} ... \\section{B} ... \\end{small}");
                diagnostics(1, (char*)"will definitely fail.");
            }
        }
        if (BraceLevel - 1 > g_safety_braces){
            {
                diagnostics(1, (char*)"Try translating with \'latex2rtf -Z%d %s\'", BraceLevel - 1, g_tex_name);
            }
        }
        {
            fprintf((FILE*)*f, (const char*)"}\n");
            i = 0;
        }
        {
            while (1){
                while_continue:
                ;
                if (!(i < g_safety_braces)){
                    goto while_break;
                }
                {
                    fprintf((FILE*)*f, (const char*)"}");
                    i++;
                }
            }
            while_break:
            ;
        }
        if ((unsigned long )*f != (unsigned long )stdout){
            {
                tmp = fclose(*f);
            }
            if (tmp == -1){
                {
                    diagnostics(1, (char*)"Error closing RTF-File");
                }
            }
        }
        {
            *f = (FILE*)((void*)0);
            diagnostics(4, (char*)"Closed RTF file");
            fprintf((FILE*)stderr, (const char*)"\n");
        }
        return;
    }
}

void putRtfCharEscaped(char cThis)
{
    int tmp;
    {
        {
            tmp = getTexMode();
        }
        if (tmp == 6){
            {
                changeTexMode(2);
            }
        }
        if ((int)cThis == 92){
            {
                fprintRTF((char*)"%s", "\\\\");
            }
        }else
            if ((int)cThis == 123){
                {
                    fprintRTF((char*)"%s", "\\{");
                }
            }else
                if ((int)cThis == 125){
                    {
                        fprintRTF((char*)"%s", "\\}");
                    }
                }else
                    if ((int)cThis == 10){
                        {
                            fprintRTF((char*)"%s", "\n\\par ");
                        }
                    }else{
                        {
                            fprintRTF((char*)"%c", (int)cThis);
                        }
                    }

        return;
    }
}

void putRtfStrEscaped(const char* string)
{
    char* s;
    char* tmp;
    {
        s = (char*)string;
        if ((unsigned long )string == (unsigned long )((void*)0)){
            return;
        }
        {
            while (1){
                while_continue:
                ;
                if (!*s){
                    goto while_break;
                }
                {
                    tmp = s;
                    s++;
                    putRtfCharEscaped(*tmp);
                }
            }
            while_break:
            ;
        }
        return;
    }
}

void fprintRTF(char* format, ...)
{
    char buffer___0[1024];
    unsigned char* text;
    char last;
    va_list apf;
    {
        {
            last = (char)'\000';
            __builtin_va_start(apf, format);
            vsnprintf((char*)(buffer___0), (size_t)1024, (const char*)format, apf);
            __builtin_va_end(apf);
            text = (unsigned char*)(buffer___0);
        }
        {
            while (1){
                while_continue:
                ;
                if (!*text){
                    goto while_break;
                }
                {
                    WriteEightBitChar(*(text + 0), fRtf);
                }
                if ((int)*text == 123){
                    if ((int)last != 92){
                        {
                            PushFontSettings();
                        }
                    }
                }
                if ((int)*text == 125){
                    if ((int)last != 92){
                        {
                            PopFontSettings();
                        }
                    }
                }
                if ((int)*text == 92){
                    if ((int)last != 92){
                        {
                            MonitorFontChanges((const unsigned char*)text);
                        }
                    }
                }
                last = (char)*text;
                text++;
            }
            while_break:
            ;
        }
        return;
    }
}

char* getTmpPath(void)
{
    size_t n;
    char* t;
    char* u;
    char pathsep_str[2];
    size_t tmp;
    {
        t = (char*)((void*)0);
        u = (char*)((void*)0);
        pathsep_str[0] = (char)'/';
        pathsep_str[1] = (char)0;
        if (g_tmp_dir){
            {
                t = strdup((const char*)g_tmp_dir);
            }
        }else{
            {
                u = getenv("TMPDIR");
            }
            if ((unsigned long )u != (unsigned long )((void*)0)){
                {
                    t = strdup((const char*)u);
                }
            }
        }
        if ((unsigned long )t == (unsigned long )((void*)0)){
            {
                t = strdup("/tmp/");
            }
        }
        {
            tmp = strlen((const char*)t);
            n = tmp - 1UL;
        }
        if (n > 1UL){
            if ((int)*(t + n) != 47){
                {
                    u = strdup_together((const char*)t, (const char*)(pathsep_str));
                    free((void*)t);
                    t = u;
                }
            }
        }
        return (t);
    }
}

char* my_strdup(const char* str)
{
    char* s;
    unsigned long strsize;
    size_t tmp;
    void* tmp___0;
    {
        {
            s = (char*)((void*)0);
            tmp = strlen(str);
            strsize = tmp + 1UL;
            tmp___0 = malloc(strsize);
            s = (char*)tmp___0;
            *s = (char)'\000';
        }
        if ((unsigned long )s == (unsigned long )((void*)0)){
            {
                diagnostics(0, (char*)"Cannot allocate memory to duplicate string");
            }
        }
        {
            my_strlcpy(s, str, strsize);
        }
        return (s);
    }
}

FILE* my_fopen(char* path, char* mode)
{
    char* name;
    FILE* p;
    FILE* tmp;
    char* tmp___0;
    {
        if ((unsigned long )path == (unsigned long )((void*)0)){
            return ((FILE*)((void*)0));
        }else
            if ((unsigned long )mode == (unsigned long )((void*)0)){
                return ((FILE*)((void*)0));
            }

        if ((unsigned long )g_home_dir == (unsigned long )((void*)0)){
            {
                name = strdup((const char*)path);
            }
        }else{
            {
                name = strdup_together((const char*)g_home_dir, (const char*)path);
            }
        }
        {
            p = fopen((const char*)name, (const char*)mode);
        }
        if ((unsigned long )p == (unsigned long )((void*)0)){
            {
                tmp___0 = strstr((const char*)path, ".tex");
            }
            if ((unsigned long )tmp___0 != (unsigned long )((void*)0)){
                {
                    tmp = open_cfg((const char*)path, 0);
                    p = tmp;
                }
            }
        }else{
            {
                diagnostics(2, (char*)"Opened \'%s\'", name);
            }
        }
        if ((unsigned long )p == (unsigned long )((void*)0)){
            {
                diagnostics(1, (char*)"Cannot open \'%s\'", name);
                fflush((FILE*)((void*)0));
            }
        }
        {
            free((void*)name);
        }
        return (p);
    }
}

void debug_malloc(void)
{
    char c;
    {
        {
            diagnostics(2, (char*)"Malloc Debugging --- press return to continue");
            fflush((FILE*)((void*)0));
        }
        if (2 <= g_verbosity_level){
            {
                fscanf((FILE*)stdin, (const char*)"%c", &c);
                c = (char)((int)c + 1);
            }
        }
        return;
    }
}

extern void* (bsearch)(const void* __key, const void* __base, size_t __nmemb, size_t __size, int (*__compar)(const void*, const void*));
extern void (__assert_fail)(const char* __assertion, const char* __file, unsigned int __line, const char* __function);
char* GetBabelName(char* name);
ConfigEntryT** SearchCfgEntry(const char* theTexCommand, int WhichCfg);
ConfigEntryT** SearchCfgEntryByID(const int id, int WhichCfg);
ConfigEntryT** CfgNext(int WhichCfg, ConfigEntryT** last);
static ConfigInfoT configinfo[5] = {{(char*)"direct.cfg", (ConfigEntryT**)((void*)0), 0, 0}, {(char*)"fonts.cfg", (ConfigEntryT**)((void*)0), 0, 0}, {(char*)"ignore.cfg", (ConfigEntryT**)((void*)0), 0, 0}, {(char*)"style.cfg", (ConfigEntryT**)((void*)0), 0, 0}, {(char*)"english.cfg", (ConfigEntryT**)((void*)0), 0, 0}};
char* ReadUptoMatch(FILE* infile, const char* scanchars);

static int cfg_compare(ConfigEntryT** el1, ConfigEntryT** el2)
{
    int tmp;
    {
        {
            tmp = strcmp((*el1)->TexCommand, (*el2)->TexCommand);
        }
        return (tmp);
    }
}

static FILE* try_path(const char* path, const char* cfg_file)
{
    char* both;
    FILE* fp;
    char separator[2];
    size_t tmp;
    {
        separator[0] = (char)'/';
        separator[1] = (char)'\000';
        if ((unsigned long )path == (unsigned long )((void*)0)){
            return ((FILE*)((void*)0));
        }else
            if ((unsigned long )cfg_file == (unsigned long )((void*)0)){
                return ((FILE*)((void*)0));
            }

        {
            tmp = strlen(path);
        }
        if ((const int)*(path + tmp) != 47){
            {
                both = strdup_together3(path, (const char*)(separator), cfg_file);
            }
        }else{
            {
                both = strdup_together(path, cfg_file);
            }
        }
        {
            diagnostics(2, (char*)"trying to open \'%s\'", both);
            fp = fopen((const char*)both, (const char*)"rb");
            free((void*)both);
        }
        return (fp);
    }
}

static FILE* open_path(const char* path, const char* name, const char* subdir)
{
    FILE* fp;
    char* pf;
    char* tmp;
    char* p;
    char* p1;
    char* tmp___0;
    char* pft;
    char* tmp___1;
    {
        {
            fp = (FILE*)((void*)0);
            tmp = strdup(path);
            pf = tmp;
            p = pf;
        }
        {
            while (1){
                while_continue:
                ;
                if (!((unsigned long )((void*)0) != (unsigned long )p)){
                    goto while_break;
                }
                {
                    tmp___0 = strchr((const char*)p, ':');
                    p1 = tmp___0;
                }
                if ((unsigned long )((void*)0) != (unsigned long )p1){
                    *p1 = (char)'\000';
                }
                if ((unsigned long )((void*)0) != (unsigned long )subdir){
                    {
                        tmp___1 = strdup_together((const char*)p, subdir);
                        pft = tmp___1;
                        fp = try_path((const char*)pft, name);
                        free((void*)pft);
                    }
                }else{
                    {
                        fp = try_path((const char*)p, name);
                    }
                }
                if ((unsigned long )((void*)0) != (unsigned long )fp){
                    goto while_break;
                }
                if (p1){
                    p = p1 + 1;
                }else{
                    p = (char*)((void*)0);
                }
            }
            while_break:
            ;
        }
        {
            free((void*)pf);
        }
        return (fp);
    }
}

static FILE* open_env(const char* env, const char* name, const char* subdir)
{
    FILE* result;
    char* p;
    char* tmp;
    {
        {
            result = (FILE*)((void*)0);
            tmp = getenv(env);
            p = tmp;
        }
        if ((unsigned long )((void*)0) != (unsigned long )p){
            {
                result = open_path((const char*)p, name, subdir);
            }
        }
        return (result);
    }
}

FILE* open_cfg(const char* name, int quit_on_error)
{
    FILE* fp;
    char* tmp;
    {
        {
            fp = try_path((const char*)g_config_path, name);
        }
        if (fp){
            return (fp);
        }
        {
            fp = open_env("RTFPATH", name, (const char*)((void*)0));
        }
        if ((unsigned long )((void*)0) != (unsigned long )fp){
            return (fp);
        }
        {
            fp = open_env("PROGRAMFILES", name, "/latex2rtf/cfg");
        }
        if ((unsigned long )((void*)0) != (unsigned long )fp){
            return (fp);
        }
        {
            fp = open_path("/usr/local/share/latex2rtf/cfg", name, (const char*)((void*)0));
        }
        if ((unsigned long )((void*)0) != (unsigned long )fp){
            return (fp);
        }
        if (quit_on_error){
            {
                diagnostics(1, (char*)"Cannot open the latex2rtf config file \'%s\'", name);
                diagnostics(1, (char*)"Locate the directory containing the .cfg files and");
                diagnostics(1, (char*)"   (1) define the environment variable RTFPATH, *or*");
                diagnostics(1, (char*)"   (2) use command line path option \"-P /path/to/cfg/file\", *or*");
                diagnostics(1, (char*)"   (3) recompile latex2rtf with CFGDIR defined properly");
                tmp = getenv("RTFPATH");
                diagnostics(1, (char*)"Current RTFPATH: %s", tmp);
                diagnostics(1, (char*)"Current  CFGDIR: %s", "/usr/local/share/latex2rtf/cfg");
                diagnostics(0, (char*)" Giving up.  Please don\'t hate me.");
            }
        }
        return ((FILE*)((void*)0));
    }
}

static int read_cfg(FILE* cfgfile, ConfigEntryT*** pointer_array, int do_remove_backslash)
{
    int bufindex;
    int bufsize___0;
    char* line;
    char* cmdend;
    void* tmp;
    const unsigned short **tmp___0;
    void* tmp___1;
    void* tmp___2;
    {
        bufindex = 0;
        bufsize___0 = 0;
        if ((unsigned long )*pointer_array == (unsigned long )((void*)0)){
            {
                tmp = malloc(1024UL * sizeof (char*));
                *pointer_array = (struct ConfigEntryT**)tmp;
                bufsize___0 = 1024;
            }
            if ((unsigned long )*pointer_array == (unsigned long )((void*)0)){
                {
                    diagnostics(0, (char*)"Cannot allocate memory for pointer list");
                }
            }
        }
        {
            while (1){
                while_continue:
                ;
                {
                    line = ReadUptoMatch(cfgfile, "\n");
                }
                if (!((unsigned long )line != (unsigned long )((void*)0))){
                    goto while_break;
                }
                {
                    _IO_getc(cfgfile);
                }
                {
                    while (1){
                        while_continue___0:
                        ;
                        {
                            tmp___0 = __ctype_b_loc();
                        }
                        if (!((const int)*(*tmp___0 + (int)((unsigned char)*line)) & 8192)){
                            goto while_break___0;
                        }
                        line++;
                    }
                    while_break___0:
                    ;
                }
                if ((int)*line == 35){
                    goto while_continue;
                }
                if ((int)*line == 0){
                    goto while_continue;
                }
                {
                    cmdend = strrchr((const char*)line, '.');
                }
                if ((unsigned long )cmdend == (unsigned long )((void*)0)){
                    {
                        diagnostics(0, (char*)"Bad config file, missing final period\nBad line is \"%s\"", line);
                        exit(1);
                    }
                }
                *cmdend = (char)'\000';
                if (do_remove_backslash){
                    if ((int)*line != 92){
                        {
                            diagnostics(0, (char*)"Bad config file, missing initial\'\\\'\nBad line is\"%s\"", line);
                        }
                    }else{
                        line++;
                    }
                }
                if (bufindex >= bufsize___0){
                    {
                        bufsize___0 += 1024;
                        tmp___1 = realloc((void*)*pointer_array, (unsigned long )bufsize___0 * sizeof (char*));
                        *pointer_array = (struct ConfigEntryT**)tmp___1;
                    }
                    if ((unsigned long )*pointer_array == (unsigned long )((void*)0)){
                        {
                            diagnostics(0, (char*)"Cannot allocate memory for pointer list");
                        }
                    }
                }
                {
                    line = strdup((const char*)line);
                    cmdend = strchr((const char*)line, ',');
                }
                if ((unsigned long )cmdend == (unsigned long )((void*)0)){
                    {
                        diagnostics(0, (char*)"Bad config file, missing \',\' between elements\nBad line is\"%s\"", line);
                        exit(1);
                    }
                }
                {
                    *cmdend = (char)'\000';
                    tmp___2 = malloc(sizeof (ConfigEntryT));
                    *(*pointer_array + bufindex) = (struct ConfigEntryT*)tmp___2;
                }
                if ((unsigned long )*(*pointer_array + bufindex) == (unsigned long )((void*)0)){
                    {
                        diagnostics(0, (char*)"Cannot allocate memory for config entry");
                    }
                }
                {
                    (*(*pointer_array + bufindex))->TexCommand = (const char*)line;
                    (*(*pointer_array + bufindex))->RtfCommand = (const char*)(cmdend + 1);
                    (*(*pointer_array + bufindex))->original_id = bufindex;
                    bufindex++;
                    diagnostics(6, (char*)"%3d Tex=\'%s\' RTF=\'%s\'", bufindex, line, cmdend + 1);
                }
            }
            while_break:
            ;
        }
        {
            qsort((void*)*pointer_array, (size_t)bufindex, sizeof (*(*pointer_array)), (int(*)(const void*, const void*))(&cfg_compare));
        }
        return (bufindex);
    }
}

void ReadCfg(void)
{
    int i;
    FILE* fp;
    char* fname;
    FILE* tmp;
    {
        i = 0;
        {
            while (1){
                while_continue:
                ;
                if (!(i < 5)){
                    goto while_break;
                }
                {
                    fname = configinfo[i].filename;
                    tmp = open_cfg((const char*)fname, 1);
                    fp = tmp;
                    configinfo[i].config_info_size = read_cfg(fp, &configinfo[i].config_info, configinfo[i].remove_leading_backslash);
                    fclose(fp);
                    diagnostics(2, (char*)"read %d entries for file %s", configinfo[i].config_info_size, fname);
                    i++;
                }
            }
            while_break:
            ;
        }
        return;
    }
}

ConfigEntryT** SearchCfgEntry(const char* theTexCommand, int WhichCfg)
{
    ConfigEntryT compare_item;
    ConfigEntryT* compare_ptr;
    ConfigEntryT** p;
    ConfigEntryT** base;
    int size;
    void* tmp___1;
    {
        compare_item.TexCommand = theTexCommand;
        compare_item.RtfCommand = "";
        compare_item.original_id = 0;
        compare_ptr = &compare_item;
        size = configinfo[WhichCfg].config_info_size;
        base = configinfo[WhichCfg].config_info;
        if ((unsigned long )theTexCommand == (unsigned long )((void*)0)){
            return ((ConfigEntryT**)((void*)0));
        }
        if (WhichCfg >= 0){
            if (!(WhichCfg < 5)){
                {
                    __assert_fail("WhichCfg >= 0 && WhichCfg < CONFIG_SIZE", "/home/khheo/project/bingo-ci-experiment/benchmark/latex2rtf-2.1.1/cfg.c", 325U, "SearchCfgEntry");
                }
            }
        }else{
            {
                __assert_fail("WhichCfg >= 0 && WhichCfg < CONFIG_SIZE", "/home/khheo/project/bingo-ci-experiment/benchmark/latex2rtf-2.1.1/cfg.c", 325U, "SearchCfgEntry");
            }
        }
        if (!((unsigned long )configinfo[WhichCfg].config_info != (unsigned long )((void*)0))){
            {
                __assert_fail("configinfo[WhichCfg].config_info != NULL", "/home/khheo/project/bingo-ci-experiment/benchmark/latex2rtf-2.1.1/cfg.c", 326U, "SearchCfgEntry");
            }
        }
        {
            diagnostics(5, (char*)"seeking \'%s\' in %d of size %d  ", theTexCommand, WhichCfg, size);
            tmp___1 = bsearch((const void*)(&compare_ptr), (const void*)base, (size_t)size, sizeof (compare_ptr), (int(*)(const void*, const void*))(&cfg_compare));
            p = (ConfigEntryT**)tmp___1;
        }
        if (p){
            {
                diagnostics(5, (char*)"seeking \'%s\'  found \'%s\'", theTexCommand, (*p)->TexCommand);
            }
        }
        return (p);
    }
}

ConfigEntryT** SearchCfgEntryByID(const int id, int WhichCfg)
{
    int i;
    int max;
    ConfigEntryT** entry;
    {
        max = configinfo[WhichCfg].config_info_size;
        if (id > (const int)max){
            return ((ConfigEntryT**)((void*)0));
        }
        entry = configinfo[WhichCfg].config_info;
        i = 0;
        {
            while (1){
                while_continue:
                ;
                if (!(i < max)){
                    goto while_break;
                }
                if (id == (const int)(*entry)->original_id){
                    return (entry);
                }
                entry++;
                i++;
            }
            while_break:
            ;
        }
        return ((ConfigEntryT**)((void*)0));
    }
}

char* SearchCfgRtf(const char* theTexCommand, int WhichCfg)
{
    ConfigEntryT** p;
    {
        {
            p = SearchCfgEntry(theTexCommand, WhichCfg);
        }
        if ((unsigned long )p == (unsigned long )((void*)0)){
            return ((char*)((void*)0));
        }else{
            return ((char*)(*p)->RtfCommand);
        }
    }
}

ConfigEntryT** CfgStartIterate(void)
{
    {
        return ((ConfigEntryT**)((void*)0));
    }
}

ConfigEntryT** CfgNext(int WhichCfg, ConfigEntryT** last)
{
    {
        if ((unsigned long )last == (unsigned long )((void*)0)){
            return (configinfo[WhichCfg].config_info);
        }
        last++;
        if ((unsigned long )last > (unsigned long )((configinfo[WhichCfg].config_info + configinfo[WhichCfg].config_info_size) - 1)){
            return ((ConfigEntryT**)((void*)0));
        }
        return (last);
    }
}

ConfigEntryT** CfgNextByInsertion(int WhichCfg, ConfigEntryT** last)
{
    int next_id;
    ConfigEntryT** tmp;
    {
        if ((unsigned long )last == (unsigned long )((void*)0)){
            next_id = 0;
        }else{
            next_id = (*last)->original_id + 1;
        }
        {
            tmp = SearchCfgEntryByID((const int)next_id, WhichCfg);
        }
        return (tmp);
    }
}

void ReadLanguage(char* lang)
{
    FILE* fp;
    char* langfn;
    FILE* tmp;
    {
        if ((unsigned long )lang == (unsigned long )((void*)0)){
            return;
        }
        {
            langfn = strdup_together((const char*)lang, ".cfg");
            tmp = open_cfg((const char*)langfn, 1);
            fp = tmp;
            free((void*)langfn);
        }
        if ((unsigned long )fp == (unsigned long )((void*)0)){
            return;
        }
        {
            configinfo[4].config_info_size = read_cfg(fp, &configinfo[4].config_info, configinfo[4].remove_leading_backslash);
            fclose(fp);
        }
        return;
    }
}

void ConvertBabelName(char* name)
{
    char* s;
    char* tmp;
    {
        {
            tmp = SearchCfgRtf((const char*)name, 4);
            s = tmp;
        }
        if ((unsigned long )s != (unsigned long )((void*)0)){
            {
                ConvertString((const char*)s);
            }
        }
        return;
    }
}

char* GetBabelName(char* name)
{
    char* s;
    {
        {
            s = (char*)((void*)0);
            s = SearchCfgRtf((const char*)name, 4);
        }
        return (s);
    }
}

static char* buffer = (char*)((void*)0);
static int bufsize = 0;

char* ReadUptoMatch(FILE* infile, const char* scanchars)
{
    int bufindex;
    int c;
    int tmp;
    void* tmp___0;
    char* tmp___1;
    int tmp___2;
    void* tmp___3;
    {
        {
            bufindex = 0;
            tmp = feof(infile);
        }
        if (tmp != 0){
            return ((char*)((void*)0));
        }
        if ((unsigned long )buffer == (unsigned long )((void*)0)){
            {
                tmp___0 = malloc(1024UL * sizeof (char));
                buffer = (char*)tmp___0;
            }
            if ((unsigned long )buffer == (unsigned long )((void*)0)){
                {
                    diagnostics(0, (char*)"Cannot allocate memory for input buffer");
                    exit(1);
                }
            }
            bufsize = 1024;
        }
        {
            while (1){
                while_continue:
                ;
                {
                    c = _IO_getc(infile);
                }
                if (!(c != -1)){
                    goto while_break;
                }
                if (c == 13){
                    c = '\n';
                }else
                    if (c == 10){
                        c = '\n';
                    }

                {
                    tmp___1 = strchr(scanchars, c);
                }
                if (tmp___1){
                    goto while_break;
                }
                if (c == 0){
                    goto while_continue;
                }
                tmp___2 = bufindex;
                bufindex++;
                *(buffer + tmp___2) = (char)c;
                if (bufindex >= bufsize){
                    {
                        bufsize += 1024;
                        tmp___3 = realloc((void*)buffer, (size_t)bufsize);
                        buffer = (char*)tmp___3;
                    }
                    if ((unsigned long )buffer == (unsigned long )((void*)0)){
                        {
                            diagnostics(0, (char*)"Cannot allocate memory for input buffer");
                            exit(1);
                        }
                    }
                }
            }
            while_break:
            ;
        }
        *(buffer + bufindex) = (char)'\000';
        if (c != -1){
            {
                ungetc(c, infile);
            }
        }
        return (buffer);
    }
}

void Ignore_Environment(char* cCommand);

static void IgnoreCmd(void)
{
    char c;
    const unsigned short **tmp;
    {
        {
            while (1){
                while_continue:
                ;
                {
                    c = getTexChar();
                }
                if (c){
                    if (!((int)c != 92)){
                        goto while_break;
                    }
                }else{
                    goto while_break;
                }
            }
            while_break:
            ;
        }
        {
            while (1){
                while_continue___0:
                ;
                {
                    c = getTexChar();
                }
                if (c){
                    {
                        tmp = __ctype_b_loc();
                    }
                    if (!((const int)*(*tmp + (int)c) & 1024)){
                        goto while_break___0;
                    }
                }else{
                    goto while_break___0;
                }
            }
            while_break___0:
            ;
        }
        {
            ungetTexChar(c);
        }
        return;
    }
}

static void IgnoreNumber(void)
{
    char c;
    const unsigned short **tmp;
    {
        {
            c = getNonSpace();
        }
        if ((int)c == 61){
            {
                c = getNonSpace();
            }
        }
        {
            while (1){
                while_continue:
                ;
                if (!((int)c == 45)){
                    if (!((int)c == 43)){
                        if (!((int)c == 46)){
                            {
                                tmp = __ctype_b_loc();
                            }
                            if (!((const int)*(*tmp + (int)c) & 2048)){
                                goto while_break;
                            }
                        }
                    }
                }
                {
                    c = getTexChar();
                }
            }
            while_break:
            ;
        }
        {
            ungetTexChar(c);
        }
        return;
    }
}

static void IgnoreMeasure(void)
{
    char c;
    char tmp;
    {
        {
            tmp = getNonSpace();
            c = tmp;
        }
        if ((int)c == 61){
            {
                c = getNonSpace();
            }
        }
        {
            ungetTexChar(c);
            getDimension();
        }
        return;
    }
}

int TryVariableIgnore(const char* command)
{
    const char* RtfCommand;
    char* TexCommand;
    char c;
    char* tmp;
    const unsigned short **tmp___0;
    char* str;
    char* tmp___1;
    int tmp___2;
    int tmp___3;
    int tmp___4;
    int tmp___5;
    int tmp___6;
    int tmp___7;
    int tmp___8;
    int tmp___9;
    int tmp___10;
    {
        {
            TexCommand = strdup_together("\\", command);
            tmp = SearchCfgRtf((const char*)TexCommand, 2);
            RtfCommand = (const char*)tmp;
            free((void*)TexCommand);
            diagnostics(4, (char*)"Ignoring \'%s\' as \'%s\'", command, RtfCommand);
        }
        if ((unsigned long )RtfCommand == (unsigned long )((void*)0)){
            return (0);
        }
        {
            tmp___10 = strcmp(RtfCommand, "SINGLE");
        }
        if (!(tmp___10 == 0)){
            {
                tmp___9 = strcmp(RtfCommand, "NUMBER");
            }
            if (tmp___9 == 0){
                {
                    IgnoreNumber();
                }
            }else{
                {
                    tmp___8 = strcmp(RtfCommand, "MEASURE");
                }
                if (tmp___8 == 0){
                    {
                        IgnoreMeasure();
                    }
                }else{
                    {
                        tmp___7 = strcmp(RtfCommand, "OTHER");
                    }
                    if (tmp___7 == 0){
                        {
                            c = getNonSpace();
                        }
                        if ((int)c == 61){
                            {
                                c = getNonSpace();
                            }
                        }
                        {
                            while (1){
                                while_continue:
                                ;
                                if (c){
                                    {
                                        tmp___0 = __ctype_b_loc();
                                    }
                                    if ((const int)*(*tmp___0 + (int)c) & 8192){
                                        goto while_break;
                                    }
                                }else{
                                    goto while_break;
                                }
                                {
                                    c = getTexChar();
                                }
                            }
                            while_break:
                            ;
                        }
                        if (c){
                            {
                                c = getNonSpace();
                                ungetTexChar(c);
                            }
                        }
                    }else{
                        {
                            tmp___6 = strcmp(RtfCommand, "COMMAND");
                        }
                        if (tmp___6 == 0){
                            {
                                IgnoreCmd();
                            }
                        }else{
                            {
                                tmp___5 = strcmp(RtfCommand, "PARAMETER");
                            }
                            if (tmp___5 == 0){
                                {
                                    CmdIgnoreParameter(1);
                                }
                            }else{
                                {
                                    tmp___4 = strcmp(RtfCommand, "TWOPARAMETER");
                                }
                                if (tmp___4 == 0){
                                    {
                                        CmdIgnoreParameter(2);
                                    }
                                }else{
                                    {
                                        tmp___3 = strcmp(RtfCommand, "ENVIRONMENT");
                                    }
                                    if (tmp___3 == 0){
                                        {
                                            tmp___1 = strdup_together3("end{", command, "}");
                                            str = tmp___1;
                                            Ignore_Environment(str);
                                            free((void*)str);
                                        }
                                    }else{
                                        {
                                            tmp___2 = strcmp(RtfCommand, "ENVCMD");
                                        }
                                        if (tmp___2 == 0){
                                            {
                                                PushEnvironment(9);
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        return (1);
    }
}

int TryPackageIgnore(const char* package)
{
    const char* RtfCommand;
    char* TexCommand;
    int result;
    char* tmp;
    int tmp___0;
    {
        {
            result = 0;
            diagnostics(4, (char*)"trying to ignore \'%s\'", package);
            TexCommand = strdup_together("\\", package);
            tmp = SearchCfgRtf((const char*)TexCommand, 2);
            RtfCommand = (const char*)tmp;
            free((void*)TexCommand);
        }
        if ((unsigned long )((void*)0) != (unsigned long )RtfCommand){
            {
                tmp___0 = strcmp(RtfCommand, "PACKAGE");
                result = 0 == tmp___0;
            }
        }
        return (result);
    }
}

void Ignore_Environment(char* cCommand)
{
    char unknown_environment[100];
    char* buffer___0;
    int font;
    {
        {
            diagnostics(4, (char*)"Entering IgnoreEnvironment <%s>", cCommand);
            snprintf((char*)(unknown_environment), (size_t)100, (const char*)"\\%s%s%s", "end{", cCommand, "}");
            font = TexFontNumber("Typewriter");
            CmdEndParagraph(0);
            CmdIndent(1);
            startParagraph("Normal", 2);
            fprintRTF((char*)"\\qc [Sorry. Ignored ");
            fprintRTF((char*)"{\\plain\\f%d\\\\begin\\{%s\\} ... \\\\end\\{%s\\}}]", font, cCommand, cCommand);
            CmdEndParagraph(0);
            CmdIndent(2);
            buffer___0 = getTexUntil(unknown_environment, 0);
            ConvertString((const char*)(unknown_environment));
            free((void*)buffer___0);
            diagnostics(4, (char*)"Exiting IgnoreEnvironment");
        }
        return;
    }
}

extern long (strtol)(const char*restrict  __nptr, char**restrict  __endptr, int __base);
void CmdChar(int code);
void CmdCedillaChar(int code);
void CmdDoubleAcuteChar(int code);
void CmdUnderdotChar(int code);
void CmdCaronChar(int code);
void CmdRingChar(int code);
void CmdVecChar(int code);
void CmdBreveChar(int code);
void CmdWideBreveChar(int code);
void CmdUnderbarChar(int code);
void CmdDotlessChar(int code);
void CmdSymbol(int code);
void CmdLogo(int code);
void CmdFrenchAbbrev(int code);
void CmdCzechAbbrev(int code);
void CmdEuro(int code);
void CmdDegreeCelsius(int code);
void CmdNot(int code);

static void putUnicodeChar(unsigned char b1, unsigned char b2, char default_char)
{
    int tmp;
    {
        {
            tmp = getTexMode();
        }
        if (tmp == 6){
            {
                changeTexMode(2);
            }
        }
        if ((int)b1 < 128){
            {
                fprintRTF((char*)"\\u%d%c", (int)b1 * 256 + (int)b2, (int)default_char);
            }
        }else{
            {
                fprintRTF((char*)"\\u%d%c", ((int)b1 * 256 + (int)b2) - 65536, (int)default_char);
            }
        }
        return;
    }
}

void CmdUnicodeChar(int code)
{
    unsigned char a;
    unsigned char b;
    uint16_t thechar;
    int tmp;
    {
        {
            tmp = getTexMode();
        }
        if (tmp == 6){
            {
                changeTexMode(2);
            }
        }
        {
            thechar = (uint16_t)code;
            a = (unsigned char)((int)thechar >> 8);
            b = (unsigned char)((int)thechar - (int)a * 256);
            putUnicodeChar(a, b, (char)'?');
        }
        return;
    }
}

void CmdUmlauteChar(int code)
{
    int n;
    int tmp;
    char* cParam;
    char* tmp___0;
    char* tmp___1;
    {
        {
            tmp = RtfFontNumber("STIXGeneral");
            n = tmp;
            tmp___0 = getBraceParam();
            cParam = tmp___0;
            tmp___1 = strstr((const char*)cParam, "\\i");
        }
        if (tmp___1){
            {
                fprintRTF((char*)"\\\'ef");
                free((void*)cParam);
            }
            return;
        }
        {
            if ((int)*(cParam + 0) == 65){
                goto case_65;
            }
            if ((int)*(cParam + 0) == 69){
                goto case_69;
            }
            if ((int)*(cParam + 0) == 73){
                goto case_73;
            }
            if ((int)*(cParam + 0) == 79){
                goto case_79;
            }
            if ((int)*(cParam + 0) == 85){
                goto case_85;
            }
            if ((int)*(cParam + 0) == 97){
                goto case_97;
            }
            if ((int)*(cParam + 0) == 101){
                goto case_101;
            }
            if ((int)*(cParam + 0) == 105){
                goto case_105;
            }
            if ((int)*(cParam + 0) == 111){
                goto case_111;
            }
            if ((int)*(cParam + 0) == 117){
                goto case_117;
            }
            if ((int)*(cParam + 0) == 121){
                goto case_121;
            }
            if ((int)*(cParam + 0) == 89){
                goto case_89;
            }
            if ((int)*(cParam + 0) == 72){
                goto case_72;
            }
            if ((int)*(cParam + 0) == 104){
                goto case_104;
            }
            if ((int)*(cParam + 0) == 87){
                goto case_87;
            }
            if ((int)*(cParam + 0) == 119){
                goto case_119;
            }
            if ((int)*(cParam + 0) == 88){
                goto case_88;
            }
            if ((int)*(cParam + 0) == 120){
                goto case_120;
            }
            if ((int)*(cParam + 0) == 116){
                goto case_116;
            }
            if ((int)*(cParam + 0) == 0){
                goto case_0;
            }
            goto switch_default;
            case_65:
            {
                fprintRTF((char*)"\\\'c4");
            }
            goto switch_break;
            case_69:
            {
                fprintRTF((char*)"\\\'cb");
            }
            goto switch_break;
            case_73:
            {
                fprintRTF((char*)"\\\'cf");
            }
            goto switch_break;
            case_79:
            {
                fprintRTF((char*)"\\\'d6");
            }
            goto switch_break;
            case_85:
            {
                fprintRTF((char*)"\\\'dc");
            }
            goto switch_break;
            case_97:
            {
                fprintRTF((char*)"\\\'e4");
            }
            goto switch_break;
            case_101:
            {
                fprintRTF((char*)"\\\'eb");
            }
            goto switch_break;
            case_105:
            {
                fprintRTF((char*)"\\\'ef");
            }
            goto switch_break;
            case_111:
            {
                fprintRTF((char*)"\\\'f6");
            }
            goto switch_break;
            case_117:
            {
                fprintRTF((char*)"\\\'fc");
            }
            goto switch_break;
            case_121:
            {
                fprintRTF((char*)"\\\'ff");
            }
            goto switch_break;
            case_89:
            {
                putUnicodeChar((unsigned char)1, (unsigned char)120, (char)'Y');
            }
            goto switch_break;
            case_72:
            {
                putUnicodeChar((unsigned char)30, (unsigned char)38, (char)'H');
            }
            goto switch_break;
            case_104:
            {
                putUnicodeChar((unsigned char)30, (unsigned char)39, (char)'h');
            }
            goto switch_break;
            case_87:
            {
                putUnicodeChar((unsigned char)30, (unsigned char)131, (char)'W');
            }
            goto switch_break;
            case_119:
            {
                putUnicodeChar((unsigned char)30, (unsigned char)132, (char)'w');
            }
            goto switch_break;
            case_88:
            {
                putUnicodeChar((unsigned char)30, (unsigned char)140, (char)'X');
            }
            goto switch_break;
            case_120:
            {
                putUnicodeChar((unsigned char)30, (unsigned char)141, (char)'x');
            }
            goto switch_break;
            case_116:
            {
                putUnicodeChar((unsigned char)30, (unsigned char)151, (char)'t');
            }
            goto switch_break;
            case_0:
            {
                fprintRTF((char*)" \\u776.");
            }
            goto switch_break;
            switch_default:
            {
                fprintRTF((char*)"{\\f%d", n);
                fprintRTF((char*)"\\u776.}");
                ConvertString((const char*)cParam);
            }
            goto switch_break;
            switch_break:
            ;
        }
        {
            free((void*)cParam);
        }
        return;
    }
}

void CmdGraveChar(int code)
{
    int n;
    int tmp;
    char* cParam;
    char* tmp___0;
    char* tmp___1;
    {
        {
            tmp = RtfFontNumber("STIXGeneral");
            n = tmp;
            tmp___0 = getBraceParam();
            cParam = tmp___0;
            tmp___1 = strstr((const char*)cParam, "\\i");
        }
        if (tmp___1){
            {
                fprintRTF((char*)"\\\'ec");
                free((void*)cParam);
            }
            return;
        }
        {
            if ((int)*(cParam + 0) == 65){
                goto case_65;
            }
            if ((int)*(cParam + 0) == 69){
                goto case_69;
            }
            if ((int)*(cParam + 0) == 73){
                goto case_73;
            }
            if ((int)*(cParam + 0) == 79){
                goto case_79;
            }
            if ((int)*(cParam + 0) == 85){
                goto case_85;
            }
            if ((int)*(cParam + 0) == 97){
                goto case_97;
            }
            if ((int)*(cParam + 0) == 101){
                goto case_101;
            }
            if ((int)*(cParam + 0) == 105){
                goto case_105;
            }
            if ((int)*(cParam + 0) == 111){
                goto case_111;
            }
            if ((int)*(cParam + 0) == 117){
                goto case_117;
            }
            if ((int)*(cParam + 0) == 78){
                goto case_78;
            }
            if ((int)*(cParam + 0) == 110){
                goto case_110;
            }
            if ((int)*(cParam + 0) == 0){
                goto case_0;
            }
            goto switch_default;
            case_65:
            {
                fprintRTF((char*)"\\\'c0");
            }
            goto switch_break;
            case_69:
            {
                fprintRTF((char*)"\\\'c8");
            }
            goto switch_break;
            case_73:
            {
                fprintRTF((char*)"\\\'cc");
            }
            goto switch_break;
            case_79:
            {
                fprintRTF((char*)"\\\'d2");
            }
            goto switch_break;
            case_85:
            {
                fprintRTF((char*)"\\\'d9");
            }
            goto switch_break;
            case_97:
            {
                fprintRTF((char*)"\\\'e0");
            }
            goto switch_break;
            case_101:
            {
                fprintRTF((char*)"\\\'e8");
            }
            goto switch_break;
            case_105:
            {
                fprintRTF((char*)"\\\'ec");
            }
            goto switch_break;
            case_111:
            {
                fprintRTF((char*)"\\\'f2");
            }
            goto switch_break;
            case_117:
            {
                fprintRTF((char*)"\\\'f9");
            }
            goto switch_break;
            case_78:
            {
                fprintRTF((char*)"\\u504N");
            }
            goto switch_break;
            case_110:
            {
                fprintRTF((char*)"\\u505n");
            }
            goto switch_break;
            case_0:
            {
                fprintRTF((char*)" \\u768\\\'60");
            }
            goto switch_break;
            switch_default:
            {
                fprintRTF((char*)"{\\f%d", n);
                fprintRTF((char*)"\\u768\\\'60}");
                ConvertString((const char*)cParam);
            }
            goto switch_break;
            switch_break:
            ;
        }
        {
            free((void*)cParam);
        }
        return;
    }
}

void CmdAcuteChar(int code)
{
    int n;
    int tmp;
    char* cParam;
    char* tmp___0;
    char* tmp___1;
    {
        {
            tmp = RtfFontNumber("STIXGeneral");
            n = tmp;
            tmp___0 = getBraceParam();
            cParam = tmp___0;
            tmp___1 = strstr((const char*)cParam, "\\i");
        }
        if (tmp___1){
            {
                fprintRTF((char*)"\\\'ed");
                free((void*)cParam);
            }
            return;
        }
        {
            if ((int)*(cParam + 0) == 65){
                goto case_65;
            }
            if ((int)*(cParam + 0) == 69){
                goto case_69;
            }
            if ((int)*(cParam + 0) == 73){
                goto case_73;
            }
            if ((int)*(cParam + 0) == 79){
                goto case_79;
            }
            if ((int)*(cParam + 0) == 85){
                goto case_85;
            }
            if ((int)*(cParam + 0) == 97){
                goto case_97;
            }
            if ((int)*(cParam + 0) == 101){
                goto case_101;
            }
            if ((int)*(cParam + 0) == 105){
                goto case_105;
            }
            if ((int)*(cParam + 0) == 111){
                goto case_111;
            }
            if ((int)*(cParam + 0) == 117){
                goto case_117;
            }
            if ((int)*(cParam + 0) == 121){
                goto case_121;
            }
            if ((int)*(cParam + 0) == 89){
                goto case_89;
            }
            if ((int)*(cParam + 0) == 67){
                goto case_67;
            }
            if ((int)*(cParam + 0) == 99){
                goto case_99;
            }
            if ((int)*(cParam + 0) == 71){
                goto case_71;
            }
            if ((int)*(cParam + 0) == 103){
                goto case_103;
            }
            if ((int)*(cParam + 0) == 76){
                goto case_76;
            }
            if ((int)*(cParam + 0) == 108){
                goto case_108;
            }
            if ((int)*(cParam + 0) == 78){
                goto case_78;
            }
            if ((int)*(cParam + 0) == 110){
                goto case_110;
            }
            if ((int)*(cParam + 0) == 82){
                goto case_82;
            }
            if ((int)*(cParam + 0) == 114){
                goto case_114;
            }
            if ((int)*(cParam + 0) == 83){
                goto case_83;
            }
            if ((int)*(cParam + 0) == 115){
                goto case_115;
            }
            if ((int)*(cParam + 0) == 90){
                goto case_90;
            }
            if ((int)*(cParam + 0) == 122){
                goto case_122;
            }
            if ((int)*(cParam + 0) == 0){
                goto case_0;
            }
            goto switch_default;
            case_65:
            {
                fprintRTF((char*)"\\\'c1");
            }
            goto switch_break;
            case_69:
            {
                fprintRTF((char*)"\\\'c9");
            }
            goto switch_break;
            case_73:
            {
                fprintRTF((char*)"\\\'cd");
            }
            goto switch_break;
            case_79:
            {
                fprintRTF((char*)"\\\'d3");
            }
            goto switch_break;
            case_85:
            {
                fprintRTF((char*)"\\\'da");
            }
            goto switch_break;
            case_97:
            {
                fprintRTF((char*)"\\\'e1");
            }
            goto switch_break;
            case_101:
            {
                fprintRTF((char*)"\\\'e9");
            }
            goto switch_break;
            case_105:
            {
                fprintRTF((char*)"\\\'ed");
            }
            goto switch_break;
            case_111:
            {
                fprintRTF((char*)"\\\'f3");
            }
            goto switch_break;
            case_117:
            {
                fprintRTF((char*)"\\\'fa");
            }
            goto switch_break;
            case_121:
            {
                fprintRTF((char*)"\\\'fd");
            }
            goto switch_break;
            case_89:
            {
                fprintRTF((char*)"\\\'dd");
            }
            goto switch_break;
            case_67:
            {
                fprintRTF((char*)"\\u262C");
            }
            goto switch_break;
            case_99:
            {
                fprintRTF((char*)"\\u263c");
            }
            goto switch_break;
            case_71:
            {
                fprintRTF((char*)"\\u500G");
            }
            goto switch_break;
            case_103:
            {
                fprintRTF((char*)"\\u501g");
            }
            goto switch_break;
            case_76:
            {
                fprintRTF((char*)"\\u313L");
            }
            goto switch_break;
            case_108:
            {
                fprintRTF((char*)"\\u314l");
            }
            goto switch_break;
            case_78:
            {
                fprintRTF((char*)"\\u323N");
            }
            goto switch_break;
            case_110:
            {
                fprintRTF((char*)"\\u324n");
            }
            goto switch_break;
            case_82:
            {
                fprintRTF((char*)"\\u340R");
            }
            goto switch_break;
            case_114:
            {
                fprintRTF((char*)"\\u341r");
            }
            goto switch_break;
            case_83:
            {
                fprintRTF((char*)"\\u346S");
            }
            goto switch_break;
            case_115:
            {
                fprintRTF((char*)"\\u347s");
            }
            goto switch_break;
            case_90:
            {
                fprintRTF((char*)"\\u377Z");
            }
            goto switch_break;
            case_122:
            {
                fprintRTF((char*)"\\u378z");
            }
            goto switch_break;
            case_0:
            {
                fprintRTF((char*)"\\\'b4");
            }
            goto switch_break;
            switch_default:
            {
                fprintRTF((char*)"{\\f%d", n);
                fprintRTF((char*)"\\u769\\\'b4}");
                ConvertString((const char*)cParam);
            }
            goto switch_break;
            switch_break:
            ;
        }
        {
            free((void*)cParam);
        }
        return;
    }
}

void CmdDoubleAcuteChar(int code)
{
    int n;
    int tmp;
    char* cParam;
    char* tmp___0;
    {
        {
            tmp = RtfFontNumber("STIXGeneral");
            n = tmp;
            tmp___0 = getBraceParam();
            cParam = tmp___0;
        }
        {
            if ((int)*(cParam + 0) == 79){
                goto case_79;
            }
            if ((int)*(cParam + 0) == 111){
                goto case_111;
            }
            if ((int)*(cParam + 0) == 85){
                goto case_85;
            }
            if ((int)*(cParam + 0) == 117){
                goto case_117;
            }
            if ((int)*(cParam + 0) == 0){
                goto case_0;
            }
            goto switch_default;
            case_79:
            {
                putUnicodeChar((unsigned char)1, (unsigned char)80, (char)'O');
            }
            goto switch_break;
            case_111:
            {
                putUnicodeChar((unsigned char)1, (unsigned char)81, (char)'o');
            }
            goto switch_break;
            case_85:
            {
                putUnicodeChar((unsigned char)1, (unsigned char)112, (char)'U');
            }
            goto switch_break;
            case_117:
            {
                putUnicodeChar((unsigned char)1, (unsigned char)113, (char)'u');
            }
            goto switch_break;
            case_0:
            {
                putUnicodeChar((unsigned char)2, (unsigned char)221, (char)'\"');
            }
            goto switch_break;
            switch_default:
            {
                fprintRTF((char*)"{\\f%d", n);
                fprintRTF((char*)"\\u779\"}");
                ConvertString((const char*)cParam);
            }
            goto switch_break;
            switch_break:
            ;
        }
        {
            free((void*)cParam);
        }
        return;
    }
}

void CmdMacronChar(int code)
{
    int n;
    int tmp;
    char* cParam;
    char* tmp___0;
    char* tmp___1;
    {
        {
            tmp = RtfFontNumber("STIXGeneral");
            n = tmp;
            tmp___0 = getBraceParam();
            cParam = tmp___0;
            tmp___1 = strstr((const char*)cParam, "\\i");
        }
        if (tmp___1){
            {
                putUnicodeChar((unsigned char)1, (unsigned char)43, (char)'i');
                free((void*)cParam);
            }
            return;
        }
        {
            if ((int)*(cParam + 0) == 65){
                goto case_65;
            }
            if ((int)*(cParam + 0) == 97){
                goto case_97;
            }
            if ((int)*(cParam + 0) == 69){
                goto case_69;
            }
            if ((int)*(cParam + 0) == 101){
                goto case_101;
            }
            if ((int)*(cParam + 0) == 73){
                goto case_73;
            }
            if ((int)*(cParam + 0) == 105){
                goto case_105;
            }
            if ((int)*(cParam + 0) == 71){
                goto case_71;
            }
            if ((int)*(cParam + 0) == 103){
                goto case_103;
            }
            if ((int)*(cParam + 0) == 79){
                goto case_79;
            }
            if ((int)*(cParam + 0) == 111){
                goto case_111;
            }
            if ((int)*(cParam + 0) == 85){
                goto case_85;
            }
            if ((int)*(cParam + 0) == 117){
                goto case_117;
            }
            if ((int)*(cParam + 0) == 89){
                goto case_89;
            }
            if ((int)*(cParam + 0) == 121){
                goto case_121;
            }
            if ((int)*(cParam + 0) == 0){
                goto case_0;
            }
            goto switch_default;
            case_65:
            {
                putUnicodeChar((unsigned char)1, (unsigned char)0, (char)'A');
            }
            goto switch_break;
            case_97:
            {
                putUnicodeChar((unsigned char)1, (unsigned char)1, (char)'a');
            }
            goto switch_break;
            case_69:
            {
                putUnicodeChar((unsigned char)1, (unsigned char)18, (char)'E');
            }
            goto switch_break;
            case_101:
            {
                putUnicodeChar((unsigned char)1, (unsigned char)19, (char)'e');
            }
            goto switch_break;
            case_73:
            {
                putUnicodeChar((unsigned char)1, (unsigned char)42, (char)'l');
            }
            goto switch_break;
            case_105:
            {
                putUnicodeChar((unsigned char)1, (unsigned char)43, (char)'i');
            }
            goto switch_break;
            case_71:
            {
                putUnicodeChar((unsigned char)30, (unsigned char)32, (char)'G');
            }
            goto switch_break;
            case_103:
            {
                putUnicodeChar((unsigned char)30, (unsigned char)33, (char)'g');
            }
            goto switch_break;
            case_79:
            {
                putUnicodeChar((unsigned char)1, (unsigned char)76, (char)'O');
            }
            goto switch_break;
            case_111:
            {
                putUnicodeChar((unsigned char)1, (unsigned char)77, (char)'o');
            }
            goto switch_break;
            case_85:
            {
                putUnicodeChar((unsigned char)1, (unsigned char)106, (char)'U');
            }
            goto switch_break;
            case_117:
            {
                putUnicodeChar((unsigned char)1, (unsigned char)107, (char)'u');
            }
            goto switch_break;
            case_89:
            {
                putUnicodeChar((unsigned char)2, (unsigned char)50, (char)'Y');
            }
            goto switch_break;
            case_121:
            {
                putUnicodeChar((unsigned char)2, (unsigned char)51, (char)'y');
            }
            goto switch_break;
            case_0:
            {
                fprintRTF((char*)"\\\'5f");
            }
            goto switch_break;
            switch_default:
            {
                fprintRTF((char*)"{\\f%d", n);
                fprintRTF((char*)"\\u772\\\'5f}");
                ConvertString((const char*)cParam);
            }
            goto switch_break;
            switch_break:
            ;
        }
        {
            free((void*)cParam);
        }
        return;
    }
}

void CmdHatChar(int code)
{
    int n;
    int tmp;
    char* cParam;
    char* tmp___0;
    {
        {
            tmp = RtfFontNumber("STIXGeneral");
            n = tmp;
            tmp___0 = getBraceParam();
            cParam = tmp___0;
        }
        {
            if ((int)*(cParam + 0) == 97){
                goto case_97;
            }
            if ((int)*(cParam + 0) == 65){
                goto case_65;
            }
            if ((int)*(cParam + 0) == 101){
                goto case_101;
            }
            if ((int)*(cParam + 0) == 69){
                goto case_69;
            }
            if ((int)*(cParam + 0) == 105){
                goto case_105;
            }
            if ((int)*(cParam + 0) == 73){
                goto case_73;
            }
            if ((int)*(cParam + 0) == 111){
                goto case_111;
            }
            if ((int)*(cParam + 0) == 79){
                goto case_79;
            }
            if ((int)*(cParam + 0) == 117){
                goto case_117;
            }
            if ((int)*(cParam + 0) == 85){
                goto case_85;
            }
            if ((int)*(cParam + 0) == 67){
                goto case_67;
            }
            if ((int)*(cParam + 0) == 99){
                goto case_99;
            }
            if ((int)*(cParam + 0) == 71){
                goto case_71;
            }
            if ((int)*(cParam + 0) == 103){
                goto case_103;
            }
            if ((int)*(cParam + 0) == 72){
                goto case_72;
            }
            if ((int)*(cParam + 0) == 104){
                goto case_104;
            }
            if ((int)*(cParam + 0) == 74){
                goto case_74;
            }
            if ((int)*(cParam + 0) == 83){
                goto case_83;
            }
            if ((int)*(cParam + 0) == 115){
                goto case_115;
            }
            if ((int)*(cParam + 0) == 87){
                goto case_87;
            }
            if ((int)*(cParam + 0) == 119){
                goto case_119;
            }
            if ((int)*(cParam + 0) == 89){
                goto case_89;
            }
            if ((int)*(cParam + 0) == 121){
                goto case_121;
            }
            if ((int)*(cParam + 0) == 0){
                goto case_0;
            }
            goto switch_default;
            case_97:
            {
                fprintRTF((char*)"\\\'e2");
            }
            goto switch_break;
            case_65:
            {
                fprintRTF((char*)"\\\'c2");
            }
            goto switch_break;
            case_101:
            {
                fprintRTF((char*)"\\\'ea");
            }
            goto switch_break;
            case_69:
            {
                fprintRTF((char*)"\\\'ca");
            }
            goto switch_break;
            case_105:
            {
                fprintRTF((char*)"\\\'ee");
            }
            goto switch_break;
            case_73:
            {
                fprintRTF((char*)"\\\'ce");
            }
            goto switch_break;
            case_111:
            {
                fprintRTF((char*)"\\\'f4");
            }
            goto switch_break;
            case_79:
            {
                fprintRTF((char*)"\\\'d4");
            }
            goto switch_break;
            case_117:
            {
                fprintRTF((char*)"\\\'fb");
            }
            goto switch_break;
            case_85:
            {
                fprintRTF((char*)"\\\'db");
            }
            goto switch_break;
            case_67:
            {
                fprintRTF((char*)"\\u264C");
            }
            goto switch_break;
            case_99:
            {
                fprintRTF((char*)"\\u265c");
            }
            goto switch_break;
            case_71:
            {
                fprintRTF((char*)"\\u284G");
            }
            goto switch_break;
            case_103:
            {
                fprintRTF((char*)"\\u285g");
            }
            goto switch_break;
            case_72:
            {
                fprintRTF((char*)"\\u292H");
            }
            goto switch_break;
            case_104:
            {
                fprintRTF((char*)"\\u293h");
            }
            goto switch_break;
            case_74:
            {
                fprintRTF((char*)"\\u308J");
            }
            goto switch_break;
            case_83:
            {
                fprintRTF((char*)"\\u348S");
            }
            goto switch_break;
            case_115:
            {
                fprintRTF((char*)"\\u349s");
            }
            goto switch_break;
            case_87:
            {
                fprintRTF((char*)"\\u372W");
            }
            goto switch_break;
            case_119:
            {
                fprintRTF((char*)"\\u373w");
            }
            goto switch_break;
            case_89:
            {
                fprintRTF((char*)"\\u374Y");
            }
            goto switch_break;
            case_121:
            {
                fprintRTF((char*)"\\u375y");
            }
            goto switch_break;
            case_0:
            {
                fprintRTF((char*)"\\\'5e");
            }
            goto switch_break;
            switch_default:
            {
                fprintRTF((char*)"{\\f%d", n);
                fprintRTF((char*)"\\u770\\\'5e}");
                ConvertString((const char*)cParam);
            }
            goto switch_break;
            switch_break:
            ;
        }
        {
            free((void*)cParam);
        }
        return;
    }
}

void CmdRingChar(int code)
{
    int n;
    int tmp;
    char* cParam;
    char* tmp___0;
    {
        {
            tmp = RtfFontNumber("STIXGeneral");
            n = tmp;
            tmp___0 = getBraceParam();
            cParam = tmp___0;
        }
        {
            if ((int)*(cParam + 0) == 65){
                goto case_65;
            }
            if ((int)*(cParam + 0) == 97){
                goto case_97;
            }
            if ((int)*(cParam + 0) == 85){
                goto case_85;
            }
            if ((int)*(cParam + 0) == 117){
                goto case_117;
            }
            if ((int)*(cParam + 0) == 119){
                goto case_119;
            }
            if ((int)*(cParam + 0) == 121){
                goto case_121;
            }
            if ((int)*(cParam + 0) == 0){
                goto case_0;
            }
            goto switch_default;
            case_65:
            {
                fprintRTF((char*)"\\\'c5");
            }
            goto switch_break;
            case_97:
            {
                fprintRTF((char*)"\\\'e5");
            }
            goto switch_break;
            case_85:
            {
                putUnicodeChar((unsigned char)1, (unsigned char)110, (char)'U');
            }
            goto switch_break;
            case_117:
            {
                putUnicodeChar((unsigned char)1, (unsigned char)111, (char)'u');
            }
            goto switch_break;
            case_119:
            {
                putUnicodeChar((unsigned char)1, (unsigned char)152, (char)'w');
            }
            goto switch_break;
            case_121:
            {
                putUnicodeChar((unsigned char)1, (unsigned char)153, (char)'y');
            }
            goto switch_break;
            case_0:
            {
                fprintRTF((char*)"\\\'b0");
            }
            goto switch_break;
            switch_default:
            {
                fprintRTF((char*)"{\\f%d", n);
                fprintRTF((char*)"\\u778\\\'b0}");
                ConvertString((const char*)cParam);
            }
            goto switch_break;
            switch_break:
            ;
        }
        {
            free((void*)cParam);
        }
        return;
    }
}

void CmdTildeChar(int code)
{
    int n;
    int tmp;
    char* cParam;
    char* tmp___0;
    char* tmp___1;
    {
        {
            tmp = RtfFontNumber("STIXGeneral");
            n = tmp;
            tmp___0 = getBraceParam();
            cParam = tmp___0;
            tmp___1 = strstr((const char*)cParam, "\\i");
        }
        if (tmp___1){
            {
                fprintRTF((char*)"\\u297i");
                free((void*)cParam);
            }
            return;
        }
        {
            if ((int)*(cParam + 0) == 65){
                goto case_65;
            }
            if ((int)*(cParam + 0) == 79){
                goto case_79;
            }
            if ((int)*(cParam + 0) == 97){
                goto case_97;
            }
            if ((int)*(cParam + 0) == 111){
                goto case_111;
            }
            if ((int)*(cParam + 0) == 110){
                goto case_110;
            }
            if ((int)*(cParam + 0) == 78){
                goto case_78;
            }
            if ((int)*(cParam + 0) == 73){
                goto case_73;
            }
            if ((int)*(cParam + 0) == 85){
                goto case_85;
            }
            if ((int)*(cParam + 0) == 117){
                goto case_117;
            }
            if ((int)*(cParam + 0) == 0){
                goto case_0;
            }
            goto switch_default;
            case_65:
            {
                fprintRTF((char*)"\\\'c3");
            }
            goto switch_break;
            case_79:
            {
                fprintRTF((char*)"\\\'d5");
            }
            goto switch_break;
            case_97:
            {
                fprintRTF((char*)"\\\'e3");
            }
            goto switch_break;
            case_111:
            {
                fprintRTF((char*)"\\\'f5");
            }
            goto switch_break;
            case_110:
            {
                fprintRTF((char*)"\\\'f1");
            }
            goto switch_break;
            case_78:
            {
                fprintRTF((char*)"\\\'d1");
            }
            goto switch_break;
            case_73:
            {
                fprintRTF((char*)"\\u296I");
            }
            goto switch_break;
            case_85:
            {
                fprintRTF((char*)"\\u360U");
            }
            goto switch_break;
            case_117:
            {
                fprintRTF((char*)"\\u361u");
            }
            goto switch_break;
            case_0:
            {
                fprintRTF((char*)"\\\'7e");
            }
            goto switch_break;
            switch_default:
            {
                fprintRTF((char*)"{\\f%d", n);
                fprintRTF((char*)"\\u771\\\'7e}");
                ConvertString((const char*)cParam);
            }
            goto switch_break;
            switch_break:
            ;
        }
        {
            free((void*)cParam);
        }
        return;
    }
}

void CmdCedillaChar(int code)
{
    int n;
    int tmp;
    char* cParam;
    char* tmp___0;
    {
        {
            tmp = RtfFontNumber("STIXGeneral");
            n = tmp;
            tmp___0 = getBraceParam();
            cParam = tmp___0;
        }
        {
            if ((int)*(cParam + 0) == 67){
                goto case_67;
            }
            if ((int)*(cParam + 0) == 99){
                goto case_99;
            }
            if ((int)*(cParam + 0) == 71){
                goto case_71;
            }
            if ((int)*(cParam + 0) == 103){
                goto case_103;
            }
            if ((int)*(cParam + 0) == 75){
                goto case_75;
            }
            if ((int)*(cParam + 0) == 107){
                goto case_107;
            }
            if ((int)*(cParam + 0) == 76){
                goto case_76;
            }
            if ((int)*(cParam + 0) == 108){
                goto case_108;
            }
            if ((int)*(cParam + 0) == 78){
                goto case_78;
            }
            if ((int)*(cParam + 0) == 110){
                goto case_110;
            }
            if ((int)*(cParam + 0) == 82){
                goto case_82;
            }
            if ((int)*(cParam + 0) == 114){
                goto case_114;
            }
            if ((int)*(cParam + 0) == 83){
                goto case_83;
            }
            if ((int)*(cParam + 0) == 115){
                goto case_115;
            }
            if ((int)*(cParam + 0) == 84){
                goto case_84;
            }
            if ((int)*(cParam + 0) == 116){
                goto case_116;
            }
            if ((int)*(cParam + 0) == 69){
                goto case_69;
            }
            if ((int)*(cParam + 0) == 101){
                goto case_101;
            }
            if ((int)*(cParam + 0) == 0){
                goto case_0;
            }
            goto switch_default;
            case_67:
            {
                fprintRTF((char*)"\\\'c7");
            }
            goto switch_break;
            case_99:
            {
                fprintRTF((char*)"\\\'e7");
            }
            goto switch_break;
            case_71:
            {
                putUnicodeChar((unsigned char)1, (unsigned char)34, (char)'G');
            }
            goto switch_break;
            case_103:
            {
                putUnicodeChar((unsigned char)1, (unsigned char)35, (char)'g');
            }
            goto switch_break;
            case_75:
            {
                putUnicodeChar((unsigned char)1, (unsigned char)54, (char)'K');
            }
            goto switch_break;
            case_107:
            {
                putUnicodeChar((unsigned char)1, (unsigned char)55, (char)'k');
            }
            goto switch_break;
            case_76:
            {
                putUnicodeChar((unsigned char)1, (unsigned char)59, (char)'L');
            }
            goto switch_break;
            case_108:
            {
                putUnicodeChar((unsigned char)1, (unsigned char)60, (char)'l');
            }
            goto switch_break;
            case_78:
            {
                putUnicodeChar((unsigned char)1, (unsigned char)69, (char)'N');
            }
            goto switch_break;
            case_110:
            {
                putUnicodeChar((unsigned char)1, (unsigned char)70, (char)'n');
            }
            goto switch_break;
            case_82:
            {
                putUnicodeChar((unsigned char)1, (unsigned char)86, (char)'R');
            }
            goto switch_break;
            case_114:
            {
                putUnicodeChar((unsigned char)1, (unsigned char)87, (char)'r');
            }
            goto switch_break;
            case_83:
            {
                putUnicodeChar((unsigned char)1, (unsigned char)94, (char)'S');
            }
            goto switch_break;
            case_115:
            {
                putUnicodeChar((unsigned char)1, (unsigned char)95, (char)'s');
            }
            goto switch_break;
            case_84:
            {
                putUnicodeChar((unsigned char)1, (unsigned char)98, (char)'T');
            }
            goto switch_break;
            case_116:
            {
                putUnicodeChar((unsigned char)1, (unsigned char)99, (char)'t');
            }
            goto switch_break;
            case_69:
            {
                putUnicodeChar((unsigned char)2, (unsigned char)40, (char)'E');
            }
            goto switch_break;
            case_101:
            {
                putUnicodeChar((unsigned char)2, (unsigned char)41, (char)'e');
            }
            goto switch_break;
            case_0:
            {
                fprintRTF((char*)"\\\'b8");
            }
            goto switch_break;
            switch_default:
            {
                fprintRTF((char*)"{\\f%d", n);
                fprintRTF((char*)"\\u807\\\'b8}");
                ConvertString((const char*)cParam);
            }
            goto switch_break;
            switch_break:
            ;
        }
        {
            free((void*)cParam);
        }
        return;
    }
}

void CmdBreveChar(int code)
{
    int n;
    int tmp;
    char* cParam;
    char* tmp___0;
    {
        {
            tmp = RtfFontNumber("STIXGeneral");
            n = tmp;
            tmp___0 = getBraceParam();
            cParam = tmp___0;
        }
        {
            if ((int)*(cParam + 0) == 65){
                goto case_65;
            }
            if ((int)*(cParam + 0) == 97){
                goto case_97;
            }
            if ((int)*(cParam + 0) == 69){
                goto case_69;
            }
            if ((int)*(cParam + 0) == 101){
                goto case_101;
            }
            if ((int)*(cParam + 0) == 71){
                goto case_71;
            }
            if ((int)*(cParam + 0) == 103){
                goto case_103;
            }
            if ((int)*(cParam + 0) == 73){
                goto case_73;
            }
            if ((int)*(cParam + 0) == 105){
                goto case_105;
            }
            if ((int)*(cParam + 0) == 79){
                goto case_79;
            }
            if ((int)*(cParam + 0) == 111){
                goto case_111;
            }
            if ((int)*(cParam + 0) == 85){
                goto case_85;
            }
            if ((int)*(cParam + 0) == 99){
                goto case_99;
            }
            if ((int)*(cParam + 0) == 0){
                goto case_0;
            }
            goto switch_default;
            case_65:
            {
                putUnicodeChar((unsigned char)1, (unsigned char)2, (char)'A');
            }
            goto switch_break;
            case_97:
            {
                putUnicodeChar((unsigned char)1, (unsigned char)3, (char)'a');
            }
            goto switch_break;
            case_69:
            {
                putUnicodeChar((unsigned char)1, (unsigned char)20, (char)'E');
            }
            goto switch_break;
            case_101:
            {
                putUnicodeChar((unsigned char)1, (unsigned char)21, (char)'e');
            }
            goto switch_break;
            case_71:
            {
                putUnicodeChar((unsigned char)1, (unsigned char)30, (char)'G');
            }
            goto switch_break;
            case_103:
            {
                putUnicodeChar((unsigned char)1, (unsigned char)31, (char)'g');
            }
            goto switch_break;
            case_73:
            {
                putUnicodeChar((unsigned char)1, (unsigned char)44, (char)'I');
            }
            goto switch_break;
            case_105:
            {
                putUnicodeChar((unsigned char)1, (unsigned char)45, (char)'i');
            }
            goto switch_break;
            case_79:
            {
                putUnicodeChar((unsigned char)1, (unsigned char)78, (char)'O');
            }
            goto switch_break;
            case_111:
            {
                putUnicodeChar((unsigned char)1, (unsigned char)79, (char)'o');
            }
            goto switch_break;
            case_85:
            {
                putUnicodeChar((unsigned char)1, (unsigned char)108, (char)'U');
            }
            goto switch_break;
            case_99:
            {
                putUnicodeChar((unsigned char)1, (unsigned char)13, (char)'c');
            }
            goto switch_break;
            case_0:
            {
                putUnicodeChar((unsigned char)2, (unsigned char)216, (char)'u');
            }
            goto switch_break;
            switch_default:
            {
                fprintRTF((char*)"{\\f%d", n);
                fprintRTF((char*)"\\u774u}");
                ConvertString((const char*)cParam);
            }
            goto switch_break;
            switch_break:
            ;
        }
        {
            free((void*)cParam);
        }
        return;
    }
}

void CmdWideBreveChar(int code)
{
    int n;
    int tmp;
    char* cParam;
    char* tmp___0;
    {
        {
            tmp = RtfFontNumber("STIXGeneral");
            n = tmp;
            tmp___0 = getBraceParam();
            cParam = tmp___0;
        }
        {
            if ((int)*(cParam + 0) == 85){
                goto case_85;
            }
            if ((int)*(cParam + 0) == 73){
                goto case_73;
            }
            if ((int)*(cParam + 0) == 105){
                goto case_105;
            }
            if ((int)*(cParam + 0) == 117){
                goto case_117;
            }
            goto switch_default;
            case_85:
            {
                CmdUnicodeChar(1038);
            }
            goto switch_break;
            case_73:
            {
                CmdUnicodeChar(1049);
            }
            goto switch_break;
            case_105:
            {
                CmdUnicodeChar(1081);
            }
            goto switch_break;
            case_117:
            {
                CmdUnicodeChar(1081);
            }
            goto switch_break;
            switch_default:
            {
                fprintRTF((char*)"{\\f%d", n);
                fprintRTF((char*)"\\u774u}");
                ConvertString((const char*)cParam);
            }
            goto switch_break;
            switch_break:
            ;
        }
        {
            free((void*)cParam);
        }
        return;
    }
}

void CmdCaronChar(int code)
{
    int n;
    int tmp;
    char* cParam;
    char* tmp___0;
    {
        {
            tmp = RtfFontNumber("STIXGeneral");
            n = tmp;
            tmp___0 = getBraceParam();
            cParam = tmp___0;
        }
        {
            if ((int)*(cParam + 0) == 67){
                goto case_67;
            }
            if ((int)*(cParam + 0) == 99){
                goto case_99;
            }
            if ((int)*(cParam + 0) == 68){
                goto case_68;
            }
            if ((int)*(cParam + 0) == 100){
                goto case_100;
            }
            if ((int)*(cParam + 0) == 69){
                goto case_69;
            }
            if ((int)*(cParam + 0) == 101){
                goto case_101;
            }
            if ((int)*(cParam + 0) == 76){
                goto case_76;
            }
            if ((int)*(cParam + 0) == 108){
                goto case_108;
            }
            if ((int)*(cParam + 0) == 78){
                goto case_78;
            }
            if ((int)*(cParam + 0) == 110){
                goto case_110;
            }
            if ((int)*(cParam + 0) == 82){
                goto case_82;
            }
            if ((int)*(cParam + 0) == 114){
                goto case_114;
            }
            if ((int)*(cParam + 0) == 83){
                goto case_83;
            }
            if ((int)*(cParam + 0) == 115){
                goto case_115;
            }
            if ((int)*(cParam + 0) == 84){
                goto case_84;
            }
            if ((int)*(cParam + 0) == 116){
                goto case_116;
            }
            if ((int)*(cParam + 0) == 90){
                goto case_90;
            }
            if ((int)*(cParam + 0) == 122){
                goto case_122;
            }
            if ((int)*(cParam + 0) == 65){
                goto case_65;
            }
            if ((int)*(cParam + 0) == 97){
                goto case_97;
            }
            if ((int)*(cParam + 0) == 73){
                goto case_73;
            }
            if ((int)*(cParam + 0) == 105){
                goto case_105;
            }
            if ((int)*(cParam + 0) == 79){
                goto case_79;
            }
            if ((int)*(cParam + 0) == 111){
                goto case_111;
            }
            if ((int)*(cParam + 0) == 85){
                goto case_85;
            }
            if ((int)*(cParam + 0) == 117){
                goto case_117;
            }
            if ((int)*(cParam + 0) == 71){
                goto case_71;
            }
            if ((int)*(cParam + 0) == 103){
                goto case_103;
            }
            if ((int)*(cParam + 0) == 75){
                goto case_75;
            }
            if ((int)*(cParam + 0) == 107){
                goto case_107;
            }
            if ((int)*(cParam + 0) == 106){
                goto case_106;
            }
            if ((int)*(cParam + 0) == 72){
                goto case_72;
            }
            if ((int)*(cParam + 0) == 104){
                goto case_104;
            }
            if ((int)*(cParam + 0) == 0){
                goto case_0;
            }
            goto switch_default;
            case_67:
            {
                putUnicodeChar((unsigned char)1, (unsigned char)12, (char)'C');
            }
            goto switch_break;
            case_99:
            {
                putUnicodeChar((unsigned char)1, (unsigned char)13, (char)'c');
            }
            goto switch_break;
            case_68:
            {
                putUnicodeChar((unsigned char)1, (unsigned char)14, (char)'D');
            }
            goto switch_break;
            case_100:
            {
                putUnicodeChar((unsigned char)1, (unsigned char)15, (char)'d');
            }
            goto switch_break;
            case_69:
            {
                putUnicodeChar((unsigned char)1, (unsigned char)26, (char)'E');
            }
            goto switch_break;
            case_101:
            {
                putUnicodeChar((unsigned char)1, (unsigned char)27, (char)'e');
            }
            goto switch_break;
            case_76:
            {
                putUnicodeChar((unsigned char)1, (unsigned char)61, (char)'L');
            }
            goto switch_break;
            case_108:
            {
                putUnicodeChar((unsigned char)1, (unsigned char)62, (char)'l');
            }
            goto switch_break;
            case_78:
            {
                putUnicodeChar((unsigned char)1, (unsigned char)71, (char)'N');
            }
            goto switch_break;
            case_110:
            {
                putUnicodeChar((unsigned char)1, (unsigned char)72, (char)'n');
            }
            goto switch_break;
            case_82:
            {
                putUnicodeChar((unsigned char)1, (unsigned char)88, (char)'R');
            }
            goto switch_break;
            case_114:
            {
                putUnicodeChar((unsigned char)1, (unsigned char)89, (char)'r');
            }
            goto switch_break;
            case_83:
            {
                putUnicodeChar((unsigned char)1, (unsigned char)96, (char)'S');
            }
            goto switch_break;
            case_115:
            {
                putUnicodeChar((unsigned char)1, (unsigned char)97, (char)'s');
            }
            goto switch_break;
            case_84:
            {
                putUnicodeChar((unsigned char)1, (unsigned char)100, (char)'T');
            }
            goto switch_break;
            case_116:
            {
                putUnicodeChar((unsigned char)1, (unsigned char)101, (char)'t');
            }
            goto switch_break;
            case_90:
            {
                putUnicodeChar((unsigned char)1, (unsigned char)125, (char)'Z');
            }
            goto switch_break;
            case_122:
            {
                putUnicodeChar((unsigned char)1, (unsigned char)126, (char)'z');
            }
            goto switch_break;
            case_65:
            {
                putUnicodeChar((unsigned char)1, (unsigned char)205, (char)'A');
            }
            goto switch_break;
            case_97:
            {
                putUnicodeChar((unsigned char)1, (unsigned char)206, (char)'a');
            }
            goto switch_break;
            case_73:
            {
                putUnicodeChar((unsigned char)1, (unsigned char)207, (char)'I');
            }
            goto switch_break;
            case_105:
            {
                putUnicodeChar((unsigned char)1, (unsigned char)208, (char)'i');
            }
            goto switch_break;
            case_79:
            {
                putUnicodeChar((unsigned char)1, (unsigned char)209, (char)'O');
            }
            goto switch_break;
            case_111:
            {
                putUnicodeChar((unsigned char)1, (unsigned char)210, (char)'o');
            }
            goto switch_break;
            case_85:
            {
                putUnicodeChar((unsigned char)1, (unsigned char)211, (char)'U');
            }
            goto switch_break;
            case_117:
            {
                putUnicodeChar((unsigned char)1, (unsigned char)212, (char)'u');
            }
            goto switch_break;
            case_71:
            {
                putUnicodeChar((unsigned char)1, (unsigned char)230, (char)'G');
            }
            goto switch_break;
            case_103:
            {
                putUnicodeChar((unsigned char)1, (unsigned char)231, (char)'g');
            }
            goto switch_break;
            case_75:
            {
                putUnicodeChar((unsigned char)1, (unsigned char)232, (char)'K');
            }
            goto switch_break;
            case_107:
            {
                putUnicodeChar((unsigned char)1, (unsigned char)233, (char)'k');
            }
            goto switch_break;
            case_106:
            {
                putUnicodeChar((unsigned char)1, (unsigned char)240, (char)'j');
            }
            goto switch_break;
            case_72:
            {
                putUnicodeChar((unsigned char)2, (unsigned char)30, (char)'H');
            }
            goto switch_break;
            case_104:
            {
                putUnicodeChar((unsigned char)2, (unsigned char)31, (char)'h');
            }
            goto switch_break;
            case_0:
            {
                putUnicodeChar((unsigned char)2, (unsigned char)199, (char)'-');
            }
            goto switch_break;
            switch_default:
            {
                fprintRTF((char*)"{\\f%d", n);
                fprintRTF((char*)"\\u780-}");
                ConvertString((const char*)cParam);
            }
            goto switch_break;
            switch_break:
            ;
        }
        {
            free((void*)cParam);
        }
        return;
    }
}

void CmdDotChar(int code)
{
    int n;
    int tmp;
    char* cParam;
    char* tmp___0;
    {
        {
            tmp = RtfFontNumber("STIXGeneral");
            n = tmp;
            tmp___0 = getBraceParam();
            cParam = tmp___0;
        }
        {
            if ((int)*(cParam + 0) == 65){
                goto case_65;
            }
            if ((int)*(cParam + 0) == 97){
                goto case_97;
            }
            if ((int)*(cParam + 0) == 67){
                goto case_67;
            }
            if ((int)*(cParam + 0) == 99){
                goto case_99;
            }
            if ((int)*(cParam + 0) == 69){
                goto case_69;
            }
            if ((int)*(cParam + 0) == 101){
                goto case_101;
            }
            if ((int)*(cParam + 0) == 71){
                goto case_71;
            }
            if ((int)*(cParam + 0) == 103){
                goto case_103;
            }
            if ((int)*(cParam + 0) == 73){
                goto case_73;
            }
            if ((int)*(cParam + 0) == 79){
                goto case_79;
            }
            if ((int)*(cParam + 0) == 111){
                goto case_111;
            }
            if ((int)*(cParam + 0) == 90){
                goto case_90;
            }
            if ((int)*(cParam + 0) == 122){
                goto case_122;
            }
            if ((int)*(cParam + 0) == 0){
                goto case_0;
            }
            goto switch_default;
            case_65:
            {
                fprintRTF((char*)"\\u550A");
            }
            goto switch_break;
            case_97:
            {
                fprintRTF((char*)"\\u551a");
            }
            goto switch_break;
            case_67:
            {
                fprintRTF((char*)"\\u266C");
            }
            goto switch_break;
            case_99:
            {
                fprintRTF((char*)"\\u267c");
            }
            goto switch_break;
            case_69:
            {
                fprintRTF((char*)"\\u278E");
            }
            goto switch_break;
            case_101:
            {
                fprintRTF((char*)"\\u279e");
            }
            goto switch_break;
            case_71:
            {
                fprintRTF((char*)"\\u288G");
            }
            goto switch_break;
            case_103:
            {
                fprintRTF((char*)"\\u289g");
            }
            goto switch_break;
            case_73:
            {
                fprintRTF((char*)"\\u304I");
            }
            goto switch_break;
            case_79:
            {
                fprintRTF((char*)"\\u558O");
            }
            goto switch_break;
            case_111:
            {
                fprintRTF((char*)"\\u559o");
            }
            goto switch_break;
            case_90:
            {
                fprintRTF((char*)"\\u379Z");
            }
            goto switch_break;
            case_122:
            {
                fprintRTF((char*)"\\u380z");
            }
            goto switch_break;
            case_0:
            {
                putUnicodeChar((unsigned char)2, (unsigned char)217, (char)'.');
            }
            goto switch_break;
            switch_default:
            {
                fprintRTF((char*)"{\\f%d", n);
                fprintRTF((char*)"\\u775.}");
                ConvertString((const char*)cParam);
            }
            goto switch_break;
            switch_break:
            ;
        }
        {
            free((void*)cParam);
        }
        return;
    }
}

void CmdUnderdotChar(int code)
{
    int n;
    int tmp;
    char* cParam;
    char* tmp___0;
    char* tmp___1;
    {
        {
            tmp = RtfFontNumber("STIXGeneral");
            n = tmp;
            tmp___0 = getBraceParam();
            cParam = tmp___0;
            tmp___1 = strstr((const char*)cParam, "\\i");
        }
        if (tmp___1){
            {
                fprintRTF((char*)"\\u301i");
                free((void*)cParam);
            }
        }
        {
            if ((int)*(cParam + 0) == 66){
                goto case_66;
            }
            if ((int)*(cParam + 0) == 98){
                goto case_98;
            }
            if ((int)*(cParam + 0) == 68){
                goto case_68;
            }
            if ((int)*(cParam + 0) == 100){
                goto case_100;
            }
            if ((int)*(cParam + 0) == 72){
                goto case_72;
            }
            if ((int)*(cParam + 0) == 104){
                goto case_104;
            }
            if ((int)*(cParam + 0) == 75){
                goto case_75;
            }
            if ((int)*(cParam + 0) == 107){
                goto case_107;
            }
            if ((int)*(cParam + 0) == 76){
                goto case_76;
            }
            if ((int)*(cParam + 0) == 108){
                goto case_108;
            }
            if ((int)*(cParam + 0) == 77){
                goto case_77;
            }
            if ((int)*(cParam + 0) == 109){
                goto case_109;
            }
            if ((int)*(cParam + 0) == 78){
                goto case_78;
            }
            if ((int)*(cParam + 0) == 110){
                goto case_110;
            }
            if ((int)*(cParam + 0) == 82){
                goto case_82;
            }
            if ((int)*(cParam + 0) == 114){
                goto case_114;
            }
            if ((int)*(cParam + 0) == 83){
                goto case_83;
            }
            if ((int)*(cParam + 0) == 115){
                goto case_115;
            }
            if ((int)*(cParam + 0) == 86){
                goto case_86;
            }
            if ((int)*(cParam + 0) == 118){
                goto case_118;
            }
            if ((int)*(cParam + 0) == 87){
                goto case_87;
            }
            if ((int)*(cParam + 0) == 119){
                goto case_119;
            }
            if ((int)*(cParam + 0) == 90){
                goto case_90;
            }
            if ((int)*(cParam + 0) == 122){
                goto case_122;
            }
            if ((int)*(cParam + 0) == 65){
                goto case_65;
            }
            if ((int)*(cParam + 0) == 97){
                goto case_97;
            }
            if ((int)*(cParam + 0) == 69){
                goto case_69;
            }
            if ((int)*(cParam + 0) == 101){
                goto case_101;
            }
            if ((int)*(cParam + 0) == 73){
                goto case_73;
            }
            if ((int)*(cParam + 0) == 105){
                goto case_105;
            }
            if ((int)*(cParam + 0) == 79){
                goto case_79;
            }
            if ((int)*(cParam + 0) == 111){
                goto case_111;
            }
            if ((int)*(cParam + 0) == 85){
                goto case_85;
            }
            if ((int)*(cParam + 0) == 117){
                goto case_117;
            }
            if ((int)*(cParam + 0) == 0){
                goto case_0;
            }
            goto switch_default;
            case_66:
            {
                putUnicodeChar((unsigned char)30, (unsigned char)4, (char)'B');
            }
            goto switch_break;
            case_98:
            {
                putUnicodeChar((unsigned char)30, (unsigned char)5, (char)'b');
            }
            goto switch_break;
            case_68:
            {
                putUnicodeChar((unsigned char)30, (unsigned char)12, (char)'D');
            }
            goto switch_break;
            case_100:
            {
                putUnicodeChar((unsigned char)30, (unsigned char)13, (char)'d');
            }
            goto switch_break;
            case_72:
            {
                putUnicodeChar((unsigned char)30, (unsigned char)36, (char)'H');
            }
            goto switch_break;
            case_104:
            {
                putUnicodeChar((unsigned char)30, (unsigned char)37, (char)'h');
            }
            goto switch_break;
            case_75:
            {
                putUnicodeChar((unsigned char)30, (unsigned char)50, (char)'K');
            }
            goto switch_break;
            case_107:
            {
                putUnicodeChar((unsigned char)30, (unsigned char)51, (char)'k');
            }
            goto switch_break;
            case_76:
            {
                putUnicodeChar((unsigned char)30, (unsigned char)54, (char)'L');
            }
            goto switch_break;
            case_108:
            {
                putUnicodeChar((unsigned char)30, (unsigned char)55, (char)'l');
            }
            goto switch_break;
            case_77:
            {
                putUnicodeChar((unsigned char)30, (unsigned char)66, (char)'M');
            }
            goto switch_break;
            case_109:
            {
                putUnicodeChar((unsigned char)30, (unsigned char)67, (char)'m');
            }
            goto switch_break;
            case_78:
            {
                putUnicodeChar((unsigned char)30, (unsigned char)70, (char)'N');
            }
            goto switch_break;
            case_110:
            {
                putUnicodeChar((unsigned char)30, (unsigned char)71, (char)'n');
            }
            goto switch_break;
            case_82:
            {
                putUnicodeChar((unsigned char)30, (unsigned char)90, (char)'R');
            }
            goto switch_break;
            case_114:
            {
                putUnicodeChar((unsigned char)30, (unsigned char)91, (char)'r');
            }
            goto switch_break;
            case_83:
            {
                putUnicodeChar((unsigned char)30, (unsigned char)98, (char)'S');
            }
            goto switch_break;
            case_115:
            {
                putUnicodeChar((unsigned char)30, (unsigned char)99, (char)'s');
            }
            goto switch_break;
            case_86:
            {
                putUnicodeChar((unsigned char)30, (unsigned char)126, (char)'V');
            }
            goto switch_break;
            case_118:
            {
                putUnicodeChar((unsigned char)30, (unsigned char)127, (char)'v');
            }
            goto switch_break;
            case_87:
            {
                putUnicodeChar((unsigned char)30, (unsigned char)136, (char)'W');
            }
            goto switch_break;
            case_119:
            {
                putUnicodeChar((unsigned char)30, (unsigned char)137, (char)'w');
            }
            goto switch_break;
            case_90:
            {
                putUnicodeChar((unsigned char)30, (unsigned char)146, (char)'Z');
            }
            goto switch_break;
            case_122:
            {
                putUnicodeChar((unsigned char)30, (unsigned char)147, (char)'z');
            }
            goto switch_break;
            case_65:
            {
                putUnicodeChar((unsigned char)30, (unsigned char)160, (char)'A');
            }
            goto switch_break;
            case_97:
            {
                putUnicodeChar((unsigned char)30, (unsigned char)161, (char)'a');
            }
            goto switch_break;
            case_69:
            {
                putUnicodeChar((unsigned char)30, (unsigned char)184, (char)'E');
            }
            goto switch_break;
            case_101:
            {
                putUnicodeChar((unsigned char)30, (unsigned char)185, (char)'e');
            }
            goto switch_break;
            case_73:
            {
                putUnicodeChar((unsigned char)30, (unsigned char)202, (char)'I');
            }
            goto switch_break;
            case_105:
            {
                putUnicodeChar((unsigned char)30, (unsigned char)203, (char)'i');
            }
            goto switch_break;
            case_79:
            {
                putUnicodeChar((unsigned char)30, (unsigned char)204, (char)'O');
            }
            goto switch_break;
            case_111:
            {
                putUnicodeChar((unsigned char)30, (unsigned char)205, (char)'o');
            }
            goto switch_break;
            case_85:
            {
                putUnicodeChar((unsigned char)30, (unsigned char)228, (char)'U');
            }
            goto switch_break;
            case_117:
            {
                putUnicodeChar((unsigned char)30, (unsigned char)229, (char)'u');
            }
            goto switch_break;
            case_0:
            {
                fprintRTF((char*)" \\u803.");
            }
            goto switch_break;
            switch_default:
            {
                fprintRTF((char*)"{\\f%d", n);
                fprintRTF((char*)"\\u803.}");
                ConvertString((const char*)cParam);
            }
            goto switch_break;
            switch_break:
            ;
        }
        {
            free((void*)cParam);
        }
        return;
    }
}

void CmdVecChar(int code)
{
    int n;
    int tmp;
    char* cParam;
    char* tmp___0;
    {
        {
            tmp = RtfFontNumber("STIXGeneral");
            n = tmp;
            tmp___0 = getBraceParam();
            cParam = tmp___0;
            fprintRTF((char*)"{\\f%d ", n);
            putUnicodeChar((unsigned char)32, (unsigned char)215, (char)'-');
            fprintRTF((char*)"}");
            ConvertString((const char*)cParam);
            free((void*)cParam);
        }
        return;
    }
}

void CmdUnderbarChar(int code)
{
    char* cParam;
    char* tmp;
    {
        {
            tmp = getBraceParam();
            cParam = tmp;
        }
        {
            if ((int)*(cParam + 0) == 66){
                goto case_66;
            }
            if ((int)*(cParam + 0) == 98){
                goto case_98;
            }
            if ((int)*(cParam + 0) == 68){
                goto case_68;
            }
            if ((int)*(cParam + 0) == 100){
                goto case_100;
            }
            if ((int)*(cParam + 0) == 75){
                goto case_75;
            }
            if ((int)*(cParam + 0) == 107){
                goto case_107;
            }
            if ((int)*(cParam + 0) == 76){
                goto case_76;
            }
            if ((int)*(cParam + 0) == 108){
                goto case_108;
            }
            if ((int)*(cParam + 0) == 78){
                goto case_78;
            }
            if ((int)*(cParam + 0) == 110){
                goto case_110;
            }
            if ((int)*(cParam + 0) == 82){
                goto case_82;
            }
            if ((int)*(cParam + 0) == 114){
                goto case_114;
            }
            if ((int)*(cParam + 0) == 84){
                goto case_84;
            }
            if ((int)*(cParam + 0) == 116){
                goto case_116;
            }
            if ((int)*(cParam + 0) == 90){
                goto case_90;
            }
            if ((int)*(cParam + 0) == 122){
                goto case_122;
            }
            if ((int)*(cParam + 0) == 104){
                goto case_104;
            }
            if ((int)*(cParam + 0) == 0){
                goto case_0;
            }
            goto switch_default;
            case_66:
            {
                putUnicodeChar((unsigned char)30, (unsigned char)6, (char)'B');
            }
            goto switch_break;
            case_98:
            {
                putUnicodeChar((unsigned char)30, (unsigned char)7, (char)'b');
            }
            goto switch_break;
            case_68:
            {
                putUnicodeChar((unsigned char)30, (unsigned char)14, (char)'D');
            }
            goto switch_break;
            case_100:
            {
                putUnicodeChar((unsigned char)30, (unsigned char)15, (char)'d');
            }
            goto switch_break;
            case_75:
            {
                putUnicodeChar((unsigned char)30, (unsigned char)52, (char)'K');
            }
            goto switch_break;
            case_107:
            {
                putUnicodeChar((unsigned char)30, (unsigned char)53, (char)'k');
            }
            goto switch_break;
            case_76:
            {
                putUnicodeChar((unsigned char)30, (unsigned char)58, (char)'L');
            }
            goto switch_break;
            case_108:
            {
                putUnicodeChar((unsigned char)30, (unsigned char)59, (char)'l');
            }
            goto switch_break;
            case_78:
            {
                putUnicodeChar((unsigned char)30, (unsigned char)72, (char)'N');
            }
            goto switch_break;
            case_110:
            {
                putUnicodeChar((unsigned char)30, (unsigned char)73, (char)'n');
            }
            goto switch_break;
            case_82:
            {
                putUnicodeChar((unsigned char)30, (unsigned char)94, (char)'R');
            }
            goto switch_break;
            case_114:
            {
                putUnicodeChar((unsigned char)30, (unsigned char)95, (char)'r');
            }
            goto switch_break;
            case_84:
            {
                putUnicodeChar((unsigned char)30, (unsigned char)110, (char)'T');
            }
            goto switch_break;
            case_116:
            {
                putUnicodeChar((unsigned char)30, (unsigned char)111, (char)'t');
            }
            goto switch_break;
            case_90:
            {
                putUnicodeChar((unsigned char)30, (unsigned char)148, (char)'Z');
            }
            goto switch_break;
            case_122:
            {
                putUnicodeChar((unsigned char)30, (unsigned char)149, (char)'z');
            }
            goto switch_break;
            case_104:
            {
                putUnicodeChar((unsigned char)30, (unsigned char)150, (char)'h');
            }
            goto switch_break;
            case_0:
            {
                fprintRTF((char*)"_");
            }
            goto switch_break;
            switch_default:
            {
                fprintRTF((char*)"\\u817_");
                ConvertString((const char*)cParam);
            }
            goto switch_break;
            switch_break:
            ;
        }
        {
            free((void*)cParam);
        }
        return;
    }
}

void CmdDotlessChar(int code)
{
    {
        if (code == 0){
            {
                fprintRTF((char*)"\\u305i");
            }
        }else{
            {
                fprintRTF((char*)"\\u567j");
            }
        }
        return;
    }
}

void CmdEuro(int code)
{
    char* s;
    char* tmp;
    {
        {
            tmp = getBraceParam();
            s = tmp;
            fprintRTF((char*)"\\\'80");
            ConvertString((const char*)s);
            free((void*)s);
        }
        return;
    }
}

static int identifyBase(char c)
{
    const unsigned short **tmp;
    {
        if ((int)c == 39){
            return (8);
        }else
            if ((int)c == 34){
                return (16);
            }else
                if ((int)c == 96){
                    return (-1);
                }else{
                    {
                        tmp = __ctype_b_loc();
                    }
                    if ((const int)*(*tmp + (int)c) & 2048){
                        return (10);
                    }else{
                        return (0);
                    }
                }
    }
}

static int isOctal(int c)
{
    {
        if (48 <= c){
            if (c <= 55){
                return (1);
            }
        }
        return (0);
    }
}

static int isHex(int c)
{
    const unsigned short **tmp;
    {
        {
            tmp = __ctype_b_loc();
        }
        if ((const int)*(*tmp + c) & 2048){
            return (1);
        }
        if (65 <= c){
            if (c <= 70){
                return (1);
            }
        }
        if (97 <= c){
            if (c <= 102){
                return (1);
            }
        }
        return (0);
    }
}

void CmdSymbol(int code)
{
    char c;
    char* s;
    char* t;
    int n;
    int base;
    char num[4];
    int i;
    const unsigned short **tmp;
    int tmp___0;
    int tmp___1;
    long tmp___2;
    long tmp___3;
    {
        if (code == 0){
            {
                c = getNonSpace();
                base = identifyBase(c);
            }
            if (base == 0){
                {
                    diagnostics(1, (char*)"malformed \\char construction");
                    fprintRTF((char*)"%c", (int)c);
                }
                return;
            }
            if (base == -1){
                {
                    c = getTexChar();
                    CmdChar((int)c);
                }
                return;
            }
            if (base == 10){
                {
                    ungetTexChar(c);
                }
            }
            i = 0;
            {
                while (1){
                    while_continue:
                    ;
                    if (!(i < 4)){
                        goto while_break;
                    }
                    {
                        num[i] = getTexChar();
                    }
                    if (base == 10){
                        {
                            tmp = __ctype_b_loc();
                        }
                        if (!((const int)*(*tmp + (int)num[i]) & 2048)){
                            goto while_break;
                        }
                    }
                    if (base == 8){
                        {
                            tmp___0 = isOctal((int)num[i]);
                        }
                        if (!tmp___0){
                            goto while_break;
                        }
                    }
                    if (base == 16){
                        {
                            tmp___1 = isHex((int)num[i]);
                        }
                        if (!tmp___1){
                            goto while_break;
                        }
                    }
                    i++;
                }
                while_break:
                ;
            }
            {
                ungetTexChar(num[i]);
                num[i] = (char)'\000';
                tmp___2 = strtol((const char*)(num), (char**)(&s), base);
                n = (int)tmp___2;
                CmdChar(n);
            }
        }else{
            {
                s = getBraceParam();
                t = strdup_noendblanks((const char*)s);
                free((void*)s);
                base = identifyBase(*t);
            }
            if (base == 0){
                return;
            }
            if (base == -1){
                {
                    CmdChar((int)*(t + 1));
                }
                return;
            }
            {
                tmp___3 = strtol((const char*)(t + 1), (char**)(&s), base);
                n = (int)tmp___3;
                CmdChar(n);
                free((void*)t);
            }
        }
        return;
    }
}

static void TeXlogo(void)
{
    int dnsize;
    int tmp;
    {
        {
            tmp = CurrentFontSize();
            dnsize = (int)(0.3 * (double)tmp + 0.45);
            fprintRTF((char*)"T{\\dn%d E}X", dnsize);
        }
        return;
    }
}

static void LaTeXlogo(void)
{
    float FloatFsize;
    int upsize;
    int Asize;
    int tmp;
    int tmp___0;
    int tmp___1;
    int tmp___2;
    {
        {
            tmp___1 = CurrentFontSize();
        }
        if (tmp___1 > 14){
            {
                tmp = CurrentFontSize();
                FloatFsize = (float)(0.8 * (double)tmp);
            }
        }else{
            {
                tmp___0 = CurrentFontSize();
                FloatFsize = (float)(0.9 * (double)tmp___0);
            }
        }
        {
            Asize = (int)((double)FloatFsize + 0.45);
            tmp___2 = CurrentFontSize();
            upsize = (int)(0.25 * (double)tmp___2 + 0.45);
            fprintRTF((char*)"L{\\up%d\\fs%d A}", upsize, Asize);
            TeXlogo();
        }
        return;
    }
}

void CmdLogo(int code)
{
    int dnsize;
    int tmp;
    int tmp___0;
    {
        {
            changeTexMode(2);
            fprintRTF((char*)"{\\plain ");
        }
        {
            if (code == 1){
                goto case_1;
            }
            if (code == 2){
                goto case_2;
            }
            if (code == 3){
                goto case_3;
            }
            if (code == 4){
                goto case_4;
            }
            if (code == 5){
                goto case_5;
            }
            if (code == 6){
                goto case_6;
            }
            if (code == 7){
                goto case_7;
            }
            if (code == 8){
                goto case_8;
            }
            goto switch_break;
            case_1:
            {
                TeXlogo();
            }
            goto switch_break;
            case_2:
            {
                LaTeXlogo();
            }
            goto switch_break;
            case_3:
            {
                fprintRTF((char*)"{\\scaps Sli}");
                TeXlogo();
            }
            goto switch_break;
            case_4:
            {
                fprintRTF((char*)"{\\scaps Bib}");
                TeXlogo();
            }
            goto switch_break;
            case_5:
            {
                LaTeXlogo();
                tmp = CurrentFontSize();
                dnsize = (int)(0.3 * (double)tmp + 0.45);
                fprintRTF((char*)"2{\\dn%d", dnsize);
                putUnicodeChar((unsigned char)3, (unsigned char)245, (char)'e');
                fprintRTF((char*)"}");
            }
            goto switch_break;
            case_6:
            {
                fprintRTF((char*)"{\\i AmS}-");
                TeXlogo();
            }
            goto switch_break;
            case_7:
            {
                fprintRTF((char*)"{\\i AmS}-");
                LaTeXlogo();
            }
            goto switch_break;
            case_8:
            {
                tmp___0 = CurrentFontSize();
                dnsize = (int)(0.3 * (double)tmp___0 + 0.45);
                fprintRTF((char*)"L{\\dn%d Y}X", dnsize);
            }
            goto switch_break;
            switch_break:
            ;
        }
        {
            fprintRTF((char*)"}");
        }
        return;
    }
}

void CmdCzechAbbrev(int code)
{
    char* quote;
    {
        {
            quote = getBraceParam();
            fprintRTF((char*)" \\\'84");
            ConvertString((const char*)quote);
            free((void*)quote);
            fprintRTF((char*)"\\ldblquote ");
        }
        return;
    }
}

void CmdFrenchAbbrev(int code)
{
    float FloatFsize;
    int up;
    int size;
    char* fuptext;
    char* abbev;
    char* tmp;
    int tmp___0;
    {
        if (code == 17){
            {
                fprintRTF((char*)"<");
            }
            return;
        }
        if (code == 18){
            {
                fprintRTF((char*)">");
            }
            return;
        }
        if (code == 19){
            {
                fprintRTF((char*)"\\lquote");
            }
            return;
        }
        if (code == 20){
            {
                fprintRTF((char*)"\\rquote");
            }
            return;
        }
        if (code == 30){
            {
                fprintRTF((char*)"\\\'AB\\\'A0");
            }
            return;
        }
        if (code == 31){
            {
                fprintRTF((char*)"\\\'BB");
            }
            return;
        }
        if (code == 21){
            {
                fprintRTF((char*)"\\ldblquote");
            }
            return;
        }
        if (code == 22){
            {
                fprintRTF((char*)"\\rdblquote");
            }
            return;
        }
        if (code == 23){
            {
                fprintRTF((char*)";");
            }
            return;
        }
        if (code == 24){
            {
                fprintRTF((char*)"!");
            }
            return;
        }
        if (code == 25){
            {
                fprintRTF((char*)"?");
            }
            return;
        }
        if (code == 26){
            {
                fprintRTF((char*)"\"");
            }
            return;
        }
        if (code == 27){
            {
                fprintRTF((char*)":");
            }
            return;
        }
        if (code == 28){
            goto _L;
        }else
            if (code == 29){
                _L:
                {
                    tmp = getBraceParam();
                    abbev = tmp;
                    fprintRTF((char*)"{\\scaps ");
                    ConvertString((const char*)abbev);
                    free((void*)abbev);
                    fprintRTF((char*)"}");
                }
                return;
            }

        if (code == 8){
            {
                fprintRTF((char*)"n");
            }
        }
        if (code == 9){
            {
                fprintRTF((char*)"n");
            }
        }
        if (code == 10){
            {
                fprintRTF((char*)"N");
            }
        }
        if (code == 11){
            {
                fprintRTF((char*)"N");
            }
        }
        if (code == 12){
            {
                fprintRTF((char*)"1");
            }
        }
        if (code == 13){
            {
                fprintRTF((char*)"2");
            }
        }
        if (code == 14){
            {
                fprintRTF((char*)"3");
            }
        }
        if (code == 15){
            {
                fprintRTF((char*)"4");
            }
        }
        {
            tmp___0 = CurrentFontSize();
            FloatFsize = (float)tmp___0;
        }
        if (FloatFsize > (float)14){
            FloatFsize = (float)((double)FloatFsize * 0.75);
        }
        {
            up = (int)(0.3 * (double)FloatFsize + 0.45);
            size = (int)((double)FloatFsize + 0.45);
            fprintRTF((char*)"{\\fs%d\\up%d ", size, up);
        }
        {
            if (code == 8){
                goto case_8;
            }
            if (code == 10){
                goto case_10;
            }
            if (code == 9){
                goto case_9;
            }
            if (code == 11){
                goto case_11;
            }
            if (code == 12){
                goto case_12;
            }
            if (code == 13){
                goto case_13;
            }
            if (code == 14){
                goto case_14;
            }
            if (code == 15){
                goto case_15;
            }
            if (code == 1){
                goto case_1;
            }
            if (code == 3){
                goto case_3;
            }
            if (code == 5){
                goto case_5;
            }
            if (code == 6){
                goto case_6;
            }
            if (code == 2){
                goto case_2;
            }
            if (code == 4){
                goto case_4;
            }
            if (code == 16){
                goto case_16;
            }
            goto switch_break;
            case_8:
            {
                fprintRTF((char*)"o");
            }
            goto switch_break;
            case_10:
            {
                fprintRTF((char*)"o");
            }
            goto switch_break;
            case_9:
            {
                fprintRTF((char*)"os");
            }
            goto switch_break;
            case_11:
            {
                fprintRTF((char*)"os");
            }
            goto switch_break;
            case_12:
            {
                fprintRTF((char*)"o");
            }
            goto switch_break;
            case_13:
            {
                fprintRTF((char*)"o");
            }
            goto switch_break;
            case_14:
            {
                fprintRTF((char*)"o");
            }
            goto switch_break;
            case_15:
            {
                fprintRTF((char*)"o");
            }
            goto switch_break;
            case_1:
            {
                fprintRTF((char*)"er");
            }
            goto switch_break;
            case_3:
            {
                fprintRTF((char*)"ers");
            }
            goto switch_break;
            case_5:
            {
                fprintRTF((char*)"e");
            }
            goto switch_break;
            case_6:
            {
                fprintRTF((char*)"es");
            }
            goto switch_break;
            case_2:
            {
                fprintRTF((char*)"re");
            }
            goto switch_break;
            case_4:
            {
                fprintRTF((char*)"res");
            }
            goto switch_break;
            case_16:
            {
                fuptext = getBraceParam();
                ConvertString((const char*)fuptext);
                free((void*)fuptext);
            }
            goto switch_break;
            switch_break:
            ;
        }
        {
            fprintRTF((char*)"}");
        }
        return;
    }
}

void CmdDegreeCelsius(int code)
{
    {
        {
            fprintRTF((char*)"\\\'b0C");
        }
        return;
    }
}

void CmdNot(int code)
{
    char c;
    char* s;
    int tmp;
    int tmp___0;
    int tmp___1;
    int tmp___2;
    int tmp___3;
    int tmp___4;
    int tmp___5;
    int tmp___6;
    int tmp___7;
    int tmp___8;
    int tmp___9;
    int tmp___10;
    int tmp___11;
    int tmp___12;
    int tmp___13;
    int tmp___14;
    int tmp___15;
    int tmp___16;
    {
        {
            c = getTexChar();
        }
        {
            if ((int)c == 61){
                goto case_61;
            }
            if ((int)c == 60){
                goto case_60;
            }
            if ((int)c == 62){
                goto case_62;
            }
            if ((int)c == 92){
                goto case_92;
            }
            goto switch_default;
            case_61:
            {
                CmdUnicodeChar(8800);
            }
            goto switch_break;
            case_60:
            {
                CmdUnicodeChar(8814);
            }
            goto switch_break;
            case_62:
            {
                CmdUnicodeChar(8815);
            }
            goto switch_break;
            case_92:
            {
                ungetTexChar(c);
                s = getSimpleCommand();
                tmp___16 = strcmp((const char*)s, "\\leq");
            }
            if (tmp___16 == 0){
                {
                    CmdUnicodeChar(8816);
                }
            }else{
                {
                    tmp___15 = strcmp((const char*)s, "\\geq");
                }
                if (tmp___15 == 0){
                    {
                        CmdUnicodeChar(8817);
                    }
                }else{
                    {
                        tmp___14 = strcmp((const char*)s, "\\equiv");
                    }
                    if (tmp___14 == 0){
                        {
                            CmdUnicodeChar(8802);
                        }
                    }else{
                        {
                            tmp___13 = strcmp((const char*)s, "\\prec");
                        }
                        if (tmp___13 == 0){
                            {
                                CmdUnicodeChar(8832);
                            }
                        }else{
                            {
                                tmp___12 = strcmp((const char*)s, "\\succ");
                            }
                            if (tmp___12 == 0){
                                {
                                    CmdUnicodeChar(8833);
                                }
                            }else{
                                {
                                    tmp___11 = strcmp((const char*)s, "\\sim");
                                }
                                if (tmp___11 == 0){
                                    {
                                        CmdUnicodeChar(8769);
                                    }
                                }else{
                                    {
                                        tmp___10 = strcmp((const char*)s, "\\preceq");
                                    }
                                    if (tmp___10 == 0){
                                        {
                                            CmdUnicodeChar(8928);
                                        }
                                    }else{
                                        {
                                            tmp___9 = strcmp((const char*)s, "\\succeq");
                                        }
                                        if (tmp___9 == 0){
                                            {
                                                CmdUnicodeChar(8929);
                                            }
                                        }else{
                                            {
                                                tmp___8 = strcmp((const char*)s, "\\simeq");
                                            }
                                            if (tmp___8 == 0){
                                                {
                                                    CmdUnicodeChar(8772);
                                                }
                                            }else{
                                                {
                                                    tmp___7 = strcmp((const char*)s, "\\subset");
                                                }
                                                if (tmp___7 == 0){
                                                    {
                                                        CmdUnicodeChar(8836);
                                                    }
                                                }else{
                                                    {
                                                        tmp___6 = strcmp((const char*)s, "\\supset");
                                                    }
                                                    if (tmp___6 == 0){
                                                        {
                                                            CmdUnicodeChar(8837);
                                                        }
                                                    }else{
                                                        {
                                                            tmp___5 = strcmp((const char*)s, "\\approx");
                                                        }
                                                        if (tmp___5 == 0){
                                                            {
                                                                CmdUnicodeChar(8777);
                                                            }
                                                        }else{
                                                            {
                                                                tmp___4 = strcmp((const char*)s, "\\subseteq");
                                                            }
                                                            if (tmp___4 == 0){
                                                                {
                                                                    CmdUnicodeChar(8840);
                                                                }
                                                            }else{
                                                                {
                                                                    tmp___3 = strcmp((const char*)s, "\\supseteq");
                                                                }
                                                                if (tmp___3 == 0){
                                                                    {
                                                                        CmdUnicodeChar(8841);
                                                                    }
                                                                }else{
                                                                    {
                                                                        tmp___2 = strcmp((const char*)s, "\\cong");
                                                                    }
                                                                    if (tmp___2 == 0){
                                                                        {
                                                                            CmdUnicodeChar(8775);
                                                                        }
                                                                    }else{
                                                                        {
                                                                            tmp___1 = strcmp((const char*)s, "\\sqsubseteq");
                                                                        }
                                                                        if (tmp___1 == 0){
                                                                            {
                                                                                CmdUnicodeChar(8930);
                                                                            }
                                                                        }else{
                                                                            {
                                                                                tmp___0 = strcmp((const char*)s, "\\sqsupseteq");
                                                                            }
                                                                            if (tmp___0 == 0){
                                                                                {
                                                                                    CmdUnicodeChar(8931);
                                                                                }
                                                                            }else{
                                                                                {
                                                                                    tmp = strcmp((const char*)s, "\\asymp");
                                                                                }
                                                                                if (tmp == 0){
                                                                                    {
                                                                                        CmdUnicodeChar(8813);
                                                                                    }
                                                                                }else{
                                                                                    {
                                                                                        fprintRTF((char*)"/");
                                                                                        ConvertString((const char*)s);
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            if (s){
                {
                    free((void*)s);
                }
            }
            goto switch_break;
            switch_default:
            {
                fprintRTF((char*)"/");
                ungetTexChar(c);
            }
            goto switch_break;
            switch_break:
            ;
        }
        return;
    }
}

long pos_begin_kill;
void CmdTabular(int code);
void CmdTabbing(int code);
void CmdTable(int code);
void CmdMultiCol(int code);
void CmdHline(int code);
void CmdHAlign(int code);
int g_tabbing_left_position = 0;
int g_tabbing_current_position = 0;
int* g_tabbing_locations = (int*)((void*)0);
int tabbing_return = 0;
int tabbing_on_itself = 0;

static TabularT* NewTabular(int size)
{
    int i;
    TabularT* table;
    void* tmp;
    void* tmp___0;
    void* tmp___1;
    void* tmp___2;
    void* tmp___3;
    void* tmp___4;
    void* tmp___5;
    void* tmp___6;
    {
        {
            tmp = malloc(sizeof (TabularT));
            table = (TabularT*)tmp;
            table->i = 0;
            table->n = size;
            tmp___0 = malloc((unsigned long )(size + 1) * sizeof (char));
            table->align = (char*)tmp___0;
            tmp___1 = malloc((unsigned long )(size + 1) * sizeof (int));
            table->chars = (int*)tmp___1;
            tmp___2 = malloc((unsigned long )(size + 1) * sizeof (int));
            table->vert = (int*)tmp___2;
            tmp___3 = malloc((unsigned long )(size + 1) * sizeof (int));
            table->width = (int*)tmp___3;
            tmp___4 = malloc((unsigned long )(size + 1) * sizeof (int));
            table->cline = (int*)tmp___4;
            tmp___5 = malloc((unsigned long )(size + 1) * sizeof (char*));
            table->after = (char**)tmp___5;
            tmp___6 = malloc((unsigned long )(size + 1) * sizeof (char*));
            table->before = (char**)tmp___6;
            i = 0;
        }
        {
            while (1){
                while_continue:
                ;
                if (!(i <= size)){
                    goto while_break;
                }
                *(table->align + i) = (char)'l';
                *(table->chars + i) = 1;
                *(table->vert + i) = 0;
                *(table->width + i) = -1;
                *(table->cline + i) = 0;
                *(table->after + i) = (char*)((void*)0);
                *(table->before + i) = (char*)((void*)0);
                i++;
            }
            while_break:
            ;
        }
        return (table);
    }
}

static void FreeTabular(TabularT* table)
{
    int i;
    {
        i = 0;
        {
            while (1){
                while_continue:
                ;
                if (!(i <= table->n)){
                    goto while_break;
                }
                if (*(table->after + i)){
                    {
                        free((void*)*(table->after + i));
                    }
                }
                if (*(table->before + i)){
                    {
                        free((void*)*(table->before + i));
                    }
                }
                i++;
            }
            while_break:
            ;
        }
        {
            free((void*)table->align);
            free((void*)table->vert);
            free((void*)table->chars);
            free((void*)table->width);
            free((void*)table->cline);
            free((void*)table->after);
            free((void*)table->before);
            free((void*)table);
            table = (TabularT*)((void*)0);
        }
        return;
    }
}

static int countTabularColumns(const char* format)
{
    char* t;
    char* s;
    int iCol;
    {
        s = (char*)format;
        iCol = 0;
        {
            while (1){
                while_continue:
                ;
                if (!*s){
                    goto while_break;
                }
                {
                    if ((int)*s == 108){
                        goto case_108;
                    }
                    if ((int)*s == 114){
                        goto case_108;
                    }
                    if ((int)*s == 99){
                        goto case_108;
                    }
                    if ((int)*s == 112){
                        goto case_112;
                    }
                    if ((int)*s == 109){
                        goto case_112;
                    }
                    if ((int)*s == 98){
                        goto case_112;
                    }
                    if ((int)*s == 42){
                        goto case_42;
                    }
                    if ((int)*s == 33){
                        goto case_33;
                    }
                    if ((int)*s == 64){
                        goto case_33;
                    }
                    if ((int)*s == 62){
                        goto case_33;
                    }
                    if ((int)*s == 60){
                        goto case_33;
                    }
                    goto switch_default;
                    case_108:
                    case_114:
                    case_99:
                    iCol++;
                    s++;
                    goto switch_break;
                    case_112:
                    case_109:
                    case_98:
                    {
                        iCol++;
                        s++;
                        t = getStringBraceParam(&s);
                    }
                    if (t){
                        {
                            free((void*)t);
                        }
                    }
                    goto switch_break;
                    case_42:
                    {
                        s++;
                        t = getStringBraceParam(&s);
                    }
                    if (t){
                        {
                            free((void*)t);
                        }
                    }
                    {
                        t = getStringBraceParam(&s);
                    }
                    if (t){
                        {
                            free((void*)t);
                        }
                    }
                    goto switch_break;
                    case_33:
                    case_64:
                    case_62:
                    case_60:
                    {
                        s++;
                        t = getStringBraceParam(&s);
                    }
                    if (t){
                        {
                            free((void*)t);
                        }
                    }
                    goto switch_break;
                    switch_default:
                    s++;
                    goto switch_break;
                    switch_break:
                    ;
                }
            }
            while_break:
            ;
        }
        return (iCol);
    }
}

static TabularT* NewTabularFromFormat(const char* format);
static int warned_once = 0;

static TabularT* NewTabularFromFormat(const char* format)
{
    int iCol;
    char* t;
    char* old;
    char* s;
    TabularT* table;
    int tmp;
    {
        {
            diagnostics(4, (char*)"Entering NewTabularFromFormat, format=\'%s\'", format);
            tmp = countTabularColumns(format);
            table = NewTabular(tmp);
            iCol = 0;
            s = (char*)format;
        }
        {
            while (1){
                while_continue:
                ;
                if (!*s){
                    goto while_break;
                }
                {
                    if ((int)*s == 108){
                        goto case_108;
                    }
                    if ((int)*s == 114){
                        goto case_108;
                    }
                    if ((int)*s == 99){
                        goto case_108;
                    }
                    if ((int)*s == 112){
                        goto case_112;
                    }
                    if ((int)*s == 109){
                        goto case_112;
                    }
                    if ((int)*s == 98){
                        goto case_112;
                    }
                    if ((int)*s == 42){
                        goto case_42;
                    }
                    if ((int)*s == 60){
                        goto case_60;
                    }
                    if ((int)*s == 62){
                        goto case_62;
                    }
                    if ((int)*s == 33){
                        goto case_33;
                    }
                    if ((int)*s == 64){
                        goto case_33;
                    }
                    if ((int)*s == 124){
                        goto case_124;
                    }
                    goto switch_default;
                    case_108:
                    case_114:
                    case_99:
                    {
                        iCol++;
                        *(table->align + iCol) = *s;
                        s++;
                        diagnostics(6, (char*)"%c item, residual=\'%s\'", (int)*(s - 1), s);
                    }
                    goto switch_break;
                    case_112:
                    case_109:
                    case_98:
                    {
                        iCol++;
                        *(table->align + iCol) = (char)'l';
                        s++;
                        t = getStringBraceParam(&s);
                    }
                    if (t){
                        {
                            *(table->width + iCol) = getStringDimension(t);
                            free((void*)t);
                            diagnostics(6, (char*)"p item, width=%d, residual=\'%s\'", *(table->width + iCol), s);
                        }
                    }
                    goto switch_break;
                    case_42:
                    {
                        diagnostics(1, (char*)" \'*{num}{cols}\' not supported.");
                        s++;
                        t = getStringBraceParam(&s);
                    }
                    if (t){
                        {
                            free((void*)t);
                        }
                    }
                    {
                        t = getStringBraceParam(&s);
                    }
                    if (t){
                        {
                            free((void*)t);
                        }
                    }
                    goto switch_break;
                    case_60:
                    {
                        s++;
                        t = getStringBraceParam(&s);
                        old = *(table->before + (iCol + 1));
                    }
                    if (old){
                        {
                            *(table->before + (iCol + 1)) = strdup_together((const char*)t, (const char*)old);
                            free((void*)t);
                            free((void*)old);
                        }
                    }else{
                        *(table->before + (iCol + 1)) = t;
                    }
                    {
                        diagnostics(6, (char*)"< item, residual=\'%s\'", s);
                    }
                    goto switch_break;
                    case_62:
                    {
                        s++;
                        t = getStringBraceParam(&s);
                        old = *(table->after + (iCol + 1));
                    }
                    if (old){
                        {
                            *(table->after + (iCol + 1)) = strdup_together((const char*)t, (const char*)old);
                            free((void*)t);
                            free((void*)old);
                        }
                    }else{
                        *(table->after + (iCol + 1)) = t;
                    }
                    {
                        diagnostics(6, (char*)"> item, residual=\'%s\'", s);
                    }
                    goto switch_break;
                    case_33:
                    case_64:
                    if (!warned_once){
                        {
                            diagnostics(1, (char*)" \'@{decl.}\' and !{decl.} not supported.");
                        }
                    }
                    {
                        s++;
                        t = getStringBraceParam(&s);
                        free((void*)t);
                        warned_once = 1;
                    }
                    goto switch_break;
                    case_124:
                    (*(table->vert + iCol))++;
                    s++;
                    goto switch_break;
                    switch_default:
                    s++;
                    goto switch_break;
                    switch_break:
                    ;
                }
            }
            while_break:
            ;
        }
        {
            table->n = iCol;
            table->i = 0;
            diagnostics(5, (char*)"Exiting NewTabularFromFormat");
        }
        return (table);
    }
}

void CmdTabjump(void)
{
    {
        {
            fprintRTF((char*)"\\tab\n");
        }
        return;
    }
}

void CmdTabset(void)
{
    {
        return;
    }
}

static void BeginCellRTF(char align)
{
    {
        {
            fprintRTF((char*)"{\\pard\\intbl\\q%c ", (int)align);
        }
        return;
    }
}

static void EndCellRTF(void)
{
    {
        {
            fprintRTF((char*)"\\cell}\n");
        }
        return;
    }
}

static int TabularColumnPosition(TabularT* table, int n)
{
    int i;
    int oldWidth;
    int colWidth;
    int tmp;
    {
        colWidth = 0;
        i = 1;
        {
            while (1){
                while_continue:
                ;
                if (!(i <= n)){
                    goto while_break;
                }
                colWidth += *(table->width + i);
                i++;
            }
            while_break:
            ;
        }
        {
            tmp = getLength((char*)"textwidth");
            oldWidth = (tmp * n) / table->n;
            diagnostics(5, (char*)"col=%3d old=%5d new=%5d", n, oldWidth, colWidth);
        }
        return (colWidth);
    }
}

static TabularT* TabularPreamble(const char* format)
{
    TabularT* tabular;
    TabularT* tmp;
    int tmp___0;
    {
        {
            tmp = NewTabularFromFormat(format);
            tabular = tmp;
            tmp___0 = getTexMode();
        }
        if (tmp___0 != 2){
            {
                CmdIndent(1);
                startParagraph("last", 1);
            }
        }
        {
            fprintRTF((char*)"\\par\n");
        }
        return (tabular);
    }
}

static void TabularGetRow(const char* tabular_text, char** row, char** next_row, int* height)
{
    char* s;
    char* dimension;
    char* dim_start;
    int slash;
    int tabularnewline;
    int row_chars;
    int dim_chars;
    int brace;
    int tmp;
    void* tmp___0;
    void* tmp___1;
    {
        {
            slash = 0;
            tabularnewline = 0;
            row_chars = 0;
            dim_chars = 0;
            brace = 0;
            diagnostics(6, (char*)"TabularGetFirstRow contents=%s", tabular_text);
            s = (char*)tabular_text;
            *row = (char*)((void*)0);
            *next_row = (char*)((void*)0);
            *height = 0;
        }
        if (!s){
            return;
        }
        {
            while (1){
                while_continue:
                ;
                if ((int)*s != 0){
                    if (!(brace != 0)){
                        if (!((int)*s != 92)){
                            if (!(!slash)){
                                goto while_break;
                            }
                        }
                    }
                }else{
                    goto while_break;
                }
                if ((int)*s == 92){
                    slash = 1;
                }else{
                    slash = 0;
                }
                row_chars++;
                s++;
                if (!slash){
                    if ((int)*s == 123){
                        brace++;
                    }
                }
                if (!slash){
                    if ((int)*s == 125){
                        brace--;
                    }
                }
                if (slash){
                    {
                        tmp = strncmp((const char*)s, "tabularnewline", (size_t)14);
                    }
                    if (tmp == 0){
                        tabularnewline = 1;
                        goto while_break;
                    }
                }
            }
            while_break:
            ;
        }
        if ((int)*s == 92){
            if (slash){
                row_chars--;
            }
        }
        {
            tmp___0 = malloc((unsigned long )(row_chars + 1) * sizeof (char));
            *row = (char*)tmp___0;
            strncpy((char*)*row, (const char*)tabular_text, (size_t)row_chars);
            *(*row + row_chars) = (char)'\000';
            diagnostics(5, (char*)"TabularGetFirstRow row = %s", *row);
        }
        if ((int)*s == 0){
            return;
        }
        if (tabularnewline){
            *next_row = s + 14;
            return;
        }
        s++;
        {
            while (1){
                while_continue___0:
                ;
                if ((int)*s != 0){
                    if (!((int)*s == 32)){
                        if (!((int)*s == 10)){
                            goto while_break___0;
                        }
                    }
                }else{
                    goto while_break___0;
                }
                s++;
            }
            while_break___0:
            ;
        }
        if ((int)*s == 0){
            return;
        }
        if ((int)*s != 91){
            *next_row = s;
            return;
        }
        s++;
        dim_start = s;
        {
            while (1){
                while_continue___1:
                ;
                if ((int)*s != 0){
                    if (!((int)*s != 93)){
                        goto while_break___1;
                    }
                }else{
                    goto while_break___1;
                }
                s++;
                dim_chars++;
            }
            while_break___1:
            ;
        }
        {
            tmp___1 = malloc((unsigned long )(dim_chars + 2) * sizeof (char));
            dimension = (char*)tmp___1;
            strncpy((char*)dimension, (const char*)dim_start, (size_t)dim_chars);
            *(dimension + dim_chars) = (char)'\n';
            *(dimension + (dim_chars + 1)) = (char)'\000';
            *height = getStringDimension(dimension);
            free((void*)dimension);
            s++;
        }
        {
            while (1){
                while_continue___2:
                ;
                if ((int)*s != 0){
                    if (!((int)*s == 32)){
                        if (!((int)*s == 10)){
                            goto while_break___2;
                        }
                    }
                }else{
                    goto while_break___2;
                }
                s++;
            }
            while_break___2:
            ;
        }
        if ((int)*s == 0){
            return;
        }
        *next_row = s;
        return;
    }
}

static char* NextAmpersand(const char* t)
{
    char* s;
    int escaped;
    {
        {
            escaped = 0;
            s = (char*)t;
            diagnostics(5, (char*)"TabularNextAmpersand seeking \'&\' in \'%s\'", s);
        }
        {
            while (1){
                while_continue:
                ;
                if (s){
                    if ((int)*s != 0){
                        if (!((int)*s != 38)){
                            if ((int)*s == 38){
                                if (!escaped){
                                    goto while_break;
                                }
                            }else{
                                goto while_break;
                            }
                        }
                    }else{
                        goto while_break;
                    }
                }else{
                    goto while_break;
                }
                if ((int)*s == 92){
                    escaped = 1;
                }else{
                    escaped = 0;
                }
                s++;
            }
            while_break:
            ;
        }
        return (s);
    }
}

static void TabularGetCell(const char* cell_start, char** cell, char** next_cell)
{
    char* cell_end;
    char* dup;
    {
        *cell = (char*)((void*)0);
        *next_cell = (char*)((void*)0);
        if ((unsigned long )cell_start == (unsigned long )((void*)0)){
            return;
        }
        {
            diagnostics(5, (char*)"TabularGetCell %p start=\'%s\'", cell_start, cell_start);
            cell_end = NextAmpersand(cell_start);
        }
        if ((int)*cell_end != 38){
            {
                *cell = strdup_noendblanks(cell_start);
            }
            return;
        }
        {
            *next_cell = cell_end + 1;
            dup = my_strndup(cell_start, (size_t)(cell_end - (char*)cell_start));
            *cell = strdup_noendblanks((const char*)dup);
            free((void*)dup);
        }
        return;
    }
}

static void TabularMultiParameters(const char* cell, int* col_span, char* align, int* lvert, int* rvert)
{
    char* p;
    char* format;
    char* num;
    TabularT* mtable;
    size_t tmp;
    {
        {
            diagnostics(5, (char*)"TabularMultiParameters cell=\"%s\" ", cell);
            *col_span = 0;
            *align = (char)'\000';
            *lvert = 0;
            *rvert = 0;
            p = strstr(cell, "\\multicolumn");
        }
        if ((unsigned long )p == (unsigned long )((void*)0)){
            return;
        }
        {
            tmp = strlen("\\multicolumn");
            p += tmp;
            num = getStringBraceParam(&p);
            format = getStringBraceParam(&p);
            mtable = NewTabularFromFormat((const char*)format);
            *lvert = *(mtable->vert + 0);
            *rvert = *(mtable->vert + mtable->n);
            *align = *(mtable->align + 1);
            *col_span = atoi((const char*)num);
            free((void*)num);
            free((void*)format);
            FreeTabular(mtable);
            diagnostics(5, (char*)"TabularMultiParameters n=%d, align=%c", *col_span, (int)*align);
        }
        return;
    }
}

static int TabularHline(const char* row)
{
    char* s;
    char* t;
    {
        if ((unsigned long )row == (unsigned long )((void*)0)){
            return (0);
        }
        {
            s = strstr(row, "\\hline");
        }
        if ((unsigned long )s == (unsigned long )((void*)0)){
            return (0);
        }
        {
            t = strstr((const char*)(s + 6), "\\hline");
        }
        if ((unsigned long )t == (unsigned long )((void*)0)){
            return (1);
        }
        return (2);
    }
}

static char* TabularCline(const char* row, int columns)
{
    char* s;
    char* x;
    int i;
    int n;
    int m;
    char* cline;
    void* tmp;
    size_t tmp___0;
    {
        {
            cline = (char*)((void*)0);
            tmp = calloc((size_t)(columns + 2), sizeof (char));
            cline = (char*)tmp;
        }
        if ((unsigned long )row == (unsigned long )((void*)0)){
            return (cline);
        }
        {
            n = TabularHline(row);
            i = 0;
        }
        {
            while (1){
                while_continue:
                ;
                if (!(i <= columns)){
                    goto while_break;
                }
                *(cline + i) = (char)n;
                i++;
            }
            while_break:
            ;
        }
        if (n){
            return (cline);
        }
        {
            s = (char*)row;
            tmp___0 = strlen(row);
            x = (char*)row + tmp___0;
        }
        {
            while (1){
                while_continue___0:
                ;
                if (!((unsigned long )s < (unsigned long )x)){
                    goto while_break___0;
                }
                {
                    s = strstr((const char*)s, "\\cline{");
                }
                if ((unsigned long )s == (unsigned long )((void*)0)){
                    return (cline);
                }
                s += 7;
                {
                    while (1){
                        while_continue___1:
                        ;
                        if (*s){
                            if (!((int)*s == 32)){
                                if (!((int)*s == 10)){
                                    goto while_break___1;
                                }
                            }
                        }else{
                            goto while_break___1;
                        }
                        s++;
                    }
                    while_break___1:
                    ;
                }
                if ((int)*s <= 48){
                    return (cline);
                }else
                    if ((int)*s >= 57){
                        return (cline);
                    }

                {
                    n = atoi((const char*)s);
                }
                {
                    while (1){
                        while_continue___2:
                        ;
                        if (*s){
                            if (!((int)*s != 45)){
                                goto while_break___2;
                            }
                        }else{
                            goto while_break___2;
                        }
                        s++;
                    }
                    while_break___2:
                    ;
                }
                s++;
                {
                    while (1){
                        while_continue___3:
                        ;
                        if (*s){
                            if (!((int)*s == 32)){
                                if (!((int)*s == 10)){
                                    goto while_break___3;
                                }
                            }
                        }else{
                            goto while_break___3;
                        }
                        s++;
                    }
                    while_break___3:
                    ;
                }
                if ((int)*s <= 48){
                    return (cline);
                }else
                    if ((int)*s >= 57){
                        return (cline);
                    }

                {
                    m = atoi((const char*)s);
                    i = n;
                }
                {
                    while (1){
                        while_continue___4:
                        ;
                        if (!(i <= m)){
                            goto while_break___4;
                        }
                        if (i <= columns){
                            if (i >= 1){
                                *(cline + i) = (char)1;
                            }
                        }
                        i++;
                    }
                    while_break___4:
                    ;
                }
                {
                    while (1){
                        while_continue___5:
                        ;
                        if (*s){
                            if (!((int)*s != 125)){
                                goto while_break___5;
                            }
                        }else{
                            goto while_break___5;
                        }
                        s++;
                    }
                    while_break___5:
                    ;
                }
            }
            while_break___0:
            ;
        }
        return (cline);
    }
}

static void TabularBeginRow(TabularT* table, const char* this_row, const char* next_row, int first_row)
{
    int i;
    int span;
    int column;
    int multi_right_border;
    int multi_left_border;
    int next_left_border;
    int left_border;
    int right_border;
    char align;
    char* cell_start;
    char* cell_end;
    char* cell;
    int top___0;
    int bottom;
    char* cline;
    int tmp;
    int tmp___0;
    {
        {
            fprintRTF((char*)"{\\trowd");
            cell_start = (char*)this_row;
            column = 0;
            cline = TabularCline(next_row, table->n);
            next_left_border = *(table->vert + column);
        }
        {
            while (1){
                while_continue:
                ;
                if (!cell_start){
                    goto while_break;
                }
                top___0 = 0;
                left_border = next_left_border;
                right_border = *(table->vert + (column + 1));
                bottom = (int)*(cline + (column + 1));
                if (first_row){
                    {
                        top___0 = TabularHline(this_row);
                    }
                }
                {
                    TabularGetCell((const char*)cell_start, &cell, &cell_end);
                    TabularMultiParameters((const char*)cell, &span, &align, &multi_left_border, &multi_right_border);
                }
                if (span > 1){
                    {
                        fprintRTF((char*)"\\clmgf");
                    }
                }
                if (span == 0){
                    if (left_border == 2){
                        {
                            fprintRTF((char*)"\\clbrdrl\\brdrdb");
                        }
                    }else{
                        goto _L;
                    }
                }else
                    _L:
                    if (span > 0){
                        if (multi_left_border == 2){
                            {
                                fprintRTF((char*)"\\clbrdrl\\brdrdb");
                            }
                        }
                    }

                if (span == 0){
                    if (left_border == 1){
                        {
                            fprintRTF((char*)"\\clbrdrl\\brdrs");
                        }
                    }else{
                        goto _L___0;
                    }
                }else
                    _L___0:
                    if (span > 0){
                        if (multi_left_border == 1){
                            {
                                fprintRTF((char*)"\\clbrdrl\\brdrs");
                            }
                        }
                    }

                next_left_border = 0;
                if (top___0 == 1){
                    {
                        fprintRTF((char*)"\\clbrdrt\\brdrs");
                    }
                }
                if (top___0 == 2){
                    {
                        fprintRTF((char*)"\\clbrdrt\\brdrdb");
                    }
                }
                if (bottom == 1){
                    {
                        fprintRTF((char*)"\\clbrdrb\\brdrs");
                    }
                }
                if (bottom == 2){
                    {
                        fprintRTF((char*)"\\clbrdrb\\brdrdb");
                    }
                }
                if (span == 0){
                    if (right_border == 2){
                        {
                            fprintRTF((char*)"\\clbrdrr\\brdrdb");
                            next_left_border = 2;
                        }
                    }else{
                        goto _L___1;
                    }
                }else
                    _L___1:
                    if (span == 1){
                        if (multi_right_border == 2){
                            {
                                fprintRTF((char*)"\\clbrdrr\\brdrdb");
                                next_left_border = 2;
                            }
                        }
                    }

                if (span == 0){
                    if (right_border == 1){
                        {
                            fprintRTF((char*)"\\clbrdrr\\brdrs");
                            next_left_border = 1;
                        }
                    }else{
                        goto _L___2;
                    }
                }else
                    _L___2:
                    if (span == 1){
                        if (multi_right_border == 1){
                            {
                                fprintRTF((char*)"\\clbrdrr\\brdrs");
                                next_left_border = 1;
                            }
                        }
                    }

                {
                    column++;
                    tmp = TabularColumnPosition(table, column);
                    fprintRTF((char*)"\\cellx%d", tmp);
                    i = 2;
                }
                {
                    while (1){
                        while_continue___0:
                        ;
                        if (!(i <= span)){
                            goto while_break___0;
                        }
                        {
                            fprintRTF((char*)"\\clmrg");
                        }
                        if (top___0 == 1){
                            {
                                fprintRTF((char*)"\\clbrdrt\\brdrs");
                            }
                        }
                        if (top___0 == 2){
                            {
                                fprintRTF((char*)"\\clbrdrt\\brdrdb");
                            }
                        }
                        if (bottom == 1){
                            {
                                fprintRTF((char*)"\\clbrdrb\\brdrs");
                            }
                        }
                        if (bottom == 2){
                            {
                                fprintRTF((char*)"\\clbrdrb\\brdrdb");
                            }
                        }
                        if (i == span){
                            if (multi_right_border == 2){
                                {
                                    fprintRTF((char*)"\\clbrdrr\\brdrdb");
                                    next_left_border = 2;
                                }
                            }
                        }
                        if (i == span){
                            if (multi_right_border == 1){
                                {
                                    fprintRTF((char*)"\\clbrdrr\\brdrs");
                                    next_left_border = 1;
                                }
                            }
                        }
                        {
                            column++;
                            tmp___0 = TabularColumnPosition(table, column);
                            fprintRTF((char*)"\\cellx%d", tmp___0);
                            i++;
                        }
                    }
                    while_break___0:
                    ;
                }
                {
                    free((void*)cell);
                    cell_start = cell_end;
                }
            }
            while_break:
            ;
        }
        {
            fprintRTF((char*)"\n");
            free((void*)cline);
        }
        return;
    }
}

static void TabularEndRow(void)
{
    {
        {
            fprintRTF((char*)"\\row}\n");
        }
        return;
    }
}

static char TabularColumnAlignment(TabularT* table, int column)
{
    {
        return (*(table->align + (column + 1)));
    }
}

static void TabularWriteRow(TabularT* table, const char* this_row, const char* next_row, int height, int first_row)
{
    char* cell;
    char* cell_start;
    char* cell_end;
    char align;
    int n;
    int lvert;
    int rvert;
    size_t tmp;
    size_t tmp___0;
    char* tmp___1;
    {
        if ((unsigned long )this_row == (unsigned long )((void*)0)){
            return;
        }else{
            {
                tmp = strlen(this_row);
            }
            if (tmp == 0UL){
                return;
            }
        }
        {
            diagnostics(5, (char*)"TabularWriteRow height=%d twpi, row <%s>", height, this_row);
        }
        if ((unsigned long )next_row == (unsigned long )((void*)0)){
            if (table->n == 1){
                {
                    tmp___0 = strlen(this_row);
                }
                if (tmp___0 == 0UL){
                    return;
                }
            }
            if (table->n > 1){
                {
                    tmp___1 = strchr(this_row, '&');
                }
                if (!tmp___1){
                    {
                        TabularMultiParameters(this_row, &n, &align, &lvert, &rvert);
                    }
                    if (n == 0){
                        return;
                    }
                }
            }
        }
        {
            TabularBeginRow(table, this_row, next_row, first_row);
            cell_start = (char*)this_row;
            table->i = 0;
        }
        {
            while (1){
                while_continue:
                ;
                if (!cell_start){
                    goto while_break;
                }
                {
                    TabularGetCell((const char*)cell_start, &cell, &cell_end);
                    TabularMultiParameters((const char*)cell, &n, &align, &lvert, &rvert);
                }
                if (n == 0){
                    {
                        align = TabularColumnAlignment(table, table->i);
                        n = 1;
                    }
                }
                {
                    BeginCellRTF(align);
                }
                if ((unsigned long )cell != (unsigned long )((void*)0)){
                    {
                        fprintRTF((char*)"{");
                        ConvertString((const char*)cell);
                        fprintRTF((char*)"}");
                    }
                }
                {
                    EndCellRTF();
                    table->i += n;
                    cell_start = cell_end;
                    free((void*)cell);
                }
            }
            while_break:
            ;
        }
        {
            TabularEndRow();
        }
        return;
    }
}

static int TabularMeasureCell(const char* cell)
{
    char* s;
    int len;
    char* num;
    char* format;
    char* text;
    char* xtext;
    size_t tmp;
    size_t tmp___0;
    size_t tmp___1;
    {
        if ((unsigned long )cell == (unsigned long )((void*)0)){
            return (0);
        }else
            if ((const int)*cell == 0){
                return (0);
            }

        {
            s = strstr(cell, "multicolumn");
        }
        if (s){
            {
                tmp = strlen("multicolumn");
                PushSource((const char*)((void*)0), (const char*)(s + tmp));
                num = getBraceParam();
                format = getBraceParam();
                text = getBraceParam();
                PopSource();
                xtext = strdup_noendblanks((const char*)text);
                tmp___0 = strlen((const char*)xtext);
                len = (int)tmp___0;
                free((void*)num);
                free((void*)format);
                free((void*)text);
                free((void*)xtext);
            }
            return (len);
        }
        {
            tmp___1 = strlen(cell);
        }
        return ((int)tmp___1);
    }
}

static void TabularSetWidths(TabularT* table)
{
    double total_chars;
    double twips_to_distribute;
    double pre_allocated;
    int i;
    double twips_per_char;
    int min_width;
    int tmp;
    {
        min_width = 100;
        total_chars = (double)0;
        i = 1;
        {
            while (1){
                while_continue:
                ;
                if (!(i <= table->n)){
                    goto while_break;
                }
                if (*(table->width + i) == -1){
                    total_chars += (double)*(table->chars + i);
                }
                i++;
            }
            while_break:
            ;
        }
        if (total_chars == (double)0){
            return;
        }
        pre_allocated = (double)0;
        i = 1;
        {
            while (1){
                while_continue___0:
                ;
                if (!(i <= table->n)){
                    goto while_break___0;
                }
                if (*(table->width + i) != -1){
                    pre_allocated += (double)*(table->width + i);
                }else{
                    pre_allocated += (double)min_width;
                }
                i++;
            }
            while_break___0:
            ;
        }
        {
            tmp = getLength((char*)"textwidth");
            twips_to_distribute = (double)tmp - pre_allocated;
        }
        if (twips_to_distribute < (double)0){
            twips_to_distribute = (double)0;
        }
        {
            twips_per_char = twips_to_distribute / total_chars;
            diagnostics(5, (char*)"used=%g, allocatable=%g, per_char=%g", pre_allocated, twips_to_distribute, twips_per_char);
            i = 1;
        }
        {
            while (1){
                while_continue___1:
                ;
                if (!(i <= table->n)){
                    goto while_break___1;
                }
                if (*(table->width + i) == -1){
                    *(table->width + i) = (int)((double)min_width + twips_per_char * (double)*(table->chars + i));
                }
                i++;
            }
            while_break___1:
            ;
        }
        return;
    }
}

static void TabularMeasureRow(TabularT* table, const char* this_row, int height)
{
    char* cell;
    char* cell_start;
    char* cell_end;
    char align;
    int n;
    int lvert;
    int rvert;
    int iCol;
    int len;
    size_t tmp;
    {
        table->i = 0;
        if ((unsigned long )this_row == (unsigned long )((void*)0)){
            return;
        }else{
            {
                tmp = strlen(this_row);
            }
            if (tmp == 0UL){
                return;
            }
        }
        {
            diagnostics(5, (char*)"TabularMeasureRow height=%d twpi, row <%s>", height, this_row);
            cell_start = (char*)this_row;
            iCol = 0;
        }
        {
            while (1){
                while_continue:
                ;
                if (!cell_start){
                    goto while_break;
                }
                {
                    TabularGetCell((const char*)cell_start, &cell, &cell_end);
                    iCol++;
                    TabularMultiParameters((const char*)cell, &n, &align, &lvert, &rvert);
                }
                if (n <= 1){
                    {
                        len = TabularMeasureCell((const char*)cell);
                    }
                }else{
                    len = 0;
                    iCol += n - 1;
                }
                if (*(table->chars + iCol) < len){
                    *(table->chars + iCol) = len;
                }
                {
                    cell_start = cell_end;
                    free((void*)cell);
                }
            }
            while_break:
            ;
        }
        return;
    }
}

void CmdTabular(int code)
{
    int true_code;
    int this_height;
    int first_row;
    int begins;
    int ends;
    char* end;
    char* begin;
    char* this_row;
    char* next_row_start;
    char* table;
    char* cols;
    char* pos;
    char* width;
    TabularT* tabular_layout;
    char* pre;
    char* tmp;
    char* table2;
    char* table3;
    char* table4;
    char* p;
    int num;
    int tmp___0;
    char* tmp___1;
    char* tmp___2;
    char* tmp___3;
    const char* tmp___4;
    char* next_row;
    {
        end = (char*)((void*)0);
        begin = (char*)((void*)0);
        table = (char*)((void*)0);
        cols = (char*)((void*)0);
        pos = (char*)((void*)0);
        width = (char*)((void*)0);
        if (!(code & 16384)){
            {
                diagnostics(4, (char*)"Exiting CmdTabular");
                g_processing_tabular = 0;
            }
            return;
        }
        g_processing_tabular = 1;
        width = (char*)((void*)0);
        pos = (char*)((void*)0);
        cols = (char*)((void*)0);
        true_code = code & -16385;
        {
            if (true_code == 1){
                goto case_1;
            }
            if (true_code == 2){
                goto case_2;
            }
            if (true_code == 3){
                goto case_3;
            }
            if (true_code == 4){
                goto case_4;
            }
            goto switch_default;
            case_1:
            {
                end = strdup("\\end{tabular}");
                begin = strdup("\\begin{tabular}");
            }
            goto switch_break;
            case_2:
            {
                end = strdup("\\end{tabular*}");
                begin = strdup("\\begin{tabular*}");
                width = getBraceParam();
            }
            goto switch_break;
            case_3:
            {
                end = strdup("\\end{longtable}");
                begin = strdup("\\begin{longtable}");
            }
            goto switch_break;
            case_4:
            {
                end = strdup("\\end{longtable*}");
                begin = strdup("\\begin{longtable*}");
                width = getBraceParam();
            }
            goto switch_break;
            switch_default:
            {
                diagnostics(0, (char*)"This can\'t happen --- bad code to CmdTabular");
                exit(1);
            }
            switch_break:
            ;
        }
        {
            pos = getBracketParam();
            cols = getBraceParam();
            table = getTexUntil(end, 0);
        }
        if (g_tabular_display_bitmap){
            {
                tmp = strdup_together4((const char*)begin, "{", (const char*)cols, "}");
                pre = tmp;
                PrepareDisplayedBitmap((char*)"tabular");
                WriteLatexAsBitmap(pre, table, end);
                FinishDisplayedBitmap();
                free((void*)pre);
            }
        }
        if (g_tabular_display_rtf){
            {
                begins = strstr_count((const char*)table, begin);
                ends = strstr_count((const char*)table, end);
            }
            {
                while (1){
                    while_continue:
                    ;
                    if (!(begins > ends)){
                        goto while_break;
                    }
                    if (begins > ends){
                        {
                            table2 = getTexUntil(end, 0);
                            table3 = strdup_together((const char*)table, (const char*)end);
                            table4 = strdup_together((const char*)table3, (const char*)table2);
                            free((void*)table);
                            free((void*)table2);
                            free((void*)table3);
                            table = table4;
                        }
                    }
                    {
                        begins = strstr_count((const char*)table, begin);
                        ends = strstr_count((const char*)table, end);
                    }
                }
                while_break:
                ;
            }
            if (begins > 0){
                {
                    tmp___0 = TexFontNumber("Typewriter");
                    num = tmp___0;
                    diagnostics(1, (char*)"Nested tabular/tabbing environments not allowed");
                    diagnostics(5, (char*)"table_table_table_table_table\n%stable_table_table_table_table", table);
                    fprintRTF((char*)"{\\pard\\ql\\b0\\i0\\scaps0\\f%d ", num);
                    p = begin;
                }
                {
                    while (1){
                        while_continue___0:
                        ;
                        if (!*p){
                            goto while_break___0;
                        }
                        {
                            tmp___1 = p;
                            p++;
                            fprintRTF((char*)"%c", (int)*tmp___1);
                        }
                    }
                    while_break___0:
                    ;
                }
                p = table;
                {
                    while (1){
                        while_continue___1:
                        ;
                        if (!*p){
                            goto while_break___1;
                        }
                        {
                            tmp___2 = p;
                            p++;
                            fprintRTF((char*)"%c", (int)*tmp___2);
                        }
                    }
                    while_break___1:
                    ;
                }
                p = end;
                {
                    while (1){
                        while_continue___2:
                        ;
                        if (!*p){
                            goto while_break___2;
                        }
                        {
                            tmp___3 = p;
                            p++;
                            fprintRTF((char*)"%c", (int)*tmp___3);
                        }
                    }
                    while_break___2:
                    ;
                }
            }else{
                if (pos){
                    tmp___4 = (const char*)pos;
                }else{
                    tmp___4 = "";
                }
                {
                    diagnostics(4, (char*)"Entering CmdTabular() options [%s], format {%s}", tmp___4, cols);
                    tabular_layout = TabularPreamble((const char*)cols);
                    diagnostics(5, (char*)"*********** TABULAR TABULAR TABULAR *************");
                    diagnostics(5, (char*)"%s", table);
                    diagnostics(5, (char*)"*********** TABULAR TABULAR TABULAR *************");
                    TabularGetRow((const char*)table, &this_row, &next_row_start, &this_height);
                }
                {
                    while (1){
                        while_continue___3:
                        ;
                        if (!this_row){
                            goto while_break___3;
                        }
                        {
                            TabularMeasureRow(tabular_layout, (const char*)this_row, this_height);
                            free((void*)this_row);
                            TabularGetRow((const char*)next_row_start, &this_row, &next_row_start, &this_height);
                        }
                    }
                    while_break___3:
                    ;
                }
                {
                    TabularSetWidths(tabular_layout);
                    TabularGetRow((const char*)table, &this_row, &next_row_start, &this_height);
                    first_row = 1;
                }
                {
                    while (1){
                        while_continue___4:
                        ;
                        if (!this_row){
                            goto while_break___4;
                        }
                        {
                            TabularGetRow((const char*)next_row_start, &next_row, &next_row_start, &this_height);
                            TabularWriteRow(tabular_layout, (const char*)this_row, (const char*)next_row, this_height, first_row);
                            free((void*)this_row);
                            this_row = next_row;
                            first_row = 0;
                        }
                    }
                    while_break___4:
                    ;
                }
                if (cols){
                    {
                        free((void*)cols);
                    }
                }
                if (pos){
                    {
                        free((void*)pos);
                    }
                }
                if (width){
                    {
                        free((void*)width);
                    }
                }
                if (tabular_layout){
                    {
                        FreeTabular(tabular_layout);
                    }
                }
            }
        }
        {
            ConvertString((const char*)end);
            free((void*)table);
            free((void*)end);
            free((void*)begin);
        }
        return;
    }
}

static int TabbingColumnPosition(int n, int total)
{
    int colWidth;
    int tmp;
    {
        {
            tmp = getLength((char*)"textwidth");
            colWidth = tmp / total;
        }
        return (colWidth * (n + 1));
    }
}

static char* skip_verb(char* s)
{
    char endchar;
    int tmp;
    {
        {
            diagnostics(6, (char*)"before verb <<%s>>", s);
        }
        if (s){
            {
                tmp = strncmp((const char*)s, "verb", (size_t)4);
            }
            if (tmp == 0){
                s += 4;
                endchar = *s;
                s++;
                {
                    while (1){
                        while_continue:
                        ;
                        if (*s){
                            if (!((int)*s != (int)endchar)){
                                goto while_break;
                            }
                        }else{
                            goto while_break;
                        }
                        s++;
                    }
                    while_break:
                    ;
                }
                if (*s){
                    s++;
                }
            }
        }
        {
            diagnostics(6, (char*)"after  verb <<%s>>", s);
        }
        return (s);
    }
}

static void TabbingNextCellEnd(char* t, char** cell_end, char** next_cell)
{
    char* s;
    {
        s = t;
        {
            while (1){
                while_continue:
                ;
                if (!s){
                    goto while_break;
                }
                if ((int)*s == 0){
                    *cell_end = s;
                    *next_cell = s;
                    return;
                }
                if ((int)*s == 92){
                    {
                        s++;
                        s = skip_verb(s);
                    }
                    if ((int)*s == 61){
                        *cell_end = s - 1;
                        *next_cell = s + 1;
                        return;
                    }else
                        if ((int)*s == 62){
                            *cell_end = s - 1;
                            *next_cell = s + 1;
                            return;
                        }else
                            if ((int)*s == 60){
                                *cell_end = s - 1;
                                *next_cell = s + 1;
                                return;
                            }else
                                if ((int)*s == 39){
                                    *cell_end = s - 1;
                                    *next_cell = s + 1;
                                    return;
                                }else
                                    if ((int)*s == 96){
                                        *cell_end = s - 1;
                                        *next_cell = s + 1;
                                        return;
                                    }
                }
                if ((int)*s == 0){
                    *cell_end = s;
                    *next_cell = s;
                    return;
                }
                s++;
            }
            while_break:
            ;
        }
        return;
    }
}

static char* TabbingNextCell(char* cell_start, char** cell_end)
{
    char* end;
    char* dup;
    char* dup2;
    char* next_cell;
    char* p;
    {
        {
            end = (char*)((void*)0);
            next_cell = (char*)((void*)0);
            TabbingNextCellEnd(cell_start, &end, &next_cell);
        }
        if ((unsigned long )end < (unsigned long )cell_start){
            end = cell_start;
        }
        {
            dup = my_strndup((const char*)cell_start, (size_t)(end - cell_start));
        }
        if ((int)*next_cell == 0){
            *cell_end = (char*)((void*)0);
        }else{
            *cell_end = next_cell;
        }
        {
            while (1){
                while_continue:
                ;
                {
                    p = strstr((const char*)dup, "\\+");
                }
                if (!((unsigned long )p != (unsigned long )((void*)0))){
                    {
                        p = strstr((const char*)dup, "\\-");
                    }
                    if (!((unsigned long )p != (unsigned long )((void*)0))){
                        goto while_break;
                    }
                }
                *p = (char)' ';
                p++;
                *p = (char)' ';
            }
            while_break:
            ;
        }
        {
            dup2 = strdup_noendblanks((const char*)dup);
            free((void*)dup);
            diagnostics(5, (char*)"next cell = [[%s]]", dup);
        }
        return (dup2);
    }
}

static void TabbingBeginRow(int n, int n_total, char* align)
{
    int i;
    int tmp;
    {
        if (n == 0){
            return;
        }
        {
            fprintRTF((char*)"{\\trowd");
            i = 0;
        }
        {
            while (1){
                while_continue:
                ;
                if (!(i < n)){
                    goto while_break;
                }
                {
                    tmp = TabbingColumnPosition(i, n_total);
                    fprintRTF((char*)"\\cellx%d", tmp);
                    i++;
                }
            }
            while_break:
            ;
        }
        {
            fprintRTF((char*)"\n");
            i = 0;
        }
        {
            while (1){
                while_continue___0:
                ;
                if (!(i < g_tabbing_left_position)){
                    goto while_break___0;
                }
                {
                    BeginCellRTF(*(align + i));
                    EndCellRTF();
                    i++;
                }
            }
            while_break___0:
            ;
        }
        return;
    }
}

static void TabbingWriteRow(char* this_row, int n, int n_total, char* align)
{
    char* start;
    char* end;
    char* cell;
    int i;
    char* tmp;
    size_t tmp___0;
    {
        {
            diagnostics(5, (char*)"TabbingWriteRow n=%d <%s> [%s]", n, align, this_row);
        }
        if ((unsigned long )this_row == (unsigned long )((void*)0)){
            return;
        }else
            if (n == 0){
                return;
            }

        {
            tmp = strstr((const char*)this_row, "\\kill");
        }
        if (tmp){
            return;
        }
        {
            TabbingBeginRow(n, n_total, align);
            start = this_row;
            tmp___0 = strlen((const char*)this_row);
            end = this_row + tmp___0;
            i = g_tabbing_left_position;
        }
        {
            while (1){
                while_continue:
                ;
                if (!(i < n)){
                    goto while_break;
                }
                {
                    BeginCellRTF(*(align + i));
                    cell = TabbingNextCell(start, &end);
                }
                if (cell){
                    {
                        diagnostics(5, (char*)"cell=<%s>", cell);
                        ConvertString((const char*)cell);
                        free((void*)cell);
                    }
                }
                {
                    EndCellRTF();
                    start = end;
                    i++;
                }
            }
            while_break:
            ;
        }
        {
            fprintRTF((char*)"\\row}\n");
        }
        return;
    }
}

static void TabbingGetRow(char* table, char** row, char** next_row)
{
    char* s;
    char* arow;
    size_t row_chars;
    int slash;
    int tmp;
    const unsigned short **tmp___0;
    void* tmp___1;
    {
        row_chars = (size_t)0;
        s = table;
        *row = (char*)((void*)0);
        *next_row = (char*)((void*)0);
        if (!s){
            return;
        }
        slash = 0;
        {
            while (1){
                while_continue:
                ;
                if (!((int)*s == 0)){
                    if ((int)*s == 92){
                        if (slash){
                            goto while_break;
                        }else{
                            goto _L;
                        }
                    }else
                        _L:
                        if (row_chars > 6UL){
                            {
                                tmp = strncmp((const char*)(s - 5), "\\kill", (size_t)5);
                            }
                            if (tmp == 0){
                                {
                                    tmp___0 = __ctype_b_loc();
                                }
                                if (!((const int)*(*tmp___0 + (int)*s) & 1024)){
                                    goto while_break;
                                }
                            }
                        }
                }else{
                    goto while_break;
                }
                row_chars++;
                if ((int)*s == 92){
                    slash = 1;
                }else{
                    slash = 0;
                }
                s++;
            }
            while_break:
            ;
        }
        if ((int)*s == 92){
            if (slash){
                row_chars--;
                if ((int)*(s + 1) == 91){
                    s++;
                    {
                        while (1){
                            while_continue___0:
                            ;
                            if ((int)*s != 0){
                                if (!((int)*s != 93)){
                                    goto while_break___0;
                                }
                            }else{
                                goto while_break___0;
                            }
                            s++;
                        }
                        while_break___0:
                        ;
                    }
                }
            }
        }
        if ((int)*s != 0){
            *next_row = s + 1;
        }
        {
            tmp___1 = malloc((row_chars + 1UL) * sizeof (char));
            arow = (char*)tmp___1;
            strncpy((char*)arow, (const char*)table, row_chars);
            *(arow + row_chars) = (char)'\000';
            diagnostics(5, (char*)"TabbingGetRow obtained=<%s> remaining[%s]", arow, *next_row);
            *row = strdup_noendblanks((const char*)arow);
            free((void*)arow);
        }
        return;
    }
}

static void TabbingGetColumnAlignments(char* row, char* align, int* n, int* next_left)
{
    int i;
    {
        *next_left = g_tabbing_left_position;
        *n = *next_left + 1;
        i = 0;
        {
            while (1){
                while_continue:
                ;
                if (!(i < *n)){
                    goto while_break;
                }
                *(align + i) = (char)'l';
                i++;
            }
            while_break:
            ;
        }
        {
            while (1){
                while_continue___0:
                ;
                if (row){
                    if (!*row){
                        goto while_break___0;
                    }
                }else{
                    goto while_break___0;
                }
                if ((int)*row != 92){
                    row++;
                    goto while_continue___0;
                }
                {
                    row++;
                    row = skip_verb(row);
                }
                {
                    if ((int)*row == 61){
                        goto case_61;
                    }
                    if ((int)*row == 62){
                        goto case_62;
                    }
                    if ((int)*row == 60){
                        goto case_60;
                    }
                    if ((int)*row == 39){
                        goto case_39;
                    }
                    if ((int)*row == 96){
                        goto case_96;
                    }
                    if ((int)*row == 43){
                        goto case_43;
                    }
                    if ((int)*row == 45){
                        goto case_45;
                    }
                    goto switch_default;
                    case_61:
                    *(align + *n) = (char)'l';
                    (*n)++;
                    goto switch_break;
                    case_62:
                    *(align + *n) = (char)'l';
                    (*n)++;
                    goto switch_break;
                    case_60:
                    goto switch_break;
                    case_39:
                    *(align + (*n - 2)) = (char)'r';
                    *(align + (*n - 1)) = (char)'l';
                    goto switch_break;
                    case_96:
                    *(align + *n) = (char)'r';
                    (*n)++;
                    goto switch_break;
                    case_43:
                    (*next_left)++;
                    goto switch_break;
                    case_45:
                    (*next_left)--;
                    goto switch_break;
                    switch_default:
                    goto switch_break;
                    switch_break:
                    ;
                }
            }
            while_break___0:
            ;
        }
        *(align + *n) = (char)'\000';
        return;
    }
}

void CmdTabbing(int code)
{
    int n;
    int n_total;
    int next_left;
    char* end;
    char* this_row;
    char* next_row_start;
    char* row_start;
    char* table;
    char align[31];
    int tmp;
    size_t tmp___0;
    {
        table = (char*)((void*)0);
        if (!(code & 16384)){
            {
                diagnostics(4, (char*)"Exiting CmdTabbing");
                g_processing_tabbing = 0;
            }
            return;
        }
        {
            g_processing_tabbing = 1;
            n = 0;
            g_tabbing_left_position = 0;
            my_strlcpy(align, "l", (size_t)31);
            end = strdup("\\end{tabbing}");
            table = getTexUntil(end, 0);
            diagnostics(4, (char*)"Entering CmdTabbing()");
        }
        if (g_tabular_display_bitmap){
            {
                PrepareDisplayedBitmap((char*)"tabbing");
                WriteLatexAsBitmap((char*)"\\begin{tabbing}", table, end);
                FinishDisplayedBitmap();
            }
        }
        if (g_tabular_display_rtf){
            {
                row_start = table;
                TabbingGetRow(row_start, &this_row, &next_row_start);
                diagnostics(5, (char*)"tabbing_tabbing_tabbing\n%s\ntabbing_tabbing_tabbing", table);
                tmp = getTexMode();
            }
            if (tmp != 2){
                {
                    CmdIndent(1);
                    startParagraph("tabbing", 1);
                }
            }
            {
                fprintRTF((char*)"\\par\n");
                n_total = 0;
            }
            {
                while (1){
                    while_continue:
                    ;
                    if (this_row){
                        {
                            tmp___0 = strlen((const char*)this_row);
                        }
                        if (!(tmp___0 >= 0UL)){
                            goto while_break;
                        }
                    }else{
                        goto while_break;
                    }
                    {
                        show_string(5, (const char*)this_row, "row");
                        TabbingGetColumnAlignments(this_row, align, &n, &next_left);
                    }
                    if (n > n_total){
                        n_total = n;
                    }
                    {
                        diagnostics(4, (char*)"this row n=%d <%s> left_tab=%d", n, align, g_tabbing_left_position);
                        TabbingWriteRow(this_row, n, n_total, align);
                        g_tabbing_left_position = next_left;
                        row_start = next_row_start;
                        free((void*)this_row);
                        TabbingGetRow(row_start, &this_row, &next_row_start);
                    }
                }
                while_break:
                ;
            }
        }
        {
            ConvertString((const char*)end);
            free((void*)table);
            free((void*)end);
        }
        return;
    }
}

static char oldalignment;

void CmdTable(int code)
{
    char* location;
    char* table_contents;
    int true_code;
    int tmp;
    int tmp___0;
    int tmp___1;
    {
        true_code = code & -16385;
        if (code & 16384){
            {
                location = getBracketParam();
            }
            if (location){
                {
                    free((void*)location);
                }
            }
            {
                CmdEndParagraph(0);
                tmp = getAlignment();
                oldalignment = (char)tmp;
                setAlignment('j');
                CmdVspace(3);
                CmdIndent(1);
                g_processing_table = 1;
            }
            if (true_code == 2){
                {
                    table_contents = getTexUntil((char*)"\\end{table}", 1);
                }
            }else{
                {
                    table_contents = getTexUntil((char*)"\\end{table*}", 1);
                }
            }
            {
                g_table_label = ExtractLabelTag((const char*)table_contents);
            }
            if (g_endfloat_tables){
                if (g_endfloat_markers){
                    {
                        setAlignment('c');
                        startParagraph("endfloat", 2);
                        incrementCounter((char*)"endfloattable");
                        fprintRTF((char*)"[");
                        ConvertBabelName((char*)"TABLENAME");
                        fprintRTF((char*)" ");
                    }
                    if (g_document_type != 1){
                        if (g_document_type != 6){
                            {
                                tmp___0 = getCounter((char*)"chapter");
                                fprintRTF((char*)"%d.", tmp___0);
                            }
                        }
                    }
                    {
                        tmp___1 = getCounter((char*)"endfloattable");
                        fprintRTF((char*)"%d about here]", tmp___1);
                    }
                }
            }else{
                {
                    startParagraph("table", 2);
                    ConvertString((const char*)table_contents);
                }
            }
            {
                free((void*)table_contents);
            }
            if (true_code == 2){
                {
                    ConvertString("\\end{table}");
                }
            }else{
                {
                    ConvertString("\\end{table*}");
                }
            }
        }else{
            {
                g_processing_table = 0;
                CmdEndParagraph(0);
                safe_free(g_table_label);
                setAlignment((int)oldalignment);
                CmdVspace(3);
            }
        }
        return;
    }
}

void CmdMultiCol(int code)
{
    long numCol;
    long i;
    char* num;
    char* format;
    char* content;
    char* bcontent;
    int tmp;
    {
        {
            num = getBraceParam();
            format = getBraceParam();
            bcontent = getBraceParam();
            content = strdup_noendblanks((const char*)bcontent);
            free((void*)bcontent);
            diagnostics(4, (char*)"CmdMultiCol cols=%s format=<%s> content=<%s>", num, format, content);
            tmp = atoi((const char*)num);
            numCol = (long )tmp;
            free((void*)num);
            diagnostics(4, (char*)"Entering Convert() from CmdMultiCol()");
            ConvertString((const char*)content);
            diagnostics(4, (char*)"Exiting Convert() from CmdMultiCol()");
            i = 1L;
        }
        {
            while (1){
                while_continue:
                ;
                if (!(i < numCol)){
                    goto while_break;
                }
                {
                    fprintRTF((char*)"\\cell}\n");
                    fprintRTF((char*)"{\\pard\\intbl");
                    i++;
                }
            }
            while_break:
            ;
        }
        {
            free((void*)content);
            free((void*)format);
        }
        return;
    }
}

void CmdHline(int code)
{
    char* s;
    {
        if (code == 1){
            {
                s = getBraceParam();
                free((void*)s);
                skipSpaces();
            }
        }
        return;
    }
}

static void HA_ExtractTemplateAndLines(const char* s, char** thetemplate, char*** thelines, int* nl)
{
    char* p;
    char* ss;
    char* HA_template;
    char** lines;
    int nlines;
    int i;
    void* tmp;
    size_t n;
    void* tmp___0;
    const unsigned short **tmp___1;
    size_t n___0;
    void* tmp___2;
    const unsigned short **tmp___3;
    {
        HA_template = (char*)((void*)0);
        ss = (char*)s;
        nlines = 0;
        {
            while (1){
                while_continue:
                ;
                {
                    p = strstr((const char*)ss, "\\cr");
                }
                if (!p){
                    goto while_break;
                }
                nlines++;
                ss = p + 3;
            }
            while_break:
            ;
        }
        {
            nlines--;
            tmp = malloc((unsigned long )nlines * sizeof (char*));
            lines = (char**)tmp;
            p = strstr(s, "\\cr");
        }
        if (p){
            {
                n = (size_t)((p - (char*)s) + 1L);
                tmp___0 = malloc(n * sizeof (char));
                HA_template = (char*)tmp___0;
                my_strlcpy(HA_template, s, n);
                diagnostics(4, (char*)"HA_template = \'%s\'", HA_template);
            }
        }
        ss = p + 3;
        {
            while (1){
                while_continue___0:
                ;
                {
                    tmp___1 = __ctype_b_loc();
                }
                if (!((const int)*(*tmp___1 + (int)*ss) & 8192)){
                    goto while_break___0;
                }
                ss++;
            }
            while_break___0:
            ;
        }
        i = 0;
        {
            while (1){
                while_continue___1:
                ;
                if (!(i < nlines)){
                    goto while_break___1;
                }
                {
                    p = strstr((const char*)ss, "\\cr");
                }
                if (p){
                    {
                        n___0 = (size_t)((p - ss) + 1L);
                        tmp___2 = malloc(n___0 * sizeof (char));
                        *(lines + i) = (char*)tmp___2;
                        my_strlcpy(*(lines + i), (const char*)ss, n___0);
                        diagnostics(4, (char*)"line[%2d] = \'%s\'", i, *(lines + i));
                    }
                }
                ss = p + 3;
                {
                    while (1){
                        while_continue___2:
                        ;
                        {
                            tmp___3 = __ctype_b_loc();
                        }
                        if (!((const int)*(*tmp___3 + (int)*ss) & 8192)){
                            goto while_break___2;
                        }
                        ss++;
                    }
                    while_break___2:
                    ;
                }
                i++;
            }
            while_break___1:
            ;
        }
        *nl = nlines;
        *thelines = lines;
        *thetemplate = HA_template;
        return;
    }
}

static int HA_CountColumnsInHAlign(char** lines, int n)
{
    int i;
    int max_col;
    int col;
    char* s;
    {
        max_col = 0;
        i = 0;
        {
            while (1){
                while_continue:
                ;
                if (!(i < n)){
                    goto while_break;
                }
                col = 1;
                s = *(lines + i);
                {
                    while (1){
                        while_continue___0:
                        ;
                        {
                            s = NextAmpersand((const char*)s);
                        }
                        if (s){
                            if (!((int)*s != 0)){
                                goto while_break___0;
                            }
                        }else{
                            goto while_break___0;
                        }
                        col++;
                        s++;
                    }
                    while_break___0:
                    ;
                }
                {
                    diagnostics(5, (char*)"line[%d] has %d columns", i, col);
                }
                if (col > max_col){
                    max_col = col;
                }
                i++;
            }
            while_break:
            ;
        }
        return (max_col);
    }
}

static void HA_CountColumnsInTemplate(char* HA_template, int* ncol, int* nrepeat)
{
    char* s;
    int col;
    const unsigned short **tmp;
    {
        col = 1;
        *nrepeat = 999;
        s = HA_template;
        {
            while (1){
                while_continue:
                ;
                {
                    tmp = __ctype_b_loc();
                }
                if (!((const int)*(*tmp + (int)*s) & 8192)){
                    goto while_break;
                }
                s++;
            }
            while_break:
            ;
        }
        if ((int)*s == 38){
            *s = (char)' ';
            *nrepeat = 1;
            s++;
        }
        {
            while (1){
                while_continue___0:
                ;
                {
                    s = NextAmpersand((const char*)s);
                }
                if (s){
                    if (!((int)*s != 0)){
                        goto while_break___0;
                    }
                }else{
                    goto while_break___0;
                }
                s++;
                col++;
                if ((int)*s == 38){
                    *s = (char)' ';
                    *nrepeat = col;
                    s++;
                }
            }
            while_break___0:
            ;
        }
        {
            *ncol = col;
            diagnostics(5, (char*)"ncolumns = %d, nrepeat = %d", *ncol, *nrepeat);
        }
        return;
    }
}

static char* HA_GetCellTemplateN(const char* HA_template, int n, int tcols, int trepeat)
{
    char* s;
    char* next;
    char* cell;
    char* clean_cell;
    {
        if (n < 1){
            return ((char*)((void*)0));
        }
        if (n > trepeat){
            if (tcols == trepeat){
                n = trepeat;
            }else{
                n = trepeat + (n - trepeat) % ((tcols - trepeat) + 1);
            }
        }
        {
            s = (char*)HA_template;
            TabularGetCell((const char*)s, &cell, &next);
            n--;
        }
        {
            while (1){
                while_continue:
                ;
                if (!n){
                    goto while_break;
                }
                {
                    free((void*)cell);
                    s = next;
                    TabularGetCell((const char*)s, &cell, &next);
                    n--;
                }
            }
            while_break:
            ;
        }
        {
            clean_cell = strdup_noendblanks((const char*)cell);
            free((void*)cell);
        }
        return (clean_cell);
    }
}

static char* HA_GetCellN(const char* line, int n)
{
    char* s;
    char* next;
    char* cell;
    int i;
    char* x;
    char* tmp;
    {
        s = (char*)line;
        i = 1;
        {
            while (1){
                while_continue:
                ;
                if (!(i <= n)){
                    goto while_break;
                }
                {
                    TabularGetCell((const char*)s, &cell, &next);
                }
                if (i == n){
                    {
                        tmp = strdup_noendblanks((const char*)cell);
                        x = tmp;
                        free((void*)cell);
                    }
                    return (x);
                }
                {
                    free((void*)cell);
                    s = next;
                    i++;
                }
            }
            while_break:
            ;
        }
        return ((char*)((void*)0));
    }
}

static char* HA_ExpandCellWithTemplate(const char* HA_template, const char* cell)
{
    char buffer___0[500];
    char* s;
    char* t;
    char* b;
    char* text;
    {
        {
            t = (char*)HA_template;
            b = buffer___0;
            s = strstr(cell, "\\omit");
        }
        if ((unsigned long )s != (unsigned long )((char*)0)){
            {
                text = strdup((const char*)(s + 5));
            }
            return (text);
        }
        {
            while (1){
                while_continue:
                ;
                if (!((int)*t != 0)){
                    goto while_break;
                }
                if ((int)*t != 35){
                    *b = *t;
                    b++;
                }else{
                    s = (char*)cell;
                    {
                        while (1){
                            while_continue___0:
                            ;
                            if (!*s){
                                goto while_break___0;
                            }
                            *b = *s;
                            b++;
                            s++;
                        }
                        while_break___0:
                        ;
                    }
                }
                t++;
            }
            while_break:
            ;
        }
        {
            *b = (char)'\000';
            text = strdup((const char*)(buffer___0));
        }
        return (text);
    }
}

static char* HA_AlignFromTemplate(const char* HA_template, int ncols, int tcols, int trepeat)
{
    char* s;
    char* cell;
    char* align;
    int i;
    void* tmp;
    const unsigned short **tmp___0;
    char* tmp___1;
    int tmp___2;
    {
        {
            tmp = malloc((unsigned long )(ncols + 2) * sizeof (char));
            align = (char*)tmp;
            *(align + 0) = (char)'*';
            *(align + (ncols + 1)) = (char)'\000';
            i = 1;
        }
        {
            while (1){
                while_continue:
                ;
                if (!(i <= ncols)){
                    goto while_break;
                }
                {
                    cell = HA_GetCellTemplateN(HA_template, i, tcols, trepeat);
                    *(align + i) = (char)'l';
                    s = cell;
                }
                {
                    while (1){
                        while_continue___0:
                        ;
                        {
                            tmp___0 = __ctype_b_loc();
                        }
                        if (!((const int)*(*tmp___0 + (int)*s) & 8192)){
                            goto while_break___0;
                        }
                        s++;
                    }
                    while_break___0:
                    ;
                }
                {
                    tmp___2 = strncmp((const char*)s, "\\hfil", (size_t)5);
                }
                if (tmp___2 == 0){
                    {
                        tmp___1 = strstr((const char*)(s + 5), "\\hfil");
                    }
                    if ((unsigned long )tmp___1 != (unsigned long )((void*)0)){
                        *(align + i) = (char)'c';
                    }else{
                        *(align + i) = (char)'r';
                    }
                }
                {
                    free((void*)cell);
                    i++;
                }
            }
            while_break:
            ;
        }
        return (align);
    }
}

static void HA_CleanTemplate(char* HA_template)
{
    char* s;
    char* tmp;
    char* tmp___0;
    char* tmp___1;
    char* tmp___2;
    char* tmp___3;
    char* tmp___4;
    char* tmp___5;
    char* tmp___6;
    char* tmp___7;
    char* tmp___8;
    char* tmp___9;
    char* tmp___10;
    char* tmp___11;
    char* tmp___12;
    char* tmp___13;
    char* tmp___14;
    char* tmp___15;
    char* tmp___16;
    char* tmp___17;
    char* tmp___18;
    char* tmp___19;
    char* tmp___20;
    {
        s = HA_template;
        {
            while (1){
                while_continue:
                ;
                {
                    s = strstr((const char*)s, "\\hfill");
                }
                if (!s){
                    goto while_break;
                }
                tmp = s;
                s++;
                *tmp = (char)' ';
                tmp___0 = s;
                s++;
                *tmp___0 = (char)' ';
                tmp___1 = s;
                s++;
                *tmp___1 = (char)' ';
                tmp___2 = s;
                s++;
                *tmp___2 = (char)' ';
                tmp___3 = s;
                s++;
                *tmp___3 = (char)' ';
                tmp___4 = s;
                s++;
                *tmp___4 = (char)' ';
            }
            while_break:
            ;
        }
        s = HA_template;
        {
            while (1){
                while_continue___0:
                ;
                {
                    s = strstr((const char*)s, "\\hfil");
                }
                if (!s){
                    goto while_break___0;
                }
                tmp___5 = s;
                s++;
                *tmp___5 = (char)' ';
                tmp___6 = s;
                s++;
                *tmp___6 = (char)' ';
                tmp___7 = s;
                s++;
                *tmp___7 = (char)' ';
                tmp___8 = s;
                s++;
                *tmp___8 = (char)' ';
                tmp___9 = s;
                s++;
                *tmp___9 = (char)' ';
            }
            while_break___0:
            ;
        }
        s = HA_template;
        {
            while (1){
                while_continue___1:
                ;
                {
                    s = strstr((const char*)s, "\\qquad");
                }
                if (!s){
                    goto while_break___1;
                }
                tmp___10 = s;
                s++;
                *tmp___10 = (char)' ';
                tmp___11 = s;
                s++;
                *tmp___11 = (char)' ';
                tmp___12 = s;
                s++;
                *tmp___12 = (char)' ';
                tmp___13 = s;
                s++;
                *tmp___13 = (char)' ';
                tmp___14 = s;
                s++;
                *tmp___14 = (char)' ';
                tmp___15 = s;
                s++;
                *tmp___15 = (char)' ';
            }
            while_break___1:
            ;
        }
        s = HA_template;
        {
            while (1){
                while_continue___2:
                ;
                {
                    s = strstr((const char*)s, "\\quad");
                }
                if (!s){
                    goto while_break___2;
                }
                tmp___16 = s;
                s++;
                *tmp___16 = (char)' ';
                tmp___17 = s;
                s++;
                *tmp___17 = (char)' ';
                tmp___18 = s;
                s++;
                *tmp___18 = (char)' ';
                tmp___19 = s;
                s++;
                *tmp___19 = (char)' ';
                tmp___20 = s;
                s++;
                *tmp___20 = (char)' ';
            }
            while_break___2:
            ;
        }
        {
            diagnostics(5, (char*)"template=\'%s\'", HA_template);
        }
        return;
    }
}

void CmdHAlign(int code)
{
    char* contents;
    char* HA_template;
    char* align;
    char** lines;
    int nlines;
    int ncols;
    int tcols;
    int trepeat;
    int i;
    int line;
    char* s;
    int tmp;
    char* cell;
    char* cell_template;
    char* cell_text;
    {
        {
            contents = getBraceParam();
            HA_ExtractTemplateAndLines((const char*)contents, &HA_template, &lines, &nlines);
            free((void*)contents);
            ncols = HA_CountColumnsInHAlign(lines, nlines);
            HA_CountColumnsInTemplate(HA_template, &tcols, &trepeat);
            align = HA_AlignFromTemplate((const char*)HA_template, ncols, tcols, trepeat);
            HA_CleanTemplate(HA_template);
            line = 0;
        }
        {
            while (1){
                while_continue:
                ;
                if (!(line < nlines)){
                    goto while_break;
                }
                {
                    s = *(lines + line);
                    fprintRTF((char*)"{\\trowd");
                    i = 1;
                }
                {
                    while (1){
                        while_continue___0:
                        ;
                        if (!(i <= ncols)){
                            goto while_break___0;
                        }
                        {
                            tmp = getLength((char*)"textwidth");
                            fprintRTF((char*)"\\cellx%d", (tmp * i) / ncols);
                            i++;
                        }
                    }
                    while_break___0:
                    ;
                }
                {
                    fprintRTF((char*)"\n");
                    i = 1;
                }
                {
                    while (1){
                        while_continue___1:
                        ;
                        if (!(i <= ncols)){
                            goto while_break___1;
                        }
                        {
                            cell = HA_GetCellN((const char*)s, i);
                            cell_template = HA_GetCellTemplateN((const char*)HA_template, i, tcols, trepeat);
                            cell_text = HA_ExpandCellWithTemplate((const char*)cell_template, (const char*)cell);
                            diagnostics(5, (char*)"line=%d, col=%d, align=%c, cell is \'%s\'", line + 1, i, (int)*(align + i), cell_text);
                            free((void*)cell);
                            free((void*)cell_template);
                            BeginCellRTF(*(align + i));
                            ConvertString((const char*)cell_text);
                            EndCellRTF();
                            free((void*)cell_text);
                            i++;
                        }
                    }
                    while_break___1:
                    ;
                }
                {
                    fprintRTF((char*)"\\row}\n");
                    free((void*)*(lines + line));
                    line++;
                }
            }
            while_break:
            ;
        }
        {
            free((void*)align);
            free((void*)lines);
            free((void*)HA_template);
        }
        return;
    }
}

void CmdNewEnvironment(int code);
void CmdToday(int code);
void Environment(int code);
void CmdSection(int code);
void CmdQuote(int code);
void CmdList(int code);
void CmdCounter(int code);
void CmdLength(int code);
void CmdCaption(int code);
void CmdVerb(int code);
void CmdVerbatim(int code);
void CmdVerse(int code);
void GermanPrint(int code);
void CmdIgnoreLet(int code);
void CmdIgnoreDef(int code);
void CmdItem(int code);
void CmdMinipage(int code);
void CmdIgnoreEnviron(int code);
void CmdFigure(int code);
void CmdSubFigure(int code);
void Cmd_OptParam_Without_braces(int code);
void CmdColumn(int code);
void CmdBottom(int code);
void CmdKeywords(int code);
void CmdAcknowledgments(int code);
void CmdTitlepage(int code);
void CmdLink(int code);
void CmdTextColor(int code);
void CmdQuad(int kk);
void CmdColsep(int code);
void CmdVerbosityLevel(int code);
void CmdNewTheorem(int code);
void CmdEndInput(int code);
void CmdIf(int code);
void CmdKern(int code);
void CmdResizeBox(int code);
void CmdTextFont(int code);
void CmdThe(int code);
void CmdRule(int code);
void CmdTolerateEnviron(int code);
void CmdIflatextortf(int code);
void CmdNewif(int code);
void CmdElse(int code);
void CmdFi(int code);
void CmdAppendix(int code);
void CmdLap(int code);
void CmdBeginEnd(int code);
char* roman_item(int n, int upper);
static int g_chapter_numbering = 0;
static int g_section_numbering = 0;
static int g_appendix = 0;
int g_processing_list_environment = 0;

void CmdNewDef(int code)
{
    char* name;
    char* opt_param;
    char* def;
    char cThis;
    char* params___0;
    int param;
    const unsigned short **tmp;
    const char* tmp___0;
    const char* tmp___1;
    const char* tmp___2;
    {
        name = (char*)((void*)0);
        opt_param = (char*)((void*)0);
        def = (char*)((void*)0);
        params___0 = (char*)((void*)0);
        param = 0;
        if (code == 3){
            {
                name = getSimpleCommand();
            }
            if ((unsigned long )name == (unsigned long )((void*)0)){
                {
                    diagnostics(1, (char*)"Definition does not start with \'\\\' skipping");
                }
                return;
            }
            {
                while (1){
                    while_continue:
                    ;
                    {
                        cThis = getTexChar();
                    }
                    if (cThis){
                        if (!((int)cThis != 123)){
                            goto while_break;
                        }
                    }else{
                        goto while_break;
                    }
                    {
                        tmp = __ctype_b_loc();
                    }
                    if ((const int)*(*tmp + (int)cThis) & 2048){
                        param++;
                    }
                }
                while_break:
                ;
            }
            {
                ungetTexChar((char)'{');
                opt_param = (char*)((void*)0);
                def = getBraceParam();
                UpdateLineNumber(def);
                newDefinition(name + 1, opt_param, def, param);
            }
        }
        if (code == 1){
            goto _L;
        }else
            if (code == 2){
                _L:
                {
                    name = getBraceParam();
                    params___0 = getBracketParam();
                    opt_param = getBracketParam();
                    def = getBraceParam();
                    UpdateLineNumber(name);
                    UpdateLineNumber(params___0);
                }
                if (opt_param){
                    {
                        UpdateLineNumber(opt_param);
                    }
                }
                {
                    UpdateLineNumber(def);
                    param = 0;
                }
                if (params___0){
                    if (48 <= (int)*params___0){
                        if ((int)*params___0 <= 57){
                            param = (int)*params___0 - 48;
                        }else{
                            {
                                diagnostics(0, (char*)"non-numeric number of parameters in newcommand");
                            }
                        }
                    }else{
                        {
                            diagnostics(0, (char*)"non-numeric number of parameters in newcommand");
                        }
                    }
                }
                if (code == 1){
                    {
                        newDefinition(name + 1, opt_param, def, param);
                    }
                }else{
                    {
                        renewDefinition(name + 1, opt_param, def, param);
                    }
                }
            }

        if (def){
            tmp___0 = (const char*)def;
        }else{
            tmp___0 = "";
        }
        if (opt_param){
            tmp___1 = (const char*)opt_param;
        }else{
            tmp___1 = "";
        }
        if (name){
            tmp___2 = (const char*)name;
        }else{
            tmp___2 = "";
        }
        {
            diagnostics(4, (char*)"CmdNewDef name=<%s> param=%d opt_param=<%s> def=<%s>", tmp___2, param, tmp___1, tmp___0);
            free((void*)name);
            free((void*)def);
        }
        if (params___0){
            {
                free((void*)params___0);
            }
        }
        if (opt_param){
            {
                free((void*)opt_param);
            }
        }
        return;
    }
}

void CmdNewEnvironment(int code)
{
    char* name;
    char* opt_param;
    char* begdef;
    char* enddef;
    char* params___0;
    int param;
    {
        {
            name = getBraceParam();
            params___0 = getBracketParam();
            opt_param = getBracketParam();
            begdef = getBraceParam();
            enddef = getBraceParam();
            UpdateLineNumber(name);
            UpdateLineNumber(params___0);
        }
        if (opt_param){
            {
                UpdateLineNumber(opt_param);
            }
        }
        {
            UpdateLineNumber(begdef);
            UpdateLineNumber(enddef);
            param = 0;
        }
        if (params___0){
            if (48 <= (int)*params___0){
                if ((int)*params___0 <= 57){
                    param = (int)*params___0 - 48;
                }else{
                    {
                        diagnostics(0, (char*)"non-numeric number of parameters in newcommand");
                    }
                }
            }else{
                {
                    diagnostics(0, (char*)"non-numeric number of parameters in newcommand");
                }
            }
        }
        {
            diagnostics(2, (char*)"CmdNewEnvironment name=<%s> param=%d", name, param);
            diagnostics(2, (char*)"CmdNewEnvironment begdef=<%s>", begdef);
            diagnostics(2, (char*)"CmdNewEnvironment enddef=<%s>", enddef);
        }
        if (code == 1){
            {
                newEnvironment(name, opt_param, begdef, enddef, param);
            }
        }else{
            {
                renewEnvironment(name, opt_param, begdef, enddef, param);
            }
        }
        if (opt_param){
            {
                free((void*)opt_param);
            }
        }
        {
            free((void*)name);
            free((void*)begdef);
            free((void*)enddef);
        }
        if (params___0){
            {
                free((void*)params___0);
            }
        }
        return;
    }
}

void CmdNewTheorem(int code)
{
    char* name;
    char* caption;
    char* numbered_like;
    char* within;
    const char* tmp;
    {
        {
            name = getBraceParam();
            numbered_like = getBracketParam();
            caption = getBraceParam();
            within = getBracketParam();
            UpdateLineNumber(name);
            UpdateLineNumber(numbered_like);
            UpdateLineNumber(caption);
            UpdateLineNumber(within);
            diagnostics(2, (char*)"CmdNewTheorem name=<%s>", name);
            diagnostics(2, (char*)"CmdNewTheorem caption=<%s>", caption);
        }
        if (numbered_like){
            tmp = (const char*)numbered_like;
        }else{
            tmp = "";
        }
        {
            diagnostics(2, (char*)"CmdNewTheorem like=<%s>", tmp);
            newTheorem(name, caption, numbered_like, within);
            free((void*)name);
            free((void*)caption);
        }
        if (numbered_like){
            {
                free((void*)numbered_like);
            }
        }
        if (within){
            {
                free((void*)within);
            }
        }
        return;
    }
}

void CmdBeginEnd(int code)
{
    int i;
    char* str;
    char* option;
    char* s;
    char* tmp;
    int tmp___0;
    int tmp___1;
    {
        {
            tmp = getBraceParam();
            s = tmp;
        }
        if (code == 1){
            {
                diagnostics(5, (char*)"\\begin{%s}", s);
            }
        }else{
            {
                diagnostics(5, (char*)"\\end{%s}", s);
            }
        }
        {
            tmp___0 = strcmp((const char*)s, "document");
        }
        if (tmp___0 == 0){
            {
                free((void*)s);
                EndSource();
            }
            return;
        }
        {
            tmp___1 = strcmp((const char*)s, "multicols");
        }
        if (tmp___1 == 0){
            {
                free((void*)s);
            }
            return;
        }
        {
            i = existsEnvironment(s);
        }
        if (i > -1){
            {
                diagnostics(1, (char*)"starting user-defined environment \'%s\'", s);
                str = expandEnvironment(i, code);
                ConvertString((const char*)str);
                free((void*)str);
                free((void*)s);
            }
            return;
        }
        {
            i = existsTheorem(s);
        }
        if (i > -1){
            if (code == 1){
                {
                    option = getBracketParam();
                    str = expandTheorem(i, option);
                    CmdEndParagraph(0);
                    CmdVspace(1);
                    startParagraph("theorem", 1);
                    fprintRTF((char*)"{\\b %s} {\\i ", str);
                    PushBrace();
                }
                if (option){
                    {
                        free((void*)option);
                    }
                }
                {
                    free((void*)str);
                }
            }else{
                {
                    PopBrace();
                    fprintRTF((char*)"}");
                    CmdEndParagraph(0);
                    CmdVspace(1);
                    CmdIndent(2);
                }
            }
            {
                free((void*)s);
            }
            return;
        }
        if (code == 1){
            {
                diagnostics(5, (char*)"\\begin{%s}", s);
                CallParamFunc(s, 16384);
            }
        }else{
            {
                diagnostics(5, (char*)"\\end{%s}", s);
                CallParamFunc(s, 0);
                CmdIndent(2);
            }
        }
        {
            free((void*)s);
        }
        return;
    }
}

void CmdToday(int code)
{
    int tmp;
    {
        {
            tmp = getTexMode();
        }
        if (tmp == 6){
            {
                changeTexMode(2);
            }
        }
        {
            fprintRTF((char*)"\\chdate ");
        }
        return;
    }
}

void CmdIgnore(int code)
{
    {
        return;
    }
}

void Environment(int code)
{
    {
        if (code & 16384){
            {
                code &= -16385;
                diagnostics(4, (char*)"Entering Environment (%d)", code);
                PushEnvironment(15);
            }
        }else{
            {
                CmdEndParagraph(0);
                diagnostics(4, (char*)"Exiting  Environment (%d)", code);
                PopEnvironment();
            }
        }
        return;
    }
}

static char* FormatNumber(int formatting, int n)
{
    char label[20];
    char* tmp;
    char* tmp___0;
    {
        {
            if (formatting == 1){
                goto case_1;
            }
            if (formatting == 0){
                goto case_0;
            }
            if (formatting == 2){
                goto case_2;
            }
            goto switch_break;
            case_1:
            {
                snprintf((char*)(label), (size_t)20, (const char*)"%c", (int)((char)((n + 65) - 1)));
            }
            goto switch_break;
            case_0:
            {
                snprintf((char*)(label), (size_t)20, (const char*)"%d", n);
            }
            goto switch_break;
            case_2:
            {
                tmp = roman_item(n, 1);
            }
            return (tmp);
            switch_break:
            ;
        }
        {
            tmp___0 = strdup((const char*)(label));
        }
        return (tmp___0);
    }
}

static char* FormatSection(void)
{
    int tmp;
    char* tmp___0;
    {
        {
            tmp = getCounter((char*)"section");
            tmp___0 = FormatNumber(g_section_numbering, tmp);
        }
        return (tmp___0);
    }
}

static char* FormatChapter(void)
{
    int tmp;
    char* tmp___0;
    {
        {
            tmp = getCounter((char*)"chapter");
            tmp___0 = FormatNumber(g_chapter_numbering, tmp);
        }
        return (tmp___0);
    }
}

char* FormatUnitNumber(char* name)
{
    char label[20];
    char* s;
    char* tmp;
    int tmp___0;
    char* tmp___1;
    int tmp___2;
    char* tmp___3;
    int tmp___4;
    char* tmp___5;
    int tmp___6;
    int tmp___7;
    int tmp___8;
    int tmp___9;
    int tmp___10;
    int tmp___11;
    int tmp___12;
    int tmp___13;
    int tmp___14;
    int tmp___15;
    int tmp___16;
    int tmp___17;
    int tmp___18;
    int tmp___19;
    int tmp___20;
    int tmp___21;
    int tmp___22;
    int tmp___23;
    int tmp___24;
    int tmp___25;
    int tmp___26;
    int tmp___27;
    int tmp___28;
    int tmp___29;
    int tmp___30;
    int tmp___31;
    int tmp___32;
    int tmp___33;
    int tmp___34;
    int tmp___35;
    char* tmp___36;
    {
        s = (char*)((void*)0);
        if (g_document_type == 6){
            {
                tmp = strdup("");
            }
            return (tmp);
        }
        {
            label[0] = (char)'\000';
            tmp___2 = strcmp((const char*)name, "part");
        }
        if (tmp___2 == 0){
            {
                tmp___0 = getCounter(name);
                tmp___1 = roman_item(tmp___0, 1);
            }
            return (tmp___1);
        }
        {
            tmp___4 = strcmp((const char*)name, "chapter");
        }
        if (tmp___4 == 0){
            {
                tmp___3 = FormatChapter();
            }
            return (tmp___3);
        }
        {
            tmp___35 = strcmp((const char*)name, "section");
        }
        if (tmp___35 == 0){
            if (g_document_type == 1){
                {
                    tmp___5 = FormatSection();
                }
                return (tmp___5);
            }else{
                {
                    s = FormatChapter();
                    tmp___6 = getCounter((char*)"section");
                    snprintf((char*)(label), (size_t)20, (const char*)"%s.%d", s, tmp___6);
                }
            }
        }else{
            {
                tmp___34 = strcmp((const char*)name, "subsection");
            }
            if (tmp___34 == 0){
                if (g_document_type == 1){
                    {
                        s = FormatSection();
                        tmp___7 = getCounter((char*)"subsection");
                        snprintf((char*)(label), (size_t)20, (const char*)"%s.%d", s, tmp___7);
                    }
                }else{
                    {
                        s = FormatChapter();
                        tmp___8 = getCounter((char*)"subsection");
                        tmp___9 = getCounter((char*)"section");
                        snprintf((char*)(label), (size_t)20, (const char*)"%s.%d.%d", s, tmp___9, tmp___8);
                    }
                }
            }else{
                {
                    tmp___33 = strcmp((const char*)name, "subsubsection");
                }
                if (tmp___33 == 0){
                    if (g_document_type == 1){
                        {
                            s = FormatSection();
                            tmp___10 = getCounter((char*)"subsubsection");
                            tmp___11 = getCounter((char*)"subsection");
                            snprintf((char*)(label), (size_t)20, (const char*)"%s.%d.%d", s, tmp___11, tmp___10);
                        }
                    }else{
                        {
                            s = FormatChapter();
                            tmp___12 = getCounter((char*)"subsubsection");
                            tmp___13 = getCounter((char*)"subsection");
                            tmp___14 = getCounter((char*)"section");
                            snprintf((char*)(label), (size_t)20, (const char*)"%s.%d.%d.%d", s, tmp___14, tmp___13, tmp___12);
                        }
                    }
                }else{
                    {
                        tmp___32 = strcmp((const char*)name, "paragraph");
                    }
                    if (tmp___32 == 0){
                        if (g_document_type == 1){
                            {
                                s = FormatSection();
                                tmp___15 = getCounter((char*)"paragraph");
                                tmp___16 = getCounter((char*)"subsubsection");
                                tmp___17 = getCounter((char*)"subsection");
                                snprintf((char*)(label), (size_t)20, (const char*)"%s.%d.%d.%d", s, tmp___17, tmp___16, tmp___15);
                            }
                        }else{
                            {
                                s = FormatChapter();
                                tmp___18 = getCounter((char*)"paragraph");
                                tmp___19 = getCounter((char*)"subsubsection");
                                tmp___20 = getCounter((char*)"subsection");
                                tmp___21 = getCounter((char*)"section");
                                snprintf((char*)(label), (size_t)20, (const char*)"%s.%d.%d.%d.%d", s, tmp___21, tmp___20, tmp___19, tmp___18);
                            }
                        }
                    }else{
                        {
                            tmp___31 = strcmp((const char*)name, "subparagraph");
                        }
                        if (tmp___31 == 0){
                            if (g_document_type == 1){
                                {
                                    s = FormatSection();
                                    tmp___22 = getCounter((char*)"subparagraph");
                                    tmp___23 = getCounter((char*)"paragraph");
                                    tmp___24 = getCounter((char*)"subsubsection");
                                    tmp___25 = getCounter((char*)"subsection");
                                    snprintf((char*)(label), (size_t)20, (const char*)"%s.%d.%d.%d.%d", s, tmp___25, tmp___24, tmp___23, tmp___22);
                                }
                            }else{
                                {
                                    s = FormatChapter();
                                    tmp___26 = getCounter((char*)"subparagraph");
                                    tmp___27 = getCounter((char*)"paragraph");
                                    tmp___28 = getCounter((char*)"subsubsection");
                                    tmp___29 = getCounter((char*)"subsection");
                                    tmp___30 = getCounter((char*)"section");
                                    snprintf((char*)(label), (size_t)20, (const char*)"%s.%d.%d.%d.%d.%d", s, tmp___30, tmp___29, tmp___28, tmp___27, tmp___26);
                                }
                            }
                        }
                    }
                }
            }
        }
        if (s){
            {
                free((void*)s);
            }
        }
        {
            tmp___36 = strdup((const char*)(label));
        }
        return (tmp___36);
    }
}

void CmdAppendix(int code)
{
    {
        g_chapter_numbering = 1;
        if (g_document_type == 1){
            g_section_numbering = 1;
        }
        {
            g_appendix = 1;
            setCounter((char*)"chapter", 0);
            setCounter((char*)"section", 0);
        }
        return;
    }
}

void CmdSection(int code)
{
    char* toc_entry;
    char* heading;
    char* unit_label;
    char* chapter_name;
    int tmp;
    int tmp___0;
    int tmp___1;
    int tmp___2;
    int tmp___3;
    int tmp___4;
    int tmp___5;
    int tmp___6;
    int tmp___7;
    {
        {
            chapter_name = (char*)((void*)0);
            toc_entry = getBracketParam();
            heading = getBraceParam();
        }
        if (toc_entry){
            {
                diagnostics(4, (char*)"entering CmdSection [%s]{%s}", toc_entry, heading);
                free((void*)toc_entry);
            }
        }else{
            {
                diagnostics(4, (char*)"entering CmdSection {%s}", heading);
            }
        }
        {
            CmdEndParagraph(0);
        }
        {
            if (code == 11){
                goto case_11;
            }
            if (code == 1){
                goto case_11;
            }
            if (code == 12){
                goto case_12;
            }
            if (code == 2){
                goto case_12;
            }
            if (code == 13){
                goto case_13;
            }
            if (code == 3){
                goto case_13;
            }
            if (code == 14){
                goto case_14;
            }
            if (code == 4){
                goto case_14;
            }
            if (code == 15){
                goto case_15;
            }
            if (code == 5){
                goto case_15;
            }
            if (code == 16){
                goto case_16;
            }
            if (code == 6){
                goto case_16;
            }
            if (code == 17){
                goto case_17;
            }
            if (code == 7){
                goto case_17;
            }
            goto switch_break;
            case_11:
            case_1:
            {
                tmp = getCounter((char*)"part");
            }
            if (tmp > 0){
                {
                    CmdNewPage(1);
                }
            }
            {
                startParagraph("part", 3);
                ConvertBabelName((char*)"PARTNAME");
            }
            if (code == 1){
                {
                    incrementCounter((char*)"part");
                    unit_label = FormatUnitNumber((char*)"part");
                    fprintRTF((char*)" %s\\par ", unit_label);
                    free((void*)unit_label);
                }
            }
            {
                ConvertString((const char*)heading);
                CmdEndParagraph(0);
                CmdNewPage(1);
            }
            goto switch_break;
            case_12:
            case_2:
            {
                unit_label = (char*)((void*)0);
                tmp___0 = getCounter((char*)"chapter");
            }
            if (tmp___0 > 0){
                {
                    CmdNewPage(1);
                }
            }
            {
                startParagraph("chapter0", 3);
            }
            if (g_appendix){
                {
                    chapter_name = GetBabelName((char*)"APPENDIXNAME");
                }
            }else{
                {
                    chapter_name = GetBabelName((char*)"CHAPTERNAME");
                }
            }
            {
                ConvertString((const char*)chapter_name);
            }
            if (code == 2){
                {
                    tmp___1 = getCounter((char*)"secnumdepth");
                }
                if (tmp___1 >= -1){
                    {
                        incrementCounter((char*)"chapter");
                        setCounter((char*)"section", 0);
                        setCounter((char*)"figure", 0);
                        setCounter((char*)"table", 0);
                        setCounter((char*)"equation", 0);
                        resetTheoremCounter((char*)"chapter");
                        unit_label = FormatUnitNumber((char*)"chapter");
                        fprintRTF((char*)" ");
                        InsertBookmark(g_section_label, unit_label);
                    }
                }
            }
            {
                CmdEndParagraph(0);
                CmdVspace(3);
                startParagraph("chapter", 3);
                ConvertString((const char*)heading);
                CmdEndParagraph(0);
                CmdVspace(3);
            }
            if (unit_label){
                {
                    free((void*)unit_label);
                }
            }
            goto switch_break;
            case_13:
            case_3:
            {
                CmdVspace(3);
            }
            if (g_document_type == 6){
                {
                    startParagraph("section", 3);
                }
            }else{
                {
                    startParagraph("section", 3);
                }
                if (code == 3){
                    {
                        tmp___2 = getCounter((char*)"secnumdepth");
                    }
                    if (tmp___2 >= 0){
                        {
                            incrementCounter((char*)"section");
                            setCounter((char*)"subsection", 0);
                            resetTheoremCounter((char*)"section");
                            unit_label = FormatUnitNumber((char*)"section");
                            InsertBookmark(g_section_label, unit_label);
                            fprintRTF((char*)"  ");
                            free((void*)unit_label);
                        }
                    }
                }
            }
            {
                ConvertString((const char*)heading);
                CmdEndParagraph(0);
                CmdVspace(1);
            }
            goto switch_break;
            case_14:
            case_4:
            {
                CmdVspace(2);
            }
            if (g_document_type == 6){
                {
                    startParagraph("subsection", 3);
                }
            }else{
                {
                    startParagraph("subsection", 3);
                }
                if (code == 4){
                    {
                        tmp___3 = getCounter((char*)"secnumdepth");
                    }
                    if (tmp___3 >= 1){
                        {
                            incrementCounter((char*)"subsection");
                            setCounter((char*)"subsubsection", 0);
                            resetTheoremCounter((char*)"subsection");
                            unit_label = FormatUnitNumber((char*)"subsection");
                            InsertBookmark(g_section_label, unit_label);
                            fprintRTF((char*)"  ");
                            free((void*)unit_label);
                        }
                    }
                }
            }
            {
                ConvertString((const char*)heading);
                CmdEndParagraph(0);
                CmdVspace(1);
            }
            goto switch_break;
            case_15:
            case_5:
            {
                CmdVspace(2);
            }
            if (g_document_type == 6){
                {
                    startParagraph("subsubsection", 2);
                    fprintRTF((char*)"{\\i ");
                    ConvertString((const char*)heading);
                    fprintRTF((char*)".} ");
                }
            }else{
                {
                    startParagraph("subsubsection", 3);
                }
                if (code == 5){
                    {
                        tmp___4 = getCounter((char*)"secnumdepth");
                    }
                    if (tmp___4 > 2){
                        goto _L;
                    }else
                        if (g_document_type == 1){
                            {
                                tmp___5 = getCounter((char*)"secnumdepth");
                            }
                            if (tmp___5 == 2){
                                _L:
                                {
                                    incrementCounter((char*)"subsubsection");
                                    setCounter((char*)"paragraph", 0);
                                    setCounter((char*)"subparagraph", 0);
                                    resetTheoremCounter((char*)"subsubsection");
                                    unit_label = FormatUnitNumber((char*)"subsubsection");
                                    InsertBookmark(g_section_label, unit_label);
                                    fprintRTF((char*)"  ");
                                    free((void*)unit_label);
                                }
                            }
                        }
                }
                {
                    ConvertString((const char*)heading);
                    CmdEndParagraph(0);
                    CmdVspace(1);
                }
            }
            goto switch_break;
            case_16:
            case_6:
            {
                CmdVspace(2);
                startParagraph("paragraph", 3);
            }
            if (code == 6){
                {
                    tmp___6 = getCounter((char*)"secnumdepth");
                }
                if (tmp___6 >= 3){
                    {
                        incrementCounter((char*)"paragraph");
                        resetTheoremCounter((char*)"paragraph");
                        unit_label = FormatUnitNumber((char*)"paragraph");
                        setCounter((char*)"subparagraph", 0);
                        InsertBookmark(g_section_label, unit_label);
                        fprintRTF((char*)"  ");
                        free((void*)unit_label);
                    }
                }
            }
            {
                ConvertString((const char*)heading);
                CmdEndParagraph(0);
                CmdVspace(1);
            }
            goto switch_break;
            case_17:
            case_7:
            {
                CmdVspace(2);
                startParagraph("subparagraph", 3);
            }
            if (code == 7){
                {
                    tmp___7 = getCounter((char*)"secnumdepth");
                }
                if (tmp___7 >= 4){
                    {
                        incrementCounter((char*)"subparagraph");
                        resetTheoremCounter((char*)"subparagraph");
                        unit_label = FormatUnitNumber((char*)"subparagraph");
                        InsertBookmark(g_section_label, unit_label);
                        fprintRTF((char*)"  ");
                        free((void*)unit_label);
                    }
                }
            }
            {
                ConvertString((const char*)heading);
                CmdEndParagraph(0);
                CmdVspace(1);
            }
            goto switch_break;
            switch_break:
            ;
        }
        if (heading){
            {
                free((void*)heading);
            }
        }
        if (g_section_label){
            {
                free((void*)g_section_label);
                g_section_label = (char*)((void*)0);
            }
        }
        return;
    }
}

void CmdCaption(int code)
{
    char* thecaption;
    char* lst_entry;
    int n;
    int vspace;
    char old_align;
    char number[20];
    char c;
    int tmp;
    int tmp___0;
    int tmp___1;
    int tmp___2;
    int tmp___3;
    {
        {
            tmp = getAlignment();
            old_align = (char)tmp;
            setAlignment('c');
            lst_entry = getBracketParam();
            thecaption = getBraceParam();
        }
        if (lst_entry){
            {
                diagnostics(4, (char*)"entering \\caption[%s]{}", lst_entry);
                show_string(4, (const char*)thecaption, "caption");
                free((void*)lst_entry);
            }
        }else{
            {
                diagnostics(4, (char*)"entering \\caption{}");
                show_string(4, (const char*)thecaption, "caption");
            }
        }
        {
            tmp___0 = getTexMode();
        }
        if (tmp___0 != 6){
            {
                CmdEndParagraph(0);
            }
        }
        {
            vspace = getLength((char*)"abovecaptionskip");
            setVspace(vspace);
            startParagraph("caption", 1);
            fprintRTF((char*)"{");
        }
        if (g_processing_figure){
            {
                incrementCounter((char*)"figure");
                ConvertBabelName((char*)"FIGURENAME");
                fprintRTF((char*)" ");
                n = getCounter((char*)"figure");
                c = (char)'f';
            }
        }else{
            {
                incrementCounter((char*)"table");
                ConvertBabelName((char*)"TABLENAME");
                fprintRTF((char*)" ");
                n = getCounter((char*)"table");
                c = (char)'t';
            }
        }
        if (g_document_type != 1){
            if (g_document_type != 6){
                {
                    tmp___1 = getCounter((char*)"chapter");
                    snprintf((char*)(number), (size_t)20, (const char*)"%d.%d", tmp___1, n);
                }
            }else{
                {
                    snprintf((char*)(number), (size_t)20, (const char*)"%d", n);
                }
            }
        }else{
            {
                snprintf((char*)(number), (size_t)20, (const char*)"%d", n);
            }
        }
        if (g_processing_figure){
            if (g_figure_label){
                {
                    InsertBookmark(g_figure_label, number);
                }
            }else{
                goto _L;
            }
        }else
            _L:
            if (g_processing_table){
                if (g_table_label){
                    {
                        InsertBookmark(g_table_label, number);
                    }
                }else{
                    {
                        fprintRTF((char*)"%s", number);
                    }
                }
            }else{
                {
                    fprintRTF((char*)"%s", number);
                }
            }

        {
            fprintRTF((char*)": ");
            ConvertString((const char*)thecaption);
            fprintRTF((char*)"}");
            InsertContentMark(c, number, (char*)"  ", thecaption);
            free((void*)thecaption);
            CmdEndParagraph(0);
            tmp___2 = getLength((char*)"belowcaptionskip");
            tmp___3 = getLength((char*)"textfloatsep");
            vspace = tmp___2 + tmp___3;
            setVspace(vspace);
            setAlignment((int)old_align);
            diagnostics(4, (char*)"exiting CmdCaption");
        }
        return;
    }
}

void CmdCounter(int code)
{
    char* s;
    char* s2;
    char* s3;
    char* s4;
    int num;
    int tmp;
    int tmp___0;
    {
        {
            s = getBraceParam();
            diagnostics(4, (char*)"Entering CmdCounter(), <%s>", s);
        }
        if (code == 3){
            goto _L___0;
        }else
            if (code == 2){
                _L___0:
                {
                    s2 = getBraceParam();
                    s3 = strchr((const char*)s2, '{');
                }
                if (s3){
                    {
                        s4 = strchr((const char*)s2, '}');
                    }
                    if (s4){
                        {
                            s3++;
                            *s4 = (char)'\000';
                            diagnostics(4, (char*)"CmdCounter() processing \\value{%s}", s3);
                            num = getCounter(s3);
                        }
                    }else{
                        goto _L;
                    }
                }else{
                    _L:
                    {
                        tmp = sscanf((const char*)s2, (const char*)"%d", &num);
                    }
                    if (tmp != 1){
                        {
                            diagnostics(1, (char*)"\nBad parameter in set/addcounter{%s}{%s}", s, s2);
                            free((void*)s2);
                            free((void*)s);
                        }
                        return;
                    }
                }
                {
                    free((void*)s2);
                }
                if (code == 3){
                    {
                        tmp___0 = getCounter(s);
                        setCounter(s, tmp___0 + num);
                    }
                }else{
                    {
                        setCounter(s, num);
                    }
                }
            }else
                if (code == 1){
                    {
                        setCounter(s, 0);
                    }
                }

        {
            free((void*)s);
        }
        return;
    }
}

void CmdLength(int code)
{
    char* s;
    char* s1;
    char cThis;
    int num;
    size_t tmp;
    int tmp___0;
    {
        if (code == 3){
            goto _L___0;
        }else
            if (code == 2){
                goto _L___0;
            }else
                if (code == 1){
                    _L___0:
                    {
                        s = getBraceParam();
                        tmp = strlen((const char*)s);
                    }
                    if (tmp <= 1UL){
                        {
                            free((void*)s);
                            diagnostics(1, (char*)"missing argument in \\newlength \\addtolength or \\setlength");
                        }
                        return;
                    }
                    {
                        s1 = s + 1;
                        diagnostics(4, (char*)"Entering CmdLength(), <%s>", s1);
                    }
                    if (code == 3){
                        goto _L;
                    }else
                        if (code == 2){
                            _L:
                            {
                                cThis = getNonSpace();
                            }
                            if ((int)cThis == 123){
                                {
                                    num = getDimension();
                                    diagnostics(4, (char*)"size is <%d> twips", num);
                                    cThis = getTexChar();
                                }
                                {
                                    while (1){
                                        while_continue:
                                        ;
                                        if (cThis){
                                            if (!((int)cThis != 125)){
                                                goto while_break;
                                            }
                                        }else{
                                            goto while_break;
                                        }
                                        {
                                            cThis = getTexChar();
                                        }
                                    }
                                    while_break:
                                    ;
                                }
                                if (code == 3){
                                    {
                                        tmp___0 = getLength(s1);
                                        setLength(s1, tmp___0 + num);
                                    }
                                }else{
                                    {
                                        setLength(s1, num);
                                    }
                                }
                            }else{
                                {
                                    diagnostics(1, (char*)"bad parameter to \\addtolength or \\setlength");
                                }
                            }
                        }else{
                            {
                                setLength(s1, 0);
                            }
                        }

                    {
                        free((void*)s);
                    }
                }else{
                    {
                        skipSpaces();
                        cThis = getTexChar();
                    }
                    if ((int)cThis == 61){
                        {
                            skipSpaces();
                        }
                    }else{
                        {
                            ungetTexChar(cThis);
                        }
                    }
                    {
                        getDimension();
                    }
                }

        return;
    }
}

void CmdQuote(int code)
{
    int true_code;
    int tmp;
    int tmp___0;
    int tmp___1;
    int tmp___2;
    {
        {
            true_code = code & -16385;
            CmdEndParagraph(0);
        }
        if (code & 16384){
            if (true_code == 2){
                {
                    PushEnvironment(23);
                    diagnostics(4, (char*)"Entering \\begin{quotation}");
                    CmdVspace(1);
                    tmp = getLeftMarginIndent();
                    setLeftMarginIndent(tmp + 512);
                    tmp___0 = getRightMarginIndent();
                    setRightMarginIndent(tmp___0 + 512);
                    startParagraph("quote", 3);
                }
            }else{
                {
                    PushEnvironment(24);
                    diagnostics(4, (char*)"Entering \\begin{quote}");
                    CmdVspace(1);
                    tmp___1 = getLeftMarginIndent();
                    setLeftMarginIndent(tmp___1 + 512);
                    tmp___2 = getRightMarginIndent();
                    setRightMarginIndent(tmp___2 + 512);
                    setLength((char*)"parindent", 0);
                    startParagraph("quote", 3);
                }
            }
        }else{
            {
                PopEnvironment();
                diagnostics(4, (char*)"Exiting \\end{quote} or \\end{quotation}");
                CmdIndent(2);
                CmdVspace(1);
            }
        }
        return;
    }
}

void CmdList(int code)
{
    int vspace;
    int amount;
    int tmp;
    int tmp___0;
    int tmp___1;
    int tmp___2;
    int tmp___3;
    int tmp___4;
    int tmp___5;
    {
        {
            amount = 300;
            tmp = getLength((char*)"topsep");
            tmp___0 = getLength((char*)"parskip");
            vspace = tmp + tmp___0;
        }
        if (code != 16390){
            if (code != 6){
                {
                    tmp___2 = getTexMode();
                }
                if (tmp___2 == 6){
                    {
                        tmp___1 = getLength((char*)"partopsep");
                        vspace += tmp___1;
                    }
                }else{
                    {
                        CmdEndParagraph(0);
                    }
                }
            }
        }
        {
            if (code == 16387){
                goto case_16387;
            }
            if (code == 16388){
                goto case_16388;
            }
            if (code == 16389){
                goto case_16389;
            }
            if (code == 16390){
                goto case_16390;
            }
            if (code == 6){
                goto case_6;
            }
            if (code == 4){
                goto case_4;
            }
            if (code == 5){
                goto case_5;
            }
            if (code == 3){
                goto case_5;
            }
            goto switch_break;
            case_16387:
            {
                setVspace(vspace);
                PushEnvironment(3);
                setLength((char*)"parindent", -amount);
                tmp___3 = getLeftMarginIndent();
                setLeftMarginIndent(tmp___3 + 2 * amount);
                CmdIndent(3);
            }
            goto switch_break;
            case_16388:
            {
                setVspace(vspace);
                PushEnvironment(4);
                g_enumerate_depth++;
                CmdItem(0);
                setLength((char*)"parindent", -amount);
                tmp___4 = getLeftMarginIndent();
                setLeftMarginIndent(tmp___4 + 2 * amount);
                CmdIndent(3);
            }
            goto switch_break;
            case_16389:
            {
                setVspace(vspace);
                PushEnvironment(5);
                setLength((char*)"parindent", -amount);
                tmp___5 = getLeftMarginIndent();
                setLeftMarginIndent(tmp___5 + 2 * amount);
                CmdIndent(3);
            }
            goto switch_break;
            case_16390:
            {
                PushEnvironment(6);
                g_enumerate_depth++;
                CmdItem(0);
            }
            goto switch_break;
            case_6:
            {
                g_enumerate_depth--;
                PopEnvironment();
                g_processing_list_environment = 0;
            }
            goto switch_break;
            case_4:
            g_enumerate_depth--;
            case_5:
            case_3:
            {
                PopEnvironment();
                CmdIndent(3);
                g_processing_list_environment = 0;
                setVspace(vspace);
            }
            goto switch_break;
            switch_break:
            ;
        }
        return;
    }
}

static int item_number[5];

void CmdItem(int code)
{
    char* itemlabel;
    char thechar;
    int vspace;
    const char* tmp;
    const char* tmp___0;
    const char* tmp___1;
    const char* tmp___2;
    int tmp___3;
    int tmp___4;
    char* tmp___5;
    {
        if (code == 0){
            if (g_enumerate_depth < 4){
                item_number[g_enumerate_depth] = 1;
            }
            return;
        }
        if (code == 4){
            tmp___2 = "enumerate";
        }else{
            if (code == 3){
                tmp___1 = "itemize";
            }else{
                if (code == 5){
                    tmp___0 = "description";
                }else{
                    if (code == 6){
                        tmp = "inparaenum";
                    }else{
                        tmp = "not enum";
                    }
                    tmp___0 = tmp;
                }
                tmp___1 = tmp___0;
            }
            tmp___2 = tmp___1;
        }
        {
            diagnostics(4, (char*)" CmdItem depth=%d #=%d (%s)", g_enumerate_depth, item_number[g_enumerate_depth], tmp___2);
            g_processing_list_environment = 1;
        }
        if (code != 6){
            {
                CmdEndParagraph(0);
                tmp___3 = getLength((char*)"itemsep");
                tmp___4 = getLength((char*)"parsep");
                vspace = tmp___3 + tmp___4;
                setVspace(vspace);
                CmdIndent(3);
                startParagraph("item", 1);
            }
        }
        {
            itemlabel = getBracketParam();
        }
        if (itemlabel){
            {
                fprintRTF((char*)"{");
            }
            if (code == 5){
                {
                    fprintRTF((char*)"\\b ");
                }
            }
            {
                diagnostics(5, (char*)"Entering ConvertString from CmdItem");
                ConvertString((const char*)itemlabel);
                diagnostics(5, (char*)"Exiting ConvertString from CmdItem");
                fprintRTF((char*)"}");
            }
            if (code != 5){
                if (code != 6){
                    {
                        fprintRTF((char*)"\\tab\n");
                    }
                }
            }
        }
        {
            if (code == 3){
                goto case_3;
            }
            if (code == 4){
                goto case_4;
            }
            if (code == 6){
                goto case_4;
            }
            if (code == 5){
                goto case_5;
            }
            goto switch_break;
            case_3:
            if (!itemlabel){
                if (FrenchMode){
                    {
                        fprintRTF((char*)"\\endash\\tab\n");
                    }
                }else{
                    {
                        fprintRTF((char*)"\\bullet\\tab\n");
                    }
                }
            }
            goto switch_break;
            case_4:
            case_6:
            if (itemlabel){
                goto switch_break;
            }
            {
                if (g_enumerate_depth == 1){
                    goto case_1;
                }
                if (g_enumerate_depth == 2){
                    goto case_2;
                }
                if (g_enumerate_depth == 3){
                    goto case_3___0;
                }
                if (g_enumerate_depth == 4){
                    goto case_4___0;
                }
                goto switch_default;
                case_1:
                {
                    fprintRTF((char*)"%d.", item_number[g_enumerate_depth]);
                }
                goto switch_break___0;
                case_2:
                {
                    fprintRTF((char*)"(%c)", (97 + item_number[g_enumerate_depth]) - 1);
                }
                goto switch_break___0;
                case_3___0:
                {
                    tmp___5 = roman_item(item_number[g_enumerate_depth], 0);
                    fprintRTF((char*)"%s.", tmp___5);
                }
                goto switch_break___0;
                case_4___0:
                {
                    fprintRTF((char*)"%c.", (65 + item_number[g_enumerate_depth]) - 1);
                }
                goto switch_break___0;
                switch_default:
                goto switch_break___0;
                switch_break___0:
                ;
            }
            if (code != 6){
                {
                    fprintRTF((char*)"\\tab\n");
                }
            }else{
                {
                    fprintRTF((char*)" ");
                }
            }
            (item_number[g_enumerate_depth])++;
            goto switch_break;
            case_5:
            {
                fprintRTF((char*)" ");
            }
            goto switch_break;
            switch_break:
            ;
        }
        if (itemlabel){
            {
                free((void*)itemlabel);
            }
        }
        {
            thechar = getNonBlank();
            ungetTexChar(thechar);
        }
        if (code != 6){
            {
                CmdIndent(1);
            }
        }
        return;
    }
}

void CmdResizeBox(int code)
{
    char* size;
    char* options;
    char* content;
    {
        {
            size = getBraceParam();
            options = getBraceParam();
            content = getBraceParam();
            free((void*)size);
            free((void*)options);
            ConvertString((const char*)content);
            free((void*)content);
        }
        return;
    }
}

void CmdBox(int code)
{
    char BoxName[7][10];
    unsigned int tmp;
    unsigned int tmp___0;
    unsigned int tmp___1;
    unsigned int tmp___2;
    unsigned int tmp___3;
    unsigned int tmp___4;
    unsigned int tmp___5;
    int mode;
    int tmp___6;
    char* position;
    char* width;
    char* position___0;
    char* width___0;
    {
        BoxName[0][0] = (char)'h';
        BoxName[0][1] = (char)'b';
        BoxName[0][2] = (char)'o';
        BoxName[0][3] = (char)'x';
        BoxName[0][4] = (char)'\000';
        tmp = 5U;
        {
            while (1){
                while_continue:
                ;
                if (tmp >= 10U){
                    goto while_break;
                }
                BoxName[0][tmp] = (char)0;
                tmp++;
            }
            while_break:
            ;
        }
        BoxName[1][0] = (char)'v';
        BoxName[1][1] = (char)'b';
        BoxName[1][2] = (char)'o';
        BoxName[1][3] = (char)'x';
        BoxName[1][4] = (char)'\000';
        tmp___0 = 5U;
        {
            while (1){
                while_continue___0:
                ;
                if (tmp___0 >= 10U){
                    goto while_break___0;
                }
                BoxName[1][tmp___0] = (char)0;
                tmp___0++;
            }
            while_break___0:
            ;
        }
        BoxName[2][0] = (char)'m';
        BoxName[2][1] = (char)'b';
        BoxName[2][2] = (char)'o';
        BoxName[2][3] = (char)'x';
        BoxName[2][4] = (char)'\000';
        tmp___1 = 5U;
        {
            while (1){
                while_continue___1:
                ;
                if (tmp___1 >= 10U){
                    goto while_break___1;
                }
                BoxName[2][tmp___1] = (char)0;
                tmp___1++;
            }
            while_break___1:
            ;
        }
        BoxName[3][0] = (char)'f';
        BoxName[3][1] = (char)'b';
        BoxName[3][2] = (char)'o';
        BoxName[3][3] = (char)'x';
        BoxName[3][4] = (char)'\000';
        tmp___2 = 5U;
        {
            while (1){
                while_continue___2:
                ;
                if (tmp___2 >= 10U){
                    goto while_break___2;
                }
                BoxName[3][tmp___2] = (char)0;
                tmp___2++;
            }
            while_break___2:
            ;
        }
        BoxName[4][0] = (char)'p';
        BoxName[4][1] = (char)'a';
        BoxName[4][2] = (char)'r';
        BoxName[4][3] = (char)'b';
        BoxName[4][4] = (char)'o';
        BoxName[4][5] = (char)'x';
        BoxName[4][6] = (char)'\000';
        tmp___3 = 7U;
        {
            while (1){
                while_continue___3:
                ;
                if (tmp___3 >= 10U){
                    goto while_break___3;
                }
                BoxName[4][tmp___3] = (char)0;
                tmp___3++;
            }
            while_break___3:
            ;
        }
        BoxName[5][0] = (char)'m';
        BoxName[5][1] = (char)'a';
        BoxName[5][2] = (char)'k';
        BoxName[5][3] = (char)'e';
        BoxName[5][4] = (char)'b';
        BoxName[5][5] = (char)'o';
        BoxName[5][6] = (char)'x';
        BoxName[5][7] = (char)'\000';
        tmp___4 = 8U;
        {
            while (1){
                while_continue___4:
                ;
                if (tmp___4 >= 10U){
                    goto while_break___4;
                }
                BoxName[5][tmp___4] = (char)0;
                tmp___4++;
            }
            while_break___4:
            ;
        }
        BoxName[6][0] = (char)'f';
        BoxName[6][1] = (char)'r';
        BoxName[6][2] = (char)'a';
        BoxName[6][3] = (char)'m';
        BoxName[6][4] = (char)'e';
        BoxName[6][5] = (char)'b';
        BoxName[6][6] = (char)'o';
        BoxName[6][7] = (char)'x';
        BoxName[6][8] = (char)'\000';
        tmp___5 = 9U;
        {
            while (1){
                while_continue___5:
                ;
                if (tmp___5 >= 10U){
                    goto while_break___5;
                }
                BoxName[6][tmp___5] = (char)0;
                tmp___5++;
            }
            while_break___5:
            ;
        }
        {
            tmp___6 = getTexMode();
            mode = tmp___6;
            diagnostics(4, (char*)"Entering CmdBox() [%s]", BoxName[code - 1]);
        }
        if (code == 1){
            {
                changeTexMode(3);
            }
        }else
            if (code == 3){
                {
                    changeTexMode(3);
                }
            }

        if (code == 5){
            {
                position = getBracketParam();
                width = getBraceParam();
            }
            if (position){
                {
                    free((void*)position);
                }
            }
            {
                free((void*)width);
            }
        }
        if (code == 6){
            goto _L;
        }else
            if (code == 7){
                _L:
                {
                    position___0 = getBracketParam();
                    width___0 = getBracketParam();
                }
                if (position___0){
                    {
                        free((void*)position___0);
                    }
                }
                if (width___0){
                    {
                        free((void*)width___0);
                    }
                }
            }

        {
            diagnostics(4, (char*)"Entering Convert() from CmdBox");
            Convert();
            diagnostics(4, (char*)"Exiting Convert() from CmdBox");
        }
        if (code == 2){
            {
                CmdEndParagraph(0);
                CmdIndent(2);
            }
        }else{
            {
                changeTexMode(mode);
            }
        }
        {
            diagnostics(4, (char*)"Exited CmdBox() [%s]", BoxName[code - 1]);
        }
        return;
    }
}

void CmdVerb(int code)
{
    char cThis;
    char markingchar;
    int num;
    int tmp;
    const unsigned short **tmp___0;
    {
        {
            markingchar = (char)'#';
            tmp = getTexMode();
        }
        if (tmp == 6){
            {
                changeTexMode(2);
            }
        }
        {
            num = TexFontNumber("Typewriter");
            fprintRTF((char*)"{\\b0\\i0\\scaps0\\f%d ", num);
        }
        if (code == 2){
            goto _L;
        }else
            if (code == 1){
                _L:
                {
                    while (1){
                        while_continue:
                        ;
                        {
                            cThis = getRawTexChar();
                        }
                        if (!cThis){
                            goto while_break;
                        }
                        if ((int)cThis != 32){
                            if ((int)cThis != 42){
                                {
                                    tmp___0 = __ctype_b_loc();
                                }
                                if (!((const int)*(*tmp___0 + (int)cThis) & 1024)){
                                    markingchar = cThis;
                                    goto while_break;
                                }
                            }
                        }
                    }
                    while_break:
                    ;
                }
            }

        {
            while (1){
                while_continue___0:
                ;
                {
                    cThis = getRawTexChar();
                }
                if (cThis){
                    if (!((int)cThis != (int)markingchar)){
                        goto while_break___0;
                    }
                }else{
                    goto while_break___0;
                }
                {
                    putRtfCharEscaped(cThis);
                }
            }
            while_break___0:
            ;
        }
        {
            fprintRTF((char*)"}");
        }
        return;
    }
}

void CmdVerbatim(int code)
{
    char* verbatim_text;
    char* endtag;
    int true_code;
    {
        endtag = (char*)((void*)0);
        true_code = code & -16385;
        if (code & 16384){
            {
                diagnostics(4, (char*)"Entering CmdVerbatim");
            }
            if (true_code != 4){
                {
                    PushEnvironment(22);
                    CmdEndParagraph(0);
                    CmdIndent(1);
                    startParagraph("verbatim", 2);
                }
            }
            {
                if (true_code == 1){
                    goto case_1;
                }
                if (true_code == 2){
                    goto case_2;
                }
                if (true_code == 3){
                    goto case_3;
                }
                if (true_code == 4){
                    goto case_4;
                }
                goto switch_break;
                case_1:
                {
                    endtag = strdup("\\end{verbatim}");
                }
                goto switch_break;
                case_2:
                {
                    endtag = strdup("\\end{Verbatim}");
                }
                goto switch_break;
                case_3:
                {
                    endtag = strdup("\\end{alltt}");
                }
                goto switch_break;
                case_4:
                {
                    endtag = strdup("\\end{comment}");
                }
                goto switch_break;
                switch_break:
                ;
            }
            {
                verbatim_text = getTexUntil(endtag, 1);
                UpdateLineNumber(verbatim_text);
            }
            if (true_code == 3){
                {
                    ConvertAllttString(verbatim_text);
                }
            }else
                if (true_code == 1){
                    {
                        show_string(5, (const char*)verbatim_text, "verbatim");
                        putRtfStrEscaped((const char*)verbatim_text);
                    }
                }else
                    if (true_code == 2){
                        {
                            show_string(5, (const char*)verbatim_text, "verbatim");
                            putRtfStrEscaped((const char*)verbatim_text);
                        }
                    }

            {
                free((void*)verbatim_text);
                ConvertString((const char*)endtag);
                free((void*)endtag);
            }
        }else{
            {
                diagnostics(4, (char*)"Exiting CmdVerbatim");
            }
            if (true_code != 4){
                {
                    PopEnvironment();
                    CmdEndParagraph(0);
                    CmdVspace(1);
                    skipWhiteSpace();
                }
            }
        }
        return;
    }
}

void CmdVerse(int code)
{
    int tmp;
    {
        {
            CmdEndParagraph(0);
        }
        {
            if (code == 16384){
                goto case_16384;
            }
            if (code == 0){
                goto case_0;
            }
            goto switch_break;
            case_16384:
            {
                PushEnvironment(21);
                CmdIndent(3);
                tmp = getLeftMarginIndent();
                setLeftMarginIndent(tmp + 1134);
                setLength((char*)"parindent", 0);
            }
            goto switch_break;
            case_0:
            {
                PopEnvironment();
                diagnostics(4, (char*)"Exiting \\end{verse}");
                CmdIndent(2);
                CmdVspace(1);
            }
            goto switch_break;
            switch_break:
            ;
        }
        return;
    }
}

void CmdIgnoreDef(int code)
{
    char cThis;
    {
        {
            while (1){
                while_continue:
                ;
                {
                    cThis = getTexChar();
                }
                if (cThis){
                    if (!((int)cThis != 123)){
                        goto while_break;
                    }
                }else{
                    goto while_break;
                }
            }
            while_break:
            ;
        }
        {
            parseBrace();
        }
        return;
    }
}

void TranslateGerman(void)
{
    char cThis;
    {
        {
            cThis = getTexChar();
        }
        {
            if ((int)cThis == 97){
                goto case_97;
            }
            if ((int)cThis == 111){
                goto case_111;
            }
            if ((int)cThis == 117){
                goto case_117;
            }
            if ((int)cThis == 115){
                goto case_115;
            }
            if ((int)cThis == 65){
                goto case_65;
            }
            if ((int)cThis == 79){
                goto case_79;
            }
            if ((int)cThis == 85){
                goto case_85;
            }
            if ((int)cThis == 124){
                goto case_124;
            }
            if ((int)cThis == 45){
                goto case_45;
            }
            if ((int)cThis == 34){
                goto case_34;
            }
            if ((int)cThis == 39){
                goto case_39;
            }
            if ((int)cThis == 96){
                goto case_96;
            }
            if ((int)cThis == 60){
                goto case_60;
            }
            if ((int)cThis == 62){
                goto case_62;
            }
            goto switch_default;
            case_97:
            {
                fprintRTF((char*)"\\\'e4");
            }
            goto switch_break;
            case_111:
            {
                fprintRTF((char*)"\\\'f6");
            }
            goto switch_break;
            case_117:
            {
                fprintRTF((char*)"\\\'fc");
            }
            goto switch_break;
            case_115:
            {
                fprintRTF((char*)"\\\'df");
            }
            goto switch_break;
            case_65:
            {
                fprintRTF((char*)"\\\'c4");
            }
            goto switch_break;
            case_79:
            {
                fprintRTF((char*)"\\\'d6");
            }
            goto switch_break;
            case_85:
            {
                fprintRTF((char*)"\\\'dc");
            }
            goto switch_break;
            case_124:
            goto switch_break;
            case_45:
            goto switch_break;
            case_34:
            goto switch_break;
            case_39:
            {
                fprintRTF((char*)"\\ldblquote ");
            }
            goto switch_break;
            case_96:
            {
                fprintRTF((char*)"{\\\'84}");
            }
            goto switch_break;
            case_60:
            {
                fprintRTF((char*)"\\\'ab");
            }
            goto switch_break;
            case_62:
            {
                fprintRTF((char*)"\\\'bb");
            }
            goto switch_break;
            switch_default:
            {
                fprintRTF((char*)"%c", (int)cThis);
            }
            switch_break:
            ;
        }
        return;
    }
}

void GermanPrint(int code)
{
    {
        {
            if (code == 1){
                goto case_1;
            }
            if (code == 2){
                goto case_2;
            }
            if (code == 3){
                goto case_3;
            }
            if (code == 4){
                goto case_4;
            }
            if (code == 5){
                goto case_5;
            }
            goto switch_break;
            case_1:
            {
                fprintRTF((char*)"ck");
            }
            goto switch_break;
            case_2:
            {
                fprintRTF((char*)"{\\\'84}");
            }
            goto switch_break;
            case_3:
            {
                fprintRTF((char*)",");
            }
            goto switch_break;
            case_4:
            {
                fprintRTF((char*)"\\lquote");
            }
            goto switch_break;
            case_5:
            {
                fprintRTF((char*)"\\ldblquote");
            }
            switch_break:
            ;
        }
        return;
    }
}

void CmdIgnoreLet(int code)
{
    char t[100];
    char cThis;
    int i;
    char* s;
    {
        {
            s = getSimpleCommand();
            cThis = getNonBlank();
        }
        if ((int)cThis == 61){
            {
                cThis = getNonBlank();
            }
        }
        t[0] = cThis;
        i = 1;
        {
            while (1){
                while_continue:
                ;
                if (!(i < 100)){
                    goto while_break;
                }
                {
                    t[i] = getTexChar();
                }
                if ((int)t[i] == 32){
                    goto while_break;
                }else
                    if ((int)t[i] == 10){
                        goto while_break;
                    }

                i++;
            }
            while_break:
            ;
        }
        {
            t[i] = (char)'\000';
            newDefinition(s + 1, (char*)((void*)0), t, 0);
            free((void*)s);
        }
        return;
    }
}

static int iIfNameCount = 0;
static IfName ifCommands[100] = {{(char*)((void*)0), 0, 0}};
static IfName ifEnvs[100];
static int iIfDepth = 0;

void CmdNewif(int code)
{
    char* s;
    int i;
    int tmp;
    int tmp___0;
    {
        {
            s = getSimpleCommand();
            diagnostics(4, (char*)"discarding %s", s);
            tmp___0 = strncmp((const char*)s, "\\if", (size_t)3);
        }
        if (tmp___0 == 0){
            i = 0;
            {
                while (1){
                    while_continue:
                    ;
                    if (!(i < iIfNameCount)){
                        goto while_break;
                    }
                    {
                        tmp = strcmp((const char*)ifCommands[i].if_name, (const char*)(s + 3));
                    }
                    if (tmp == 0){
                        goto while_break;
                    }
                    i++;
                }
                while_break:
                ;
            }
            if (i < iIfNameCount){
                {
                    diagnostics(1, (char*)"Duplicated \\newif command \'%s\'", s);
                }
            }else{
                {
                    ifCommands[iIfNameCount].if_name = strdup((const char*)(s + 3));
                    ifCommands[iIfNameCount].is_true = 0;
                    ifCommands[iIfNameCount].did_push_env = 0;
                    iIfNameCount++;
                }
            }
        }else{
            {
                diagnostics(1, (char*)"Mystery \\newif command \'%s\'", s);
            }
        }
        if (s){
            {
                free((void*)s);
            }
        }
        return;
    }
}

void CmdElse(int code)
{
    {
        iIfDepth--;
        if (ifEnvs[iIfDepth].did_push_env){
            {
                fprintRTF((char*)"\" }");
                ifEnvs[iIfDepth].did_push_env = 0;
            }
        }else{
            {
                ifEnvs[iIfDepth].did_push_env = 1;
                fprintRTF((char*)"{\\v \"");
            }
        }
        iIfDepth++;
        return;
    }
}

void CmdFi(int code)
{
    {
        iIfDepth--;
        if (ifEnvs[iIfDepth].did_push_env){
            {
                fprintRTF((char*)"\" }");
            }
        }
        return;
    }
}

int TryConditionSet(char* command)
{
    int i;
    int tmp;
    int tmp___0;
    char* s;
    char* t;
    char* tmp___1;
    char* f;
    char* tmp___2;
    int tmp___3;
    int tmp___4;
    {
        {
            tmp___0 = strncmp((const char*)command, "if", (size_t)2);
        }
        if (tmp___0 == 0){
            i = 0;
            {
                while (1){
                    while_continue:
                    ;
                    if (!(i < iIfNameCount)){
                        goto while_break;
                    }
                    {
                        tmp = strcmp((const char*)(command + 2), (const char*)ifCommands[i].if_name);
                    }
                    if (tmp == 0){
                        ifEnvs[iIfDepth] = ifCommands[i];
                        if (!ifCommands[i].is_true){
                            {
                                ifEnvs[iIfDepth].did_push_env = 1;
                                fprintRTF((char*)"{\\v \"");
                            }
                        }
                        iIfDepth++;
                        return (1);
                    }
                    i++;
                }
                while_break:
                ;
            }
        }
        i = 0;
        {
            while (1){
                while_continue___0:
                ;
                if (!(i < iIfNameCount)){
                    goto while_break___0;
                }
                {
                    s = ifCommands[i].if_name;
                    tmp___1 = strdup_together((const char*)s, "true");
                    t = tmp___1;
                    tmp___2 = strdup_together((const char*)s, "false");
                    f = tmp___2;
                    tmp___4 = strcmp((const char*)command, (const char*)t);
                }
                if (tmp___4 == 0){
                    {
                        ifCommands[i].is_true = 1;
                        free((void*)t);
                        free((void*)f);
                    }
                    return (1);
                }else{
                    {
                        tmp___3 = strcmp((const char*)command, (const char*)f);
                    }
                    if (tmp___3 == 0){
                        {
                            ifCommands[iIfNameCount].is_true = 0;
                            free((void*)t);
                            free((void*)f);
                        }
                        return (1);
                    }
                }
                {
                    free((void*)t);
                    free((void*)f);
                    i++;
                }
            }
            while_break___0:
            ;
        }
        return (0);
    }
}

void CmdQuad(int kk)
{
    int z;
    {
        {
            fprintRTF((char*)"{");
            z = 0;
        }
        {
            while (1){
                while_continue:
                ;
                if (!(z <= kk)){
                    goto while_break;
                }
                {
                    fprintRTF((char*)"  ");
                    z++;
                }
            }
            while_break:
            ;
        }
        {
            fprintRTF((char*)"}");
        }
        return;
    }
}

void CmdSpace(float kk)
{
    int size;
    int tmp;
    int tmp___0;
    {
        {
            tmp = CurrentFontSize();
            size = (int)((float)tmp * kk);
            tmp___0 = getTexMode();
        }
        if (tmp___0 == 6){
            {
                changeTexMode(2);
            }
        }
        {
            fprintRTF((char*)"{\\fs%d  }", size);
        }
        return;
    }
}

void CmdKern(int code)
{
    int size;
    int tmp;
    {
        {
            tmp = getDimension();
            size = tmp * 2;
            fprintRTF((char*)"\\expnd%d\\expndtw%d ", size, size);
        }
        return;
    }
}

static char oldalignment___0;

void CmdFigure(int code)
{
    char* figure_contents;
    char* lines;
    char* position;
    char* width;
    char endfigure[50];
    int real_code;
    int tmp;
    char* loc;
    char* tmp___0;
    const char* tmp___1;
    int tmp___2;
    int tmp___3;
    char* caption;
    char* label;
    {
        real_code = code & -16385;
        {
            if (real_code == 1){
                goto case_1;
            }
            if (real_code == 5){
                goto case_5;
            }
            if (real_code == 6){
                goto case_6;
            }
            goto switch_break;
            case_1:
            {
                strcpy((char*)(endfigure), (const char*)"\\end{figure}");
            }
            goto switch_break;
            case_5:
            {
                strcpy((char*)(endfigure), (const char*)"\\end{figure*}");
            }
            goto switch_break;
            case_6:
            {
                strcpy((char*)(endfigure), (const char*)"\\end{wrapfigure}");
            }
            goto switch_break;
            switch_break:
            ;
        }
        if (code & 16384){
            {
                setCounter((char*)"subfigure", 0);
                CmdEndParagraph(0);
                tmp = getAlignment();
                oldalignment___0 = (char)tmp;
                setAlignment('j');
                CmdVspace(3);
            }
            if (real_code == 6){
                {
                    lines = getBracketParam();
                    position = getBraceParam();
                    width = getBraceParam();
                }
                if (lines){
                    {
                        free((void*)lines);
                    }
                }
                if (position){
                    {
                        free((void*)position);
                    }
                }
                if (width){
                    {
                        free((void*)width);
                    }
                }
            }else{
                {
                    tmp___0 = getBracketParam();
                    loc = tmp___0;
                }
                if (loc){
                    tmp___1 = (const char*)loc;
                }else{
                    tmp___1 = "";
                }
                {
                    diagnostics(4, (char*)"entering CmdFigure [%s]", tmp___1);
                }
                if (loc){
                    {
                        free((void*)loc);
                    }
                }
            }
            {
                g_processing_figure = 1;
                figure_contents = getTexUntil(endfigure, 1);
                g_figure_label = ExtractLabelTag((const char*)figure_contents);
            }
            if (g_endfloat_figures){
                if (g_endfloat_markers){
                    {
                        setAlignment('c');
                        startParagraph("endfloat", 2);
                        incrementCounter((char*)"endfloatfigure");
                        fprintRTF((char*)"[");
                        ConvertBabelName((char*)"FIGURENAME");
                        fprintRTF((char*)" ");
                    }
                    if (g_document_type != 1){
                        {
                            tmp___2 = getCounter((char*)"chapter");
                            fprintRTF((char*)"%d.", tmp___2);
                        }
                    }
                    {
                        tmp___3 = getCounter((char*)"endfloatfigure");
                        fprintRTF((char*)"%d about here]", tmp___3);
                    }
                }
            }else
                if (g_latex_figures){
                    {
                        caption = ExtractAndRemoveTag((char*)"\\caption", figure_contents);
                        label = ExtractAndRemoveTag((char*)"\\label", figure_contents);
                        PrepareDisplayedBitmap((char*)"figure");
                        WriteLatexAsBitmap((char*)"\\begin{figure}", figure_contents, (char*)"\\end{figure}");
                        FinishDisplayedBitmap();
                        ConvertString((const char*)caption);
                        safe_free(label);
                        safe_free(caption);
                    }
                }else{
                    {
                        startParagraph("figure", 2);
                        ConvertString((const char*)figure_contents);
                    }
                }

            {
                free((void*)figure_contents);
                ConvertString((const char*)(endfigure));
            }
        }else{
            {
                safe_free(g_figure_label);
                g_processing_figure = 0;
                diagnostics(4, (char*)"exiting CmdFigure");
                setAlignment((int)oldalignment___0);
                CmdEndParagraph(0);
                CmdVspace(3);
            }
        }
        return;
    }
}

void CmdSubFigure(int code)
{
    char* caption;
    char* contents;
    int n;
    {
        {
            diagnostics(4, (char*)"CmdSubFigure");
            caption = getBracketParam();
            contents = getBraceParam();
            startParagraph("subfigure", 1);
            ConvertString((const char*)contents);
            free((void*)contents);
            CmdEndParagraph(0);
        }
        if (caption){
            {
                startParagraph("subfigure", 1);
                n = getCounter((char*)"subfigure");
                fprintRTF((char*)"(%c) ", (int)((char)(n + 97)));
                ConvertString((const char*)caption);
                CmdEndParagraph(0);
                free((void*)caption);
            }
        }
        {
            incrementCounter((char*)"subfigure");
        }
        return;
    }
}

static void FixTildes(char* s)
{
    char* p;
    char* p3;
    char* tmp;
    char* tmp___0;
    {
        {
            while (1){
                while_continue:
                ;
                {
                    p = strstr((const char*)s, "\\~{}");
                }
                if (!((unsigned long )p != (unsigned long )((void*)0))){
                    goto while_break;
                }
                *p = (char)'~';
                p++;
                p3 = p + 3;
                {
                    while (1){
                        while_continue___0:
                        ;
                        if (!*p3){
                            goto while_break___0;
                        }
                        tmp = p;
                        p++;
                        tmp___0 = p3;
                        p3++;
                        *tmp = *tmp___0;
                    }
                    while_break___0:
                    ;
                }
                *p = (char)'\000';
            }
            while_break:
            ;
        }
        return;
    }
}

void CmdLink(int code)
{
    char* anchor;
    char* latex;
    char* url;
    {
        {
            diagnostics(4, (char*)"Entering hyperlatex \\link command");
            anchor = getBraceParam();
            latex = getBracketParam();
            url = getBraceParam();
            FixTildes(url);
            fprintRTF((char*)"{\\field\\fldedit{\\*\\fldinst { HYPERLINK \"%s\" \\\\* MERGEFORMAT }}", url);
            fprintRTF((char*)"{\\fldrslt {\\cs15\\ul\\cf2 ");
            ConvertString((const char*)anchor);
            fprintRTF((char*)"}}}");
        }
        if (latex){
            {
                free((void*)latex);
            }
        }
        {
            free((void*)anchor);
            free((void*)url);
        }
        return;
    }
}

void CmdColumn(int code)
{
    {
        {
            if (code == 1){
                goto case_1;
            }
            if (code == 2){
                goto case_2;
            }
            goto switch_break;
            case_1:
            {
                fprintRTF((char*)"\\page\n\\colsx709\\endnhere ");
                twocolumn = 0;
            }
            goto switch_break;
            case_2:
            {
                fprintRTF((char*)"\\page\n\\cols2\\colsx709\\endnhere ");
                twocolumn = 1;
            }
            goto switch_break;
            switch_break:
            ;
        }
        return;
    }
}

void Cmd_OptParam_Without_braces(int code)
{
    char cNext;
    char cLast;
    const unsigned short **tmp;
    {
        cNext = (char)' ';
        cLast = (char)' ';
        {
            while (1){
                while_continue:
                ;
                {
                    cLast = cNext;
                    cNext = getTexChar();
                }
                if ((int)cNext != 32){
                    if ((int)cNext != 92){
                        if ((int)cNext != 123){
                            if ((int)cNext != 10){
                                if ((int)cNext != 44){
                                    if ((int)cNext != 46){
                                        goto _L;
                                    }else{
                                        {
                                            tmp = __ctype_b_loc();
                                        }
                                        if ((const int)*(*tmp + (int)cLast) & 2048){
                                            _L:
                                            if ((int)cNext != 125){
                                                if ((int)cNext != 34){
                                                    if ((int)cNext != 91){
                                                        if (!((int)cNext != 36)){
                                                            goto while_break;
                                                        }
                                                    }else{
                                                        goto while_break;
                                                    }
                                                }else{
                                                    goto while_break;
                                                }
                                            }else{
                                                goto while_break;
                                            }
                                        }else{
                                            goto while_break;
                                        }
                                    }
                                }else{
                                    goto while_break;
                                }
                            }else{
                                goto while_break;
                            }
                        }else{
                            goto while_break;
                        }
                    }else{
                        goto while_break;
                    }
                }else{
                    goto while_break;
                }
            }
            while_break:
            ;
        }
        {
            ungetTexChar(cNext);
        }
        return;
    }
}

void CmdBottom(int code)
{
    {
        return;
    }
}

static char oldalignment___1;

void CmdAbstract(int code)
{
    int tmp;
    int tmp___0;
    int tmp___1;
    char* s;
    char* tmp___2;
    int tmp___3;
    int tmp___4;
    {
        if (code == 3){
            goto _L;
        }else
            if (code == 1){
                goto _L;
            }else
                if (code == 16386){
                    _L:
                    {
                        CmdEndParagraph(0);
                        tmp = getAlignment();
                        oldalignment___1 = (char)tmp;
                    }
                    if (g_document_type == 2){
                        {
                            CmdNewPage(1);
                        }
                    }else
                        if (titlepage){
                            {
                                CmdNewPage(1);
                            }
                        }

                    {
                        startParagraph("abstract_title", 2);
                        ConvertBabelName((char*)"ABSTRACTNAME");
                        tmp___0 = getLeftMarginIndent();
                        setLeftMarginIndent(tmp___0 + 1024);
                        tmp___1 = getRightMarginIndent();
                        setRightMarginIndent(tmp___1 + 1024);
                        setAlignment('j');
                        CmdEndParagraph(0);
                        CmdIndent(3);
                        startParagraph("Normal", 2);
                    }
                }

        if (code == 1){
            {
                tmp___2 = getBraceParam();
                s = tmp___2;
                ConvertString((const char*)s);
                free((void*)s);
            }
        }
        if (code == 4){
            goto _L___0;
        }else
            if (code == 2){
                _L___0:
                {
                    CmdIndent(3);
                    CmdEndParagraph(0);
                    tmp___3 = getLeftMarginIndent();
                    setLeftMarginIndent(tmp___3 - 1024);
                    tmp___4 = getRightMarginIndent();
                    setRightMarginIndent(tmp___4 - 1024);
                    setAlignment((int)oldalignment___1);
                    CmdVspace(2);
                }
            }

        return;
    }
}

void CmdKeywords(int code)
{
    char* keywords;
    char* tmp;
    {
        {
            tmp = getBraceParam();
            keywords = tmp;
        }
        if ((unsigned long )((void*)0) != (unsigned long )keywords){
            {
                CmdEndParagraph(0);
                CmdVspace(1);
                startParagraph("Normal", 1);
                fprintRTF((char*)"{{\\b ");
                ConvertBabelName((char*)"KEYWORDS");
                fprintRTF((char*)"}\\tab\n");
                fprintRTF(keywords);
                fprintRTF((char*)"\n}\n");
                CmdEndParagraph(0);
                CmdVspace(1);
                free((void*)keywords);
            }
        }
        return;
    }
}

static char oldalignment___2;

void CmdAcknowledgments(int code)
{
    int tmp;
    {
        {
            CmdEndParagraph(0);
        }
        if (code == 16384){
            {
                CmdVspace(3);
                startParagraph("acknowledgments", 2);
                fprintRTF((char*)"\n{\\b ");
                fprintRTF((char*)"Acknowledgments");
                fprintRTF((char*)"}\n");
                CmdEndParagraph(0);
                tmp = getAlignment();
                oldalignment___2 = (char)tmp;
                setAlignment('j');
            }
        }else{
            {
                setAlignment((int)oldalignment___2);
                CmdVspace(3);
            }
        }
        return;
    }
}

void CmdTitlepage(int code)
{
    {
        {
            CmdNewPage(1);
        }
        return;
    }
}

void CmdMinipage(int code)
{
    char* v_align;
    char* width;
    {
        {
            if (code == 16384){
                goto case_16384;
            }
            if (code == 0){
                goto case_0;
            }
            goto switch_break;
            case_16384:
            {
                v_align = getBracketParam();
                width = getBraceParam();
            }
            if (v_align){
                {
                    free((void*)v_align);
                }
            }
            {
                free((void*)width);
            }
            goto switch_break;
            case_0:
            goto switch_break;
            switch_break:
            ;
        }
        return;
    }
}

void CmdColsep(int code)
{
    int tmp;
    int tmp___0;
    {
        if (!g_processing_tabular){
            {
                fprintRTF((char*)"{\\\'a7}");
            }
            return;
        }
        {
            diagnostics(0, (char*)"CmdColsep called");
            tmp = getTexMode();
        }
        if (tmp == 5){
            {
                fprintRTF((char*)"\\tab\n");
            }
        }else{
            {
                tmp___0 = getTexMode();
            }
            if (tmp___0 == 4){
                {
                    fprintRTF((char*)"\\tab\n");
                }
            }else{
                {
                    fprintRTF((char*)"\\cell}{\\pard\\intbl ");
                }
            }
        }
        return;
    }
}

void CmdVerbosityLevel(int code)
{
    char* s;
    char* tmp;
    {
        {
            tmp = getBraceParam();
            s = tmp;
            g_verbosity_level = atoi((const char*)s);
            free((void*)s);
        }
        return;
    }
}

char* roman_item(int n, int upper)
{
    char s[50];
    int i;
    char* tmp;
    char* tmp___0;
    char* tmp___1;
    {
        i = 0;
        {
            while (1){
                while_continue:
                ;
                if (!(n >= 10)){
                    goto while_break;
                }
                n -= 10;
                if (upper){
                    s[i] = (char)'X';
                }else{
                    s[i] = (char)'x';
                }
                i++;
            }
            while_break:
            ;
        }
        if (n == 9){
            if (upper){
                s[i] = (char)'I';
            }else{
                s[i] = (char)'i';
            }
            i++;
            if (upper){
                s[i] = (char)'X';
            }else{
                s[i] = (char)'x';
            }
            {
                i++;
                s[i] = (char)'\000';
                tmp = strdup((const char*)(s));
            }
            return (tmp);
        }
        if (n >= 5){
            n -= 5;
            if (upper){
                s[i] = (char)'V';
            }else{
                s[i] = (char)'v';
            }
            i++;
        }
        if (n == 4){
            if (upper){
                s[i] = (char)'I';
            }else{
                s[i] = (char)'i';
            }
            i++;
            if (upper){
                s[i] = (char)'V';
            }else{
                s[i] = (char)'v';
            }
            {
                i++;
                s[i] = (char)'\000';
                tmp___0 = strdup((const char*)(s));
            }
            return (tmp___0);
        }
        {
            while (1){
                while_continue___0:
                ;
                if (!(n >= 1)){
                    goto while_break___0;
                }
                n--;
                if (upper){
                    s[i] = (char)'I';
                }else{
                    s[i] = (char)'i';
                }
                i++;
            }
            while_break___0:
            ;
        }
        {
            s[i] = (char)'\000';
            tmp___1 = strdup((const char*)(s));
        }
        return (tmp___1);
    }
}

void CmdNonBreakSpace(int code)
{
    char cThis;
    int tmp;
    {
        {
            cThis = getNonSpace();
            ungetTexChar(cThis);
            tmp = getTexMode();
        }
        if (tmp == 6){
            {
                changeTexMode(2);
            }
        }
        if (code == 100){
            {
                fprintRTF((char*)"\\~ ");
            }
        }else{
            {
                fprintRTF((char*)"{\\charscalex%d\\~}", code);
            }
        }
        return;
    }
}

void CmdIf(int code)
{
    char* s;
    char* tmp;
    {
        {
            tmp = getTexUntil((char*)"\\fi", 0);
            s = tmp;
            safe_free(s);
        }
        return;
    }
}

void CmdEndInput(int code)
{
    {
        {
            PopSource();
        }
        return;
    }
}

void CmdTextFont(int code)
{
    char* s;
    char* tmp;
    {
        {
            tmp = getBraceParam();
            s = tmp;
            free((void*)s);
        }
        return;
    }
}

void CmdThe(int code)
{
    {
        return;
    }
}

void CmdRule(int code)
{
    char* raise;
    char* width;
    char* height;
    int dim;
    int n;
    int i;
    int tmp;
    {
        {
            raise = getBracketParam();
            width = getBraceParam();
            height = getBraceParam();
            dim = getStringDimension(width);
            tmp = CurrentFontSize();
            n = (dim / tmp) / 5;
            i = 0;
        }
        {
            while (1){
                while_continue:
                ;
                if (!(i < n)){
                    goto while_break;
                }
                {
                    fprintRTF((char*)"_");
                    i++;
                }
            }
            while_break:
            ;
        }
        if (raise){
            {
                free((void*)raise);
            }
        }
        {
            free((void*)width);
            free((void*)height);
        }
        return;
    }
}

void CmdTolerateEnviron(int code)
{
    {
        if (code == 16384){
            {
                diagnostics(4, (char*)"Entering CmdTolerateEnviron \\begin{environ}");
            }
        }
        if (code == 0){
            {
                diagnostics(4, (char*)"Exiting CmdTolerateEnviron \\end{environ}");
            }
        }
        return;
    }
}

void CmdIgnoreEnviron(int code)
{
    char* endtag;
    char* s;
    {
        endtag = (char*)((void*)0);
        s = (char*)((void*)0);
        if (code & 16384){
            {
                if ((code & -16385) == 3){
                    goto case_3;
                }
                if ((code & -16385) == 1){
                    goto case_1;
                }
                if ((code & -16385) == 4){
                    goto case_4;
                }
                goto switch_break;
                case_3:
                {
                    endtag = strdup("\\end{minipage}");
                }
                goto switch_break;
                case_1:
                {
                    endtag = strdup("\\end{htmlonly}");
                }
                goto switch_break;
                case_4:
                {
                    endtag = strdup("\\end{rawhtml}");
                }
                goto switch_break;
                switch_break:
                ;
            }
            if (endtag){
                {
                    s = getTexUntil(endtag, 0);
                    ConvertString((const char*)endtag);
                }
                if (s){
                    {
                        free((void*)s);
                    }
                }
                {
                    free((void*)endtag);
                }
            }
        }
        return;
    }
}

void CmdIflatextortf(int code)
{
    char* entire_if;
    char* else_clause;
    {
        {
            entire_if = getTexUntil((char*)"\\fi", 0);
            else_clause = strstr((const char*)entire_if, "\\else");
        }
        if ((unsigned long )else_clause != (unsigned long )((void*)0)){
            *else_clause = (char)'\000';
        }
        {
            ConvertString((const char*)entire_if);
            diagnostics(2, (char*)"CmdIflatextortf clause is");
            diagnostics(2, (char*)"       <%s>", entire_if);
            free((void*)entire_if);
        }
        return;
    }
}

static int NumForColor(char* color)
{
    int n;
    int tmp;
    int tmp___0;
    int tmp___1;
    int tmp___2;
    int tmp___3;
    int tmp___4;
    int tmp___5;
    int tmp___6;
    int tmp___7;
    int tmp___8;
    int tmp___9;
    int tmp___10;
    int tmp___11;
    int tmp___12;
    int tmp___13;
    int tmp___14;
    int tmp___15;
    int tmp___16;
    int tmp___17;
    int tmp___18;
    int tmp___19;
    int tmp___20;
    int tmp___21;
    int tmp___22;
    int tmp___23;
    int tmp___24;
    int tmp___25;
    int tmp___26;
    int tmp___27;
    int tmp___28;
    int tmp___29;
    int tmp___30;
    int tmp___31;
    int tmp___32;
    int tmp___33;
    int tmp___34;
    int tmp___35;
    int tmp___36;
    int tmp___37;
    int tmp___38;
    int tmp___39;
    int tmp___40;
    int tmp___41;
    int tmp___42;
    int tmp___43;
    int tmp___44;
    int tmp___45;
    int tmp___46;
    int tmp___47;
    int tmp___48;
    int tmp___49;
    int tmp___50;
    int tmp___51;
    int tmp___52;
    int tmp___53;
    int tmp___54;
    int tmp___55;
    int tmp___56;
    int tmp___57;
    int tmp___58;
    int tmp___59;
    int tmp___60;
    int tmp___61;
    int tmp___62;
    int tmp___63;
    int tmp___64;
    int tmp___65;
    int tmp___66;
    int tmp___67;
    int tmp___68;
    int tmp___69;
    int tmp___70;
    int tmp___71;
    int tmp___72;
    int tmp___73;
    int tmp___74;
    int tmp___75;
    int tmp___76;
    int tmp___77;
    int tmp___78;
    int tmp___79;
    int tmp___80;
    int tmp___81;
    int tmp___82;
    int tmp___83;
    int tmp___84;
    int tmp___85;
    int tmp___86;
    int tmp___87;
    int tmp___88;
    int tmp___89;
    int tmp___90;
    int tmp___91;
    int tmp___92;
    int tmp___93;
    int tmp___94;
    int tmp___95;
    int tmp___96;
    int tmp___97;
    int tmp___98;
    int tmp___99;
    int tmp___100;
    int tmp___101;
    int tmp___102;
    int tmp___103;
    int tmp___104;
    int tmp___105;
    int tmp___106;
    int tmp___107;
    int tmp___108;
    int tmp___109;
    int tmp___110;
    int tmp___111;
    int tmp___112;
    int tmp___113;
    int tmp___114;
    int tmp___115;
    int tmp___116;
    int tmp___117;
    int tmp___118;
    int tmp___119;
    int tmp___120;
    int tmp___121;
    int tmp___122;
    int tmp___123;
    int tmp___124;
    int tmp___125;
    int tmp___126;
    int tmp___127;
    {
        {
            n = -1;
            tmp___127 = strcmp((const char*)color, "black");
        }
        if (tmp___127 == 0){
            n = 1;
        }else{
            {
                tmp___126 = strcmp((const char*)color, "blue");
            }
            if (tmp___126 == 0){
                n = 2;
            }else{
                {
                    tmp___125 = strcmp((const char*)color, "cyan");
                }
                if (tmp___125 == 0){
                    n = 3;
                }else{
                    {
                        tmp___124 = strcmp((const char*)color, "green");
                    }
                    if (tmp___124 == 0){
                        n = 4;
                    }else{
                        {
                            tmp___123 = strcmp((const char*)color, "magenta");
                        }
                        if (tmp___123 == 0){
                            n = 5;
                        }else{
                            {
                                tmp___122 = strcmp((const char*)color, "red");
                            }
                            if (tmp___122 == 0){
                                n = 6;
                            }else{
                                {
                                    tmp___121 = strcmp((const char*)color, "yellow");
                                }
                                if (tmp___121 == 0){
                                    n = 7;
                                }else{
                                    {
                                        tmp___120 = strcmp((const char*)color, "white");
                                    }
                                    if (tmp___120 == 0){
                                        n = 8;
                                    }else{
                                        {
                                            tmp___119 = strcmp((const char*)color, "gray");
                                        }
                                        if (tmp___119 == 0){
                                            n = 16;
                                        }else{
                                            {
                                                tmp___118 = strcmp((const char*)color, "Almond");
                                            }
                                            if (tmp___118 == 0){
                                                n = 17;
                                            }else{
                                                {
                                                    tmp___117 = strcmp((const char*)color, "AntiqueBrass");
                                                }
                                                if (tmp___117 == 0){
                                                    n = 18;
                                                }else{
                                                    {
                                                        tmp___116 = strcmp((const char*)color, "Apricot");
                                                    }
                                                    if (tmp___116 == 0){
                                                        n = 19;
                                                    }else{
                                                        {
                                                            tmp___115 = strcmp((const char*)color, "Aquamarine");
                                                        }
                                                        if (tmp___115 == 0){
                                                            n = 20;
                                                        }else{
                                                            {
                                                                tmp___114 = strcmp((const char*)color, "Asparagus");
                                                            }
                                                            if (tmp___114 == 0){
                                                                n = 21;
                                                            }else{
                                                                {
                                                                    tmp___113 = strcmp((const char*)color, "AtomicTangerine");
                                                                }
                                                                if (tmp___113 == 0){
                                                                    n = 22;
                                                                }else{
                                                                    {
                                                                        tmp___112 = strcmp((const char*)color, "BananaMania");
                                                                    }
                                                                    if (tmp___112 == 0){
                                                                        n = 23;
                                                                    }else{
                                                                        {
                                                                            tmp___111 = strcmp((const char*)color, "Beaver");
                                                                        }
                                                                        if (tmp___111 == 0){
                                                                            n = 24;
                                                                        }else{
                                                                            {
                                                                                tmp___110 = strcmp((const char*)color, "Bittersweet");
                                                                            }
                                                                            if (tmp___110 == 0){
                                                                                n = 25;
                                                                            }else{
                                                                                {
                                                                                    tmp___109 = strcmp((const char*)color, "Black");
                                                                                }
                                                                                if (tmp___109 == 0){
                                                                                    n = 26;
                                                                                }else{
                                                                                    {
                                                                                        tmp___108 = strcmp((const char*)color, "Blue");
                                                                                    }
                                                                                    if (tmp___108 == 0){
                                                                                        n = 27;
                                                                                    }else{
                                                                                        {
                                                                                            tmp___107 = strcmp((const char*)color, "BlueBell");
                                                                                        }
                                                                                        if (tmp___107 == 0){
                                                                                            n = 28;
                                                                                        }else{
                                                                                            {
                                                                                                tmp___106 = strcmp((const char*)color, "BlueGreen");
                                                                                            }
                                                                                            if (tmp___106 == 0){
                                                                                                n = 29;
                                                                                            }else{
                                                                                                {
                                                                                                    tmp___105 = strcmp((const char*)color, "BlueViolet");
                                                                                                }
                                                                                                if (tmp___105 == 0){
                                                                                                    n = 30;
                                                                                                }else{
                                                                                                    {
                                                                                                        tmp___104 = strcmp((const char*)color, "Blush");
                                                                                                    }
                                                                                                    if (tmp___104 == 0){
                                                                                                        n = 31;
                                                                                                    }else{
                                                                                                        {
                                                                                                            tmp___103 = strcmp((const char*)color, "BrickRed");
                                                                                                        }
                                                                                                        if (tmp___103 == 0){
                                                                                                            n = 32;
                                                                                                        }else{
                                                                                                            {
                                                                                                                tmp___102 = strcmp((const char*)color, "Brown");
                                                                                                            }
                                                                                                            if (tmp___102 == 0){
                                                                                                                n = 33;
                                                                                                            }else{
                                                                                                                {
                                                                                                                    tmp___101 = strcmp((const char*)color, "BurntOrange");
                                                                                                                }
                                                                                                                if (tmp___101 == 0){
                                                                                                                    n = 34;
                                                                                                                }else{
                                                                                                                    {
                                                                                                                        tmp___100 = strcmp((const char*)color, "BurntSienna");
                                                                                                                    }
                                                                                                                    if (tmp___100 == 0){
                                                                                                                        n = 35;
                                                                                                                    }else{
                                                                                                                        {
                                                                                                                            tmp___99 = strcmp((const char*)color, "CadetBlue");
                                                                                                                        }
                                                                                                                        if (tmp___99 == 0){
                                                                                                                            n = 36;
                                                                                                                        }else{
                                                                                                                            {
                                                                                                                                tmp___98 = strcmp((const char*)color, "Canary");
                                                                                                                            }
                                                                                                                            if (tmp___98 == 0){
                                                                                                                                n = 37;
                                                                                                                            }else{
                                                                                                                                {
                                                                                                                                    tmp___97 = strcmp((const char*)color, "CaribbeanGreen");
                                                                                                                                }
                                                                                                                                if (tmp___97 == 0){
                                                                                                                                    n = 38;
                                                                                                                                }else{
                                                                                                                                    {
                                                                                                                                        tmp___96 = strcmp((const char*)color, "CarnationPink");
                                                                                                                                    }
                                                                                                                                    if (tmp___96 == 0){
                                                                                                                                        n = 39;
                                                                                                                                    }else{
                                                                                                                                        {
                                                                                                                                            tmp___95 = strcmp((const char*)color, "Cerise");
                                                                                                                                        }
                                                                                                                                        if (tmp___95 == 0){
                                                                                                                                            n = 40;
                                                                                                                                        }else{
                                                                                                                                            {
                                                                                                                                                tmp___94 = strcmp((const char*)color, "Cerulean");
                                                                                                                                            }
                                                                                                                                            if (tmp___94 == 0){
                                                                                                                                                n = 41;
                                                                                                                                            }else{
                                                                                                                                                {
                                                                                                                                                    tmp___93 = strcmp((const char*)color, "Chestnut");
                                                                                                                                                }
                                                                                                                                                if (tmp___93 == 0){
                                                                                                                                                    n = 42;
                                                                                                                                                }else{
                                                                                                                                                    {
                                                                                                                                                        tmp___92 = strcmp((const char*)color, "Copper");
                                                                                                                                                    }
                                                                                                                                                    if (tmp___92 == 0){
                                                                                                                                                        n = 43;
                                                                                                                                                    }else{
                                                                                                                                                        {
                                                                                                                                                            tmp___91 = strcmp((const char*)color, "Cornflower");
                                                                                                                                                        }
                                                                                                                                                        if (tmp___91 == 0){
                                                                                                                                                            n = 44;
                                                                                                                                                        }else{
                                                                                                                                                            {
                                                                                                                                                                tmp___90 = strcmp((const char*)color, "CottonCandy");
                                                                                                                                                            }
                                                                                                                                                            if (tmp___90 == 0){
                                                                                                                                                                n = 45;
                                                                                                                                                            }else{
                                                                                                                                                                {
                                                                                                                                                                    tmp___89 = strcmp((const char*)color, "Dandelion");
                                                                                                                                                                }
                                                                                                                                                                if (tmp___89 == 0){
                                                                                                                                                                    n = 46;
                                                                                                                                                                }else{
                                                                                                                                                                    {
                                                                                                                                                                        tmp___88 = strcmp((const char*)color, "Denim");
                                                                                                                                                                    }
                                                                                                                                                                    if (tmp___88 == 0){
                                                                                                                                                                        n = 47;
                                                                                                                                                                    }else{
                                                                                                                                                                        {
                                                                                                                                                                            tmp___87 = strcmp((const char*)color, "DesertSand");
                                                                                                                                                                        }
                                                                                                                                                                        if (tmp___87 == 0){
                                                                                                                                                                            n = 48;
                                                                                                                                                                        }else{
                                                                                                                                                                            {
                                                                                                                                                                                tmp___86 = strcmp((const char*)color, "Eggplant");
                                                                                                                                                                            }
                                                                                                                                                                            if (tmp___86 == 0){
                                                                                                                                                                                n = 49;
                                                                                                                                                                            }else{
                                                                                                                                                                                {
                                                                                                                                                                                    tmp___85 = strcmp((const char*)color, "ElectricLime");
                                                                                                                                                                                }
                                                                                                                                                                                if (tmp___85 == 0){
                                                                                                                                                                                    n = 50;
                                                                                                                                                                                }else{
                                                                                                                                                                                    {
                                                                                                                                                                                        tmp___84 = strcmp((const char*)color, "Fern");
                                                                                                                                                                                    }
                                                                                                                                                                                    if (tmp___84 == 0){
                                                                                                                                                                                        n = 51;
                                                                                                                                                                                    }else{
                                                                                                                                                                                        {
                                                                                                                                                                                            tmp___83 = strcmp((const char*)color, "ForestGreen");
                                                                                                                                                                                        }
                                                                                                                                                                                        if (tmp___83 == 0){
                                                                                                                                                                                            n = 52;
                                                                                                                                                                                        }else{
                                                                                                                                                                                            {
                                                                                                                                                                                                tmp___82 = strcmp((const char*)color, "Fuchsia");
                                                                                                                                                                                            }
                                                                                                                                                                                            if (tmp___82 == 0){
                                                                                                                                                                                                n = 53;
                                                                                                                                                                                            }else{
                                                                                                                                                                                                {
                                                                                                                                                                                                    tmp___81 = strcmp((const char*)color, "FuzzyWuzzyBrown");
                                                                                                                                                                                                }
                                                                                                                                                                                                if (tmp___81 == 0){
                                                                                                                                                                                                    n = 54;
                                                                                                                                                                                                }else{
                                                                                                                                                                                                    {
                                                                                                                                                                                                        tmp___80 = strcmp((const char*)color, "Gold");
                                                                                                                                                                                                    }
                                                                                                                                                                                                    if (tmp___80 == 0){
                                                                                                                                                                                                        n = 55;
                                                                                                                                                                                                    }else{
                                                                                                                                                                                                        {
                                                                                                                                                                                                            tmp___79 = strcmp((const char*)color, "Goldenrod");
                                                                                                                                                                                                        }
                                                                                                                                                                                                        if (tmp___79 == 0){
                                                                                                                                                                                                            n = 56;
                                                                                                                                                                                                        }else{
                                                                                                                                                                                                            {
                                                                                                                                                                                                                tmp___78 = strcmp((const char*)color, "GrannySmithApple");
                                                                                                                                                                                                            }
                                                                                                                                                                                                            if (tmp___78 == 0){
                                                                                                                                                                                                                n = 57;
                                                                                                                                                                                                            }else{
                                                                                                                                                                                                                {
                                                                                                                                                                                                                    tmp___77 = strcmp((const char*)color, "Gray");
                                                                                                                                                                                                                }
                                                                                                                                                                                                                if (tmp___77 == 0){
                                                                                                                                                                                                                    n = 58;
                                                                                                                                                                                                                }else{
                                                                                                                                                                                                                    {
                                                                                                                                                                                                                        tmp___76 = strcmp((const char*)color, "Green");
                                                                                                                                                                                                                    }
                                                                                                                                                                                                                    if (tmp___76 == 0){
                                                                                                                                                                                                                        n = 59;
                                                                                                                                                                                                                    }else{
                                                                                                                                                                                                                        {
                                                                                                                                                                                                                            tmp___75 = strcmp((const char*)color, "GreenYellow");
                                                                                                                                                                                                                        }
                                                                                                                                                                                                                        if (tmp___75 == 0){
                                                                                                                                                                                                                            n = 60;
                                                                                                                                                                                                                        }else{
                                                                                                                                                                                                                            {
                                                                                                                                                                                                                                tmp___74 = strcmp((const char*)color, "HotMagenta");
                                                                                                                                                                                                                            }
                                                                                                                                                                                                                            if (tmp___74 == 0){
                                                                                                                                                                                                                                n = 61;
                                                                                                                                                                                                                            }else{
                                                                                                                                                                                                                                {
                                                                                                                                                                                                                                    tmp___73 = strcmp((const char*)color, "InchWorm");
                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                if (tmp___73 == 0){
                                                                                                                                                                                                                                    n = 62;
                                                                                                                                                                                                                                }else{
                                                                                                                                                                                                                                    {
                                                                                                                                                                                                                                        tmp___72 = strcmp((const char*)color, "Indigo");
                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                    if (tmp___72 == 0){
                                                                                                                                                                                                                                        n = 63;
                                                                                                                                                                                                                                    }else{
                                                                                                                                                                                                                                        {
                                                                                                                                                                                                                                            tmp___71 = strcmp((const char*)color, "JazzberryJam");
                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                        if (tmp___71 == 0){
                                                                                                                                                                                                                                            n = 64;
                                                                                                                                                                                                                                        }else{
                                                                                                                                                                                                                                            {
                                                                                                                                                                                                                                                tmp___70 = strcmp((const char*)color, "JungleGreen");
                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                            if (tmp___70 == 0){
                                                                                                                                                                                                                                                n = 65;
                                                                                                                                                                                                                                            }else{
                                                                                                                                                                                                                                                {
                                                                                                                                                                                                                                                    tmp___69 = strcmp((const char*)color, "LaserLemon");
                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                if (tmp___69 == 0){
                                                                                                                                                                                                                                                    n = 66;
                                                                                                                                                                                                                                                }else{
                                                                                                                                                                                                                                                    {
                                                                                                                                                                                                                                                        tmp___68 = strcmp((const char*)color, "Lavender");
                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                    if (tmp___68 == 0){
                                                                                                                                                                                                                                                        n = 67;
                                                                                                                                                                                                                                                    }else{
                                                                                                                                                                                                                                                        {
                                                                                                                                                                                                                                                            tmp___67 = strcmp((const char*)color, "MacaroniandCheese");
                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                        if (tmp___67 == 0){
                                                                                                                                                                                                                                                            n = 68;
                                                                                                                                                                                                                                                        }else{
                                                                                                                                                                                                                                                            {
                                                                                                                                                                                                                                                                tmp___66 = strcmp((const char*)color, "Magenta");
                                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                                            if (tmp___66 == 0){
                                                                                                                                                                                                                                                                n = 69;
                                                                                                                                                                                                                                                            }else{
                                                                                                                                                                                                                                                                {
                                                                                                                                                                                                                                                                    tmp___65 = strcmp((const char*)color, "Mahogany");
                                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                                if (tmp___65 == 0){
                                                                                                                                                                                                                                                                    n = 70;
                                                                                                                                                                                                                                                                }else{
                                                                                                                                                                                                                                                                    {
                                                                                                                                                                                                                                                                        tmp___64 = strcmp((const char*)color, "Manatee");
                                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                                    if (tmp___64 == 0){
                                                                                                                                                                                                                                                                        n = 71;
                                                                                                                                                                                                                                                                    }else{
                                                                                                                                                                                                                                                                        {
                                                                                                                                                                                                                                                                            tmp___63 = strcmp((const char*)color, "MangoTango");
                                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                                        if (tmp___63 == 0){
                                                                                                                                                                                                                                                                            n = 72;
                                                                                                                                                                                                                                                                        }else{
                                                                                                                                                                                                                                                                            {
                                                                                                                                                                                                                                                                                tmp___62 = strcmp((const char*)color, "Maroon");
                                                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                                                            if (tmp___62 == 0){
                                                                                                                                                                                                                                                                                n = 73;
                                                                                                                                                                                                                                                                            }else{
                                                                                                                                                                                                                                                                                {
                                                                                                                                                                                                                                                                                    tmp___61 = strcmp((const char*)color, "Mauvelous");
                                                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                                                if (tmp___61 == 0){
                                                                                                                                                                                                                                                                                    n = 74;
                                                                                                                                                                                                                                                                                }else{
                                                                                                                                                                                                                                                                                    {
                                                                                                                                                                                                                                                                                        tmp___60 = strcmp((const char*)color, "Melon");
                                                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                                                    if (tmp___60 == 0){
                                                                                                                                                                                                                                                                                        n = 75;
                                                                                                                                                                                                                                                                                    }else{
                                                                                                                                                                                                                                                                                        {
                                                                                                                                                                                                                                                                                            tmp___59 = strcmp((const char*)color, "MidnightBlue");
                                                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                                                        if (tmp___59 == 0){
                                                                                                                                                                                                                                                                                            n = 76;
                                                                                                                                                                                                                                                                                        }else{
                                                                                                                                                                                                                                                                                            {
                                                                                                                                                                                                                                                                                                tmp___58 = strcmp((const char*)color, "MountainMeadow");
                                                                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                                                                            if (tmp___58 == 0){
                                                                                                                                                                                                                                                                                                n = 77;
                                                                                                                                                                                                                                                                                            }else{
                                                                                                                                                                                                                                                                                                {
                                                                                                                                                                                                                                                                                                    tmp___57 = strcmp((const char*)color, "NavyBlue");
                                                                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                                                                if (tmp___57 == 0){
                                                                                                                                                                                                                                                                                                    n = 78;
                                                                                                                                                                                                                                                                                                }else{
                                                                                                                                                                                                                                                                                                    {
                                                                                                                                                                                                                                                                                                        tmp___56 = strcmp((const char*)color, "NeonCarrot");
                                                                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                                                                    if (tmp___56 == 0){
                                                                                                                                                                                                                                                                                                        n = 79;
                                                                                                                                                                                                                                                                                                    }else{
                                                                                                                                                                                                                                                                                                        {
                                                                                                                                                                                                                                                                                                            tmp___55 = strcmp((const char*)color, "OliveGreen");
                                                                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                                                                        if (tmp___55 == 0){
                                                                                                                                                                                                                                                                                                            n = 80;
                                                                                                                                                                                                                                                                                                        }else{
                                                                                                                                                                                                                                                                                                            {
                                                                                                                                                                                                                                                                                                                tmp___54 = strcmp((const char*)color, "Orange");
                                                                                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                                                                                            if (tmp___54 == 0){
                                                                                                                                                                                                                                                                                                                n = 81;
                                                                                                                                                                                                                                                                                                            }else{
                                                                                                                                                                                                                                                                                                                {
                                                                                                                                                                                                                                                                                                                    tmp___53 = strcmp((const char*)color, "Orchid");
                                                                                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                                                                                if (tmp___53 == 0){
                                                                                                                                                                                                                                                                                                                    n = 82;
                                                                                                                                                                                                                                                                                                                }else{
                                                                                                                                                                                                                                                                                                                    {
                                                                                                                                                                                                                                                                                                                        tmp___52 = strcmp((const char*)color, "OuterSpace");
                                                                                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                                                                                    if (tmp___52 == 0){
                                                                                                                                                                                                                                                                                                                        n = 83;
                                                                                                                                                                                                                                                                                                                    }else{
                                                                                                                                                                                                                                                                                                                        {
                                                                                                                                                                                                                                                                                                                            tmp___51 = strcmp((const char*)color, "OutrageousOrange");
                                                                                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                                                                                        if (tmp___51 == 0){
                                                                                                                                                                                                                                                                                                                            n = 84;
                                                                                                                                                                                                                                                                                                                        }else{
                                                                                                                                                                                                                                                                                                                            {
                                                                                                                                                                                                                                                                                                                                tmp___50 = strcmp((const char*)color, "PacificBlue");
                                                                                                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                                                                                                            if (tmp___50 == 0){
                                                                                                                                                                                                                                                                                                                                n = 85;
                                                                                                                                                                                                                                                                                                                            }else{
                                                                                                                                                                                                                                                                                                                                {
                                                                                                                                                                                                                                                                                                                                    tmp___49 = strcmp((const char*)color, "Peach");
                                                                                                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                                                                                                if (tmp___49 == 0){
                                                                                                                                                                                                                                                                                                                                    n = 86;
                                                                                                                                                                                                                                                                                                                                }else{
                                                                                                                                                                                                                                                                                                                                    {
                                                                                                                                                                                                                                                                                                                                        tmp___48 = strcmp((const char*)color, "Periwinkle");
                                                                                                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                                                                                                    if (tmp___48 == 0){
                                                                                                                                                                                                                                                                                                                                        n = 87;
                                                                                                                                                                                                                                                                                                                                    }else{
                                                                                                                                                                                                                                                                                                                                        {
                                                                                                                                                                                                                                                                                                                                            tmp___47 = strcmp((const char*)color, "PiggyPink");
                                                                                                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                                                                                                        if (tmp___47 == 0){
                                                                                                                                                                                                                                                                                                                                            n = 88;
                                                                                                                                                                                                                                                                                                                                        }else{
                                                                                                                                                                                                                                                                                                                                            {
                                                                                                                                                                                                                                                                                                                                                tmp___46 = strcmp((const char*)color, "PineGreen");
                                                                                                                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                                                                                                                            if (tmp___46 == 0){
                                                                                                                                                                                                                                                                                                                                                n = 89;
                                                                                                                                                                                                                                                                                                                                            }else{
                                                                                                                                                                                                                                                                                                                                                {
                                                                                                                                                                                                                                                                                                                                                    tmp___45 = strcmp((const char*)color, "PinkFlamingo");
                                                                                                                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                                                                                                                if (tmp___45 == 0){
                                                                                                                                                                                                                                                                                                                                                    n = 90;
                                                                                                                                                                                                                                                                                                                                                }else{
                                                                                                                                                                                                                                                                                                                                                    {
                                                                                                                                                                                                                                                                                                                                                        tmp___44 = strcmp((const char*)color, "PinkSherbet");
                                                                                                                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                                                                                                                    if (tmp___44 == 0){
                                                                                                                                                                                                                                                                                                                                                        n = 91;
                                                                                                                                                                                                                                                                                                                                                    }else{
                                                                                                                                                                                                                                                                                                                                                        {
                                                                                                                                                                                                                                                                                                                                                            tmp___43 = strcmp((const char*)color, "Plum");
                                                                                                                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                                                                                                                        if (tmp___43 == 0){
                                                                                                                                                                                                                                                                                                                                                            n = 92;
                                                                                                                                                                                                                                                                                                                                                        }else{
                                                                                                                                                                                                                                                                                                                                                            {
                                                                                                                                                                                                                                                                                                                                                                tmp___42 = strcmp((const char*)color, "PurpleHeart");
                                                                                                                                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                                                                                                                                            if (tmp___42 == 0){
                                                                                                                                                                                                                                                                                                                                                                n = 93;
                                                                                                                                                                                                                                                                                                                                                            }else{
                                                                                                                                                                                                                                                                                                                                                                {
                                                                                                                                                                                                                                                                                                                                                                    tmp___41 = strcmp((const char*)color, "PurpleMountains\325Majesty");
                                                                                                                                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                                                                                                                                if (tmp___41 == 0){
                                                                                                                                                                                                                                                                                                                                                                    n = 94;
                                                                                                                                                                                                                                                                                                                                                                }else{
                                                                                                                                                                                                                                                                                                                                                                    {
                                                                                                                                                                                                                                                                                                                                                                        tmp___40 = strcmp((const char*)color, "PurplePizzazz");
                                                                                                                                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                                                                                                                                    if (tmp___40 == 0){
                                                                                                                                                                                                                                                                                                                                                                        n = 95;
                                                                                                                                                                                                                                                                                                                                                                    }else{
                                                                                                                                                                                                                                                                                                                                                                        {
                                                                                                                                                                                                                                                                                                                                                                            tmp___39 = strcmp((const char*)color, "RadicalRed");
                                                                                                                                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                                                                                                                                        if (tmp___39 == 0){
                                                                                                                                                                                                                                                                                                                                                                            n = 96;
                                                                                                                                                                                                                                                                                                                                                                        }else{
                                                                                                                                                                                                                                                                                                                                                                            {
                                                                                                                                                                                                                                                                                                                                                                                tmp___38 = strcmp((const char*)color, "RawSienna");
                                                                                                                                                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                                                                                                                                                            if (tmp___38 == 0){
                                                                                                                                                                                                                                                                                                                                                                                n = 97;
                                                                                                                                                                                                                                                                                                                                                                            }else{
                                                                                                                                                                                                                                                                                                                                                                                {
                                                                                                                                                                                                                                                                                                                                                                                    tmp___37 = strcmp((const char*)color, "RazzleDazzleRose");
                                                                                                                                                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                                                                                                                                                if (tmp___37 == 0){
                                                                                                                                                                                                                                                                                                                                                                                    n = 98;
                                                                                                                                                                                                                                                                                                                                                                                }else{
                                                                                                                                                                                                                                                                                                                                                                                    {
                                                                                                                                                                                                                                                                                                                                                                                        tmp___36 = strcmp((const char*)color, "Razzmatazz");
                                                                                                                                                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                                                                                                                                                    if (tmp___36 == 0){
                                                                                                                                                                                                                                                                                                                                                                                        n = 99;
                                                                                                                                                                                                                                                                                                                                                                                    }else{
                                                                                                                                                                                                                                                                                                                                                                                        {
                                                                                                                                                                                                                                                                                                                                                                                            tmp___35 = strcmp((const char*)color, "Red");
                                                                                                                                                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                                                                                                                                                        if (tmp___35 == 0){
                                                                                                                                                                                                                                                                                                                                                                                            n = 100;
                                                                                                                                                                                                                                                                                                                                                                                        }else{
                                                                                                                                                                                                                                                                                                                                                                                            {
                                                                                                                                                                                                                                                                                                                                                                                                tmp___34 = strcmp((const char*)color, "RedOrange");
                                                                                                                                                                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                                                                                                                                                                            if (tmp___34 == 0){
                                                                                                                                                                                                                                                                                                                                                                                                n = 101;
                                                                                                                                                                                                                                                                                                                                                                                            }else{
                                                                                                                                                                                                                                                                                                                                                                                                {
                                                                                                                                                                                                                                                                                                                                                                                                    tmp___33 = strcmp((const char*)color, "RedViolet");
                                                                                                                                                                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                                                                                                                                                                if (tmp___33 == 0){
                                                                                                                                                                                                                                                                                                                                                                                                    n = 102;
                                                                                                                                                                                                                                                                                                                                                                                                }else{
                                                                                                                                                                                                                                                                                                                                                                                                    {
                                                                                                                                                                                                                                                                                                                                                                                                        tmp___32 = strcmp((const char*)color, "RobinEggBlue");
                                                                                                                                                                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                                                                                                                                                                    if (tmp___32 == 0){
                                                                                                                                                                                                                                                                                                                                                                                                        n = 103;
                                                                                                                                                                                                                                                                                                                                                                                                    }else{
                                                                                                                                                                                                                                                                                                                                                                                                        {
                                                                                                                                                                                                                                                                                                                                                                                                            tmp___31 = strcmp((const char*)color, "RoyalPurple");
                                                                                                                                                                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                                                                                                                                                                        if (tmp___31 == 0){
                                                                                                                                                                                                                                                                                                                                                                                                            n = 104;
                                                                                                                                                                                                                                                                                                                                                                                                        }else{
                                                                                                                                                                                                                                                                                                                                                                                                            {
                                                                                                                                                                                                                                                                                                                                                                                                                tmp___30 = strcmp((const char*)color, "Salmon");
                                                                                                                                                                                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                                                                                                                                                                                            if (tmp___30 == 0){
                                                                                                                                                                                                                                                                                                                                                                                                                n = 105;
                                                                                                                                                                                                                                                                                                                                                                                                            }else{
                                                                                                                                                                                                                                                                                                                                                                                                                {
                                                                                                                                                                                                                                                                                                                                                                                                                    tmp___29 = strcmp((const char*)color, "Scarlet");
                                                                                                                                                                                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                                                                                                                                                                                if (tmp___29 == 0){
                                                                                                                                                                                                                                                                                                                                                                                                                    n = 106;
                                                                                                                                                                                                                                                                                                                                                                                                                }else{
                                                                                                                                                                                                                                                                                                                                                                                                                    {
                                                                                                                                                                                                                                                                                                                                                                                                                        tmp___28 = strcmp((const char*)color, "ScreaminGreen");
                                                                                                                                                                                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                                                                                                                                                                                    if (tmp___28 == 0){
                                                                                                                                                                                                                                                                                                                                                                                                                        n = 107;
                                                                                                                                                                                                                                                                                                                                                                                                                    }else{
                                                                                                                                                                                                                                                                                                                                                                                                                        {
                                                                                                                                                                                                                                                                                                                                                                                                                            tmp___27 = strcmp((const char*)color, "SeaGreen");
                                                                                                                                                                                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                                                                                                                                                                                        if (tmp___27 == 0){
                                                                                                                                                                                                                                                                                                                                                                                                                            n = 108;
                                                                                                                                                                                                                                                                                                                                                                                                                        }else{
                                                                                                                                                                                                                                                                                                                                                                                                                            {
                                                                                                                                                                                                                                                                                                                                                                                                                                tmp___26 = strcmp((const char*)color, "Sepia");
                                                                                                                                                                                                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                                                                                                                                                                                                            if (tmp___26 == 0){
                                                                                                                                                                                                                                                                                                                                                                                                                                n = 109;
                                                                                                                                                                                                                                                                                                                                                                                                                            }else{
                                                                                                                                                                                                                                                                                                                                                                                                                                {
                                                                                                                                                                                                                                                                                                                                                                                                                                    tmp___25 = strcmp((const char*)color, "Shadow");
                                                                                                                                                                                                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                                                                                                                                                                                                if (tmp___25 == 0){
                                                                                                                                                                                                                                                                                                                                                                                                                                    n = 110;
                                                                                                                                                                                                                                                                                                                                                                                                                                }else{
                                                                                                                                                                                                                                                                                                                                                                                                                                    {
                                                                                                                                                                                                                                                                                                                                                                                                                                        tmp___24 = strcmp((const char*)color, "Shamrock");
                                                                                                                                                                                                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                                                                                                                                                                                                    if (tmp___24 == 0){
                                                                                                                                                                                                                                                                                                                                                                                                                                        n = 111;
                                                                                                                                                                                                                                                                                                                                                                                                                                    }else{
                                                                                                                                                                                                                                                                                                                                                                                                                                        {
                                                                                                                                                                                                                                                                                                                                                                                                                                            tmp___23 = strcmp((const char*)color, "ShockingPink");
                                                                                                                                                                                                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                                                                                                                                                                                                        if (tmp___23 == 0){
                                                                                                                                                                                                                                                                                                                                                                                                                                            n = 112;
                                                                                                                                                                                                                                                                                                                                                                                                                                        }else{
                                                                                                                                                                                                                                                                                                                                                                                                                                            {
                                                                                                                                                                                                                                                                                                                                                                                                                                                tmp___22 = strcmp((const char*)color, "Silver");
                                                                                                                                                                                                                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                                                                                                                                                                                                                            if (tmp___22 == 0){
                                                                                                                                                                                                                                                                                                                                                                                                                                                n = 113;
                                                                                                                                                                                                                                                                                                                                                                                                                                            }else{
                                                                                                                                                                                                                                                                                                                                                                                                                                                {
                                                                                                                                                                                                                                                                                                                                                                                                                                                    tmp___21 = strcmp((const char*)color, "SkyBlue");
                                                                                                                                                                                                                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                                                                                                                                                                                                                if (tmp___21 == 0){
                                                                                                                                                                                                                                                                                                                                                                                                                                                    n = 114;
                                                                                                                                                                                                                                                                                                                                                                                                                                                }else{
                                                                                                                                                                                                                                                                                                                                                                                                                                                    {
                                                                                                                                                                                                                                                                                                                                                                                                                                                        tmp___20 = strcmp((const char*)color, "SpringGreen");
                                                                                                                                                                                                                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                                                                                                                                                                                                                    if (tmp___20 == 0){
                                                                                                                                                                                                                                                                                                                                                                                                                                                        n = 115;
                                                                                                                                                                                                                                                                                                                                                                                                                                                    }else{
                                                                                                                                                                                                                                                                                                                                                                                                                                                        {
                                                                                                                                                                                                                                                                                                                                                                                                                                                            tmp___19 = strcmp((const char*)color, "Sunglow");
                                                                                                                                                                                                                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                                                                                                                                                                                                                        if (tmp___19 == 0){
                                                                                                                                                                                                                                                                                                                                                                                                                                                            n = 116;
                                                                                                                                                                                                                                                                                                                                                                                                                                                        }else{
                                                                                                                                                                                                                                                                                                                                                                                                                                                            {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                tmp___18 = strcmp((const char*)color, "SunsetOrange");
                                                                                                                                                                                                                                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                                                                                                                                                                                                                                            if (tmp___18 == 0){
                                                                                                                                                                                                                                                                                                                                                                                                                                                                n = 117;
                                                                                                                                                                                                                                                                                                                                                                                                                                                            }else{
                                                                                                                                                                                                                                                                                                                                                                                                                                                                {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                    tmp___17 = strcmp((const char*)color, "Tan");
                                                                                                                                                                                                                                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                if (tmp___17 == 0){
                                                                                                                                                                                                                                                                                                                                                                                                                                                                    n = 118;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                }else{
                                                                                                                                                                                                                                                                                                                                                                                                                                                                    {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                        tmp___16 = strcmp((const char*)color, "TickleMePink");
                                                                                                                                                                                                                                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                    if (tmp___16 == 0){
                                                                                                                                                                                                                                                                                                                                                                                                                                                                        n = 119;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                    }else{
                                                                                                                                                                                                                                                                                                                                                                                                                                                                        {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                            tmp___15 = strcmp((const char*)color, "Timberwolf");
                                                                                                                                                                                                                                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                        if (tmp___15 == 0){
                                                                                                                                                                                                                                                                                                                                                                                                                                                                            n = 120;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                        }else{
                                                                                                                                                                                                                                                                                                                                                                                                                                                                            {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                tmp___14 = strcmp((const char*)color, "TropicalRainForest");
                                                                                                                                                                                                                                                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                            if (tmp___14 == 0){
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                n = 121;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                            }else{
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    tmp___13 = strcmp((const char*)color, "Tumbleweed");
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                if (tmp___13 == 0){
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    n = 122;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                }else{
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        tmp___12 = strcmp((const char*)color, "TurquoiseBlue");
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    if (tmp___12 == 0){
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        n = 123;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    }else{
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            tmp___11 = strcmp((const char*)color, "UnmellowYellow");
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        if (tmp___11 == 0){
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            n = 124;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        }else{
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                tmp___10 = strcmp((const char*)color, "Violet(Purple)");
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            if (tmp___10 == 0){
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                n = 125;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            }else{
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    tmp___9 = strcmp((const char*)color, "VioletRed");
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                if (tmp___9 == 0){
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    n = 126;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                }else{
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        tmp___8 = strcmp((const char*)color, "VividTangerine");
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    if (tmp___8 == 0){
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        n = 127;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    }else{
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            tmp___7 = strcmp((const char*)color, "VividViolet");
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        if (tmp___7 == 0){
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            n = 128;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        }else{
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                tmp___6 = strcmp((const char*)color, "White");
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            if (tmp___6 == 0){
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                n = 129;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            }else{
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    tmp___5 = strcmp((const char*)color, "WildBlueYonder");
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                if (tmp___5 == 0){
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    n = 130;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                }else{
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        tmp___4 = strcmp((const char*)color, "WildStrawberry");
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    if (tmp___4 == 0){
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        n = 131;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    }else{
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            tmp___3 = strcmp((const char*)color, "WildWatermelon");
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        if (tmp___3 == 0){
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            n = 132;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        }else{
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                tmp___2 = strcmp((const char*)color, "Wisteria");
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            if (tmp___2 == 0){
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                n = 133;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            }else{
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    tmp___1 = strcmp((const char*)color, "Yellow");
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                if (tmp___1 == 0){
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    n = 134;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                }else{
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        tmp___0 = strcmp((const char*)color, "YellowGreen");
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    if (tmp___0 == 0){
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        n = 135;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    }else{
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        {
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            tmp = strcmp((const char*)color, "YellowOrange");
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        if (tmp == 0){
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            n = 136;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                                }
                                                                                                                                                                                                                                            }
                                                                                                                                                                                                                                        }
                                                                                                                                                                                                                                    }
                                                                                                                                                                                                                                }
                                                                                                                                                                                                                            }
                                                                                                                                                                                                                        }
                                                                                                                                                                                                                    }
                                                                                                                                                                                                                }
                                                                                                                                                                                                            }
                                                                                                                                                                                                        }
                                                                                                                                                                                                    }
                                                                                                                                                                                                }
                                                                                                                                                                                            }
                                                                                                                                                                                        }
                                                                                                                                                                                    }
                                                                                                                                                                                }
                                                                                                                                                                            }
                                                                                                                                                                        }
                                                                                                                                                                    }
                                                                                                                                                                }
                                                                                                                                                            }
                                                                                                                                                        }
                                                                                                                                                    }
                                                                                                                                                }
                                                                                                                                            }
                                                                                                                                        }
                                                                                                                                    }
                                                                                                                                }
                                                                                                                            }
                                                                                                                        }
                                                                                                                    }
                                                                                                                }
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        return (n);
    }
}

void CmdTextColor(int code)
{
    char* color;
    char* text;
    char* color1;
    char* text1;
    int n;
    {
        {
            diagnostics(4, (char*)"Entering CmdTextColor");
            color1 = getBraceParam();
            color = strdup_noendblanks((const char*)color1);
            n = NumForColor(color);
            free((void*)color1);
            free((void*)color);
        }
        if (code){
            {
                text1 = getBraceParam();
                text = strdup_noendblanks((const char*)text1);
                fprintRTF((char*)"{");
            }
            if (n > 0){
                {
                    fprintRTF((char*)"\\cf%d ", n);
                }
            }
            {
                ConvertString((const char*)text);
                fprintRTF((char*)"}");
                free((void*)text);
                free((void*)text1);
            }
        }else
            if (n > 0){
                {
                    fprintRTF((char*)"\\cf%d ", n);
                }
            }

        return;
    }
}

void CmdLap(int code)
{
    char* s;
    char* tmp;
    {
        {
            tmp = getBraceParam();
            s = tmp;
            ConvertString((const char*)s);
            free((void*)s);
        }
        return;
    }
}

int PopLevels(void);
void myprintStack(void);
static int stack[10000];
static int top = 0;
int BraceLevel = 0;
int BasicPush(int lev, int brack);
int BasicPop(int* lev, int* brack);
int getStackRecursionLevel(void);

void myprintStack(void)
{
    int i;
    int lev;
    int brack;
    {
        {
            diagnostics(1, (char*)"\nStack Status top=%d", top);
            i = 0;
        }
        {
            while (1){
                while_continue:
                ;
                if (!(2 * i < top)){
                    goto while_break;
                }
                {
                    lev = stack[2 * i + 1];
                    brack = stack[2 * i + 2];
                    i++;
                    diagnostics(1, (char*)" #%d lev=%d bracket=%d", i, lev, brack);
                }
            }
            while_break:
            ;
        }
        return;
    }
}

void InitializeStack(void)
{
    {
        {
            BraceLevel = 0;
            RecursionLevel = 1;
            PushLevels();
            BraceLevel = 1;
        }
        return;
    }
}

int BasicPush(int lev, int brack)
{
    {
        {
            diagnostics(6, (char*)"pushing rec=%d and bra=%d on  stack", lev, brack);
            top++;
            stack[top] = lev;
            top++;
            stack[top] = brack;
        }
        if (top >= 10000){
            {
                diagnostics(0, (char*)"Nesting too deep.  latex2rtf bug, if file TeXs properly");
            }
        }
        return (top);
    }
}

int BasicPop(int* lev, int* brack)
{
    {
        *brack = stack[top];
        top--;
        *lev = stack[top];
        top--;
        if (top < 0){
            {
                diagnostics(0, (char*)"Nesting problem.  latex2rtf bug, if file TeXs properly");
            }
        }
        return (top);
    }
}

void PushLevels(void)
{
    {
        {
            diagnostics(6, (char*)"PushLevels");
            CleanStack();
            BasicPush(RecursionLevel, BraceLevel);
        }
        return;
    }
}

int PopLevels(void)
{
    int level;
    {
        {
            BasicPop(&level, &BraceLevel);
        }
        return (level);
    }
}

int getStackRecursionLevel(void)
{
    int PopLevel;
    int PopBrack;
    int PPopLevel;
    int tmp;
    {
        {
            PPopLevel = RecursionLevel;
            BasicPop(&PopLevel, &PopBrack);
        }
        {
            while (1){
                while_continue:
                ;
                {
                    tmp = BasicPop(&PopLevel, &PopBrack);
                }
                if (!(tmp >= 0)){
                    goto while_break;
                }
                if (PopBrack < BraceLevel){
                    goto while_break;
                }
                PPopLevel = PopLevel;
            }
            while_break:
            ;
        }
        {
            BasicPush(PopLevel, PopBrack);
            BasicPush(PPopLevel, BraceLevel);
        }
        return (PPopLevel);
    }
}

void CleanStack(void)
{
    int PopLevel;
    int PopBrack;
    int PPopLevel;
    int PPopBrack;
    {
        {
            diagnostics(6, (char*)"Cleaning Stack");
        }
        if (top < 4){
            return;
        }
        {
            BasicPop(&PPopLevel, &PPopBrack);
            BasicPop(&PopLevel, &PopBrack);
        }
        {
            while (1){
                while_continue:
                ;
                if (PPopLevel == PopLevel){
                    if (PPopBrack == PopBrack){
                        if (!(top > 0)){
                            goto while_break;
                        }
                    }else{
                        goto while_break;
                    }
                }else{
                    goto while_break;
                }
                {
                    BasicPop(&PopLevel, &PopBrack);
                }
            }
            while_break:
            ;
        }
        {
            BasicPush(PopLevel, PopBrack);
        }
        if (PPopLevel != PopLevel){
            {
                BasicPush(PPopLevel, PPopBrack);
            }
        }else
            if (PPopBrack != PopBrack){
                {
                    BasicPush(PPopLevel, PPopBrack);
                }
            }

        return;
    }
}

void PushBrace(void)
{
    {
        {
            BasicPush(RecursionLevel, BraceLevel);
            PushFontSettings();
            BraceLevel++;
        }
        return;
    }
}

int PopBrace(void)
{
    int PopLevel;
    int PopBrack;
    int PPopLevel;
    {
        {
            diagnostics(6, (char*)"Popping Brace Level");
            BraceLevel--;
            PopFontSettings();
            PPopLevel = RecursionLevel;
            BasicPop(&PopLevel, &PopBrack);
        }
        {
            while (1){
                while_continue:
                ;
                if (!(PopBrack >= BraceLevel)){
                    goto while_break;
                }
                if (PopLevel < PPopLevel){
                    PPopLevel = PopLevel;
                }
                {
                    BasicPop(&PopLevel, &PopBrack);
                }
            }
            while_break:
            ;
        }
        {
            BasicPush(PopLevel, PopBrack);
            BasicPush(PPopLevel, BraceLevel);
        }
        return (PPopLevel);
    }
}

void CmdFontSize(int code);
void CmdEmphasize(int code);
void CmdUnderline(int code);
void CmdTextNormal(int code);
static int iEnvCount = 0;
static CommandArray* Environments[100];
static int g_par_indent_array[100];
static int g_left_indent_array[100];
static int g_right_indent_array[100];
static char g_align_array[100];
static CommandArray commands[294] = {{(char*)"begin", &CmdBeginEnd, 1}, {(char*)"end", &CmdBeginEnd, 2}, {(char*)"today", &CmdToday, 0}, {(char*)"footnote", &CmdFootNote, 1}, {(char*)"endnote", &CmdFootNote, 4}, {(char*)"rmfamily", &CmdFontFamily, 1}, {(char*)"rm", &CmdFontFamily, 2}, {(char*)"mathrm", &CmdFontFamily, 3}, {(char*)"textrm", &CmdFontFamily, 3}, {(char*)"sffamily", &CmdFontFamily, 5}, {(char*)"sf", &CmdFontFamily, 6}, {(char*)"mathsf", &CmdFontFamily, 7}, {(char*)"textsf", &CmdFontFamily, 7}, {(char*)"ttfamily", &CmdFontFamily, 9}, {(char*)"tt", &CmdFontFamily, 10}, {(char*)"mathtt", &CmdFontFamily, 11}, {(char*)"texttt", &CmdFontFamily, 11}, {(char*)"cal", &CmdFontFamily, 14}, {(char*)"mathcal", &CmdFontFamily, 15}, {(char*)"bfseries", &CmdFontSeries, 5}, {(char*)"bf", &CmdFontSeries, 6}, {(char*)"textbf", &CmdFontSeries, 7}, {(char*)"mathbf", &CmdFontSeries, 7}, {(char*)"mdseries", &CmdFontSeries, 1}, {(char*)"textmd", &CmdFontSeries, 3}, {(char*)"mathmd", &CmdFontSeries, 3}, {(char*)"itshape", &CmdFontShape, 5}, {(char*)"it", &CmdFontShape, 6}, {(char*)"mit", &CmdFontShape, 6}, {(char*)"textit", &CmdFontShape, 7}, {(char*)"mathit", &CmdFontShape, 7}, {(char*)"upshape", &CmdFontShape, 13}, {(char*)"textup", &CmdFontShape, 15}, {(char*)"mathup", &CmdFontShape, 15}, {(char*)"scfamily", &CmdFontShape, 9}, {(char*)"scshape", &CmdFontShape, 9}, {(char*)"sc", &CmdFontShape, 10}, {(char*)"textsc", &CmdFontShape, 11}, {(char*)"mathsc", &CmdFontShape, 11}, {(char*)"slshape", &CmdFontShape, 1}, {(char*)"sl", &CmdFontShape, 2}, {(char*)"textsl", &CmdFontShape, 3}, {(char*)"mathsl", &CmdFontShape, 3}, {(char*)"tiny", &CmdFontSize, 10}, {(char*)"ssmall", &CmdFontSize, 12}, {(char*)"scriptsize", &CmdFontSize, 14}, {(char*)"footnotesize", &CmdFontSize, 16}, {(char*)"enotesize", &CmdFontSize, 16}, {(char*)"small", &CmdFontSize, 18}, {(char*)"normalsize", &CmdFontSize, 20}, {(char*)"large", &CmdFontSize, 24}, {(char*)"Large", &CmdFontSize, 28}, {(char*)"LARGE", &CmdFontSize, 34}, {(char*)"huge", &CmdFontSize, 40}, {(char*)"Huge", &CmdFontSize, 50}, {(char*)"HUGE", &CmdFontSize, 60}, {(char*)"em", &CmdEmphasize, 2}, {(char*)"emph", &CmdEmphasize, 3}, {(char*)"underline", &CmdUnderline, 0}, {(char*)"underbar", &CmdUnderline, 0}, {(char*)"textnormal", &CmdTextNormal, 3}, {(char*)"normalfont", &CmdTextNormal, 3}, {(char*)"mathnormal", &CmdTextNormal, 4}, {(char*)"textfont", &CmdTextFont, 0}, {(char*)"the", &CmdThe, 0}, {(char*)"raggedright", &CmdAlign, 6}, {(char*)"centerline", &CmdAlign, 4}, {(char*)"vcenter", &CmdAlign, 5}, {(char*)"latex", &CmdLogo, 2}, {(char*)"LaTeX", &CmdLogo, 2}, {(char*)"LaTeXe", &CmdLogo, 5}, {(char*)"TeX", &CmdLogo, 1}, {(char*)"SLiTeX", &CmdLogo, 3}, {(char*)"BibTeX", &CmdLogo, 4}, {(char*)"AmSTeX", &CmdLogo, 6}, {(char*)"AmSLaTeX", &CmdLogo, 7}, {(char*)"LyX", &CmdLogo, 8}, {(char*)"lower", &CmdSubscript, 2}, {(char*)"kern", &CmdKern, 0}, {(char*)"hat", &CmdHatChar, 0}, {(char*)"check", &CmdCaronChar, 0}, {(char*)"breve", &CmdBreveChar, 0}, {(char*)"acute", &CmdAcuteChar, 0}, {(char*)"grave", &CmdGraveChar, 0}, {(char*)"tilde", &CmdTildeChar, 0}, {(char*)"bar", &CmdMacronChar, 0}, {(char*)"vec", &CmdVecChar, 0}, {(char*)"overrightarrow", &CmdVecChar, 0}, {(char*)"dot", &CmdDotChar, 0}, {(char*)"ddot", &CmdUmlauteChar, 0}, {(char*)"\"", &CmdUmlauteChar, 0}, {(char*)"u", &CmdBreveChar, 0}, {(char*)"d", &CmdUnderdotChar, 0}, {(char*)"v", &CmdCaronChar, 0}, {(char*)"r", &CmdRingChar, 0}, {(char*)"b", &CmdUnderbarChar, 0}, {(char*)"c", &CmdCedillaChar, 0}, {(char*)"i", &CmdDotlessChar, 0}, {(char*)"j", &CmdDotlessChar, 1}, {(char*)"H", &CmdDoubleAcuteChar, 0}, {(char*)"l", &CmdUnicodeChar, 323}, {(char*)"L", &CmdUnicodeChar, 322}, {(char*)"part", &CmdSection, 1}, {(char*)"part*", &CmdSection, 11}, {(char*)"chapter", &CmdSection, 2}, {(char*)"chapter*", &CmdSection, 12}, {(char*)"section", &CmdSection, 3}, {(char*)"section*", &CmdSection, 13}, {(char*)"subsection", &CmdSection, 4}, {(char*)"subsection*", &CmdSection, 14}, {(char*)"subsubsection", &CmdSection, 5}, {(char*)"subsubsection*", &CmdSection, 15}, {(char*)"paragraph", &CmdSection, 6}, {(char*)"paragraph*", &CmdSection, 16}, {(char*)"subparagraph", &CmdSection, 7}, {(char*)"subparagraph*", &CmdSection, 17}, {(char*)"ldots", &CmdUnicodeChar, 8230}, {(char*)"dots", &CmdUnicodeChar, 8230}, {(char*)"dotfill", &CmdUnicodeChar, 8230}, {(char*)"textellipsis", &CmdUnicodeChar, 8230}, {(char*)"maketitle", &CmdMakeTitle, 0}, {(char*)"par", &CmdEndParagraph, 0}, {(char*)"noindent", &CmdIndent, 1}, {(char*)"indent", &CmdIndent, 3}, {(char*)"caption", &CmdCaption, 0}, {(char*)"appendix", &CmdAppendix, 0}, {(char*)"protect", &CmdIgnore, 0}, {(char*)"clearpage", &CmdNewPage, 1}, {(char*)"efloatseparator", &CmdNewPage, 1}, {(char*)"cleardoublepage", &CmdNewPage, 1}, {(char*)"newpage", &CmdNewPage, 2}, {(char*)"pagebreak", &CmdNewPage, 1}, {(char*)"mbox", &CmdBox, 3}, {(char*)"hbox", &CmdBox, 1}, {(char*)"vbox", &CmdBox, 2}, {(char*)"fbox", &CmdBox, 4}, {(char*)"parbox", &CmdBox, 5}, {(char*)"makebox", &CmdBox, 6}, {(char*)"framebox", &CmdBox, 7}, {(char*)"frenchspacing", &CmdIgnore, 0}, {(char*)"nonfrenchspacing", &CmdIgnore, 0}, {(char*)"include", &CmdIgnoreParameter, 1}, {(char*)"input", &CmdIgnoreParameter, 1}, {(char*)"verb", &CmdVerb, 1}, {(char*)"verb*", &CmdVerb, 2}, {(char*)"onecolumn", &CmdColumn, 1}, {(char*)"twocolumn", &CmdColumn, 2}, {(char*)"includegraphics", &CmdGraphics, 1}, {(char*)"epsffile", &CmdGraphics, 2}, {(char*)"epsfbox", &CmdGraphics, 3}, {(char*)"BoxedEPSF", &CmdGraphics, 4}, {(char*)"psfig", &CmdGraphics, 5}, {(char*)"includegraphics*", &CmdGraphics, 1}, {(char*)"moveleft", &CmdLength, 0}, {(char*)"moveright", &CmdLength, 0}, {(char*)"hsize", &CmdLength, 0}, {(char*)"letterspace", &CmdLength, 0}, {(char*)"footnotemark", &CmdIgnoreParameter, 10}, {(char*)"endnotemark", &CmdIgnoreParameter, 10}, {(char*)"label", &CmdLabel, 1}, {(char*)"ref", &CmdLabel, 3}, {(char*)"vref", &CmdLabel, 11}, {(char*)"eqref", &CmdLabel, 10}, {(char*)"pageref", &CmdLabel, 7}, {(char*)"nameref", &CmdLabel, 17}, {(char*)"cite", &CmdCite, 1}, {(char*)"onlinecite", &CmdCite, 1}, {(char*)"citeonline", &CmdCite, 1}, {(char*)"nobibliography", &CmdIgnoreParameter, 1}, {(char*)"bibliography", &CmdBibliography, 0}, {(char*)"bibitem", &CmdBibitem, 0}, {(char*)"bibentry", &CmdBibEntry, 0}, {(char*)"newblock", &CmdNewblock, 0}, {(char*)"newsavebox", &CmdIgnoreParameter, 1}, {(char*)"usebox", &CmdIgnoreParameter, 1}, {(char*)"subfigure", &CmdSubFigure, 0}, {(char*)"quad", &CmdQuad, 1}, {(char*)"qquad", &CmdQuad, 2}, {(char*)"textsuperscript", &CmdSuperscript, 1}, {(char*)"textsubscript", &CmdSubscript, 1}, {(char*)"hspace", &CmdIgnoreParameter, 1}, {(char*)"hspace*", &CmdIgnoreParameter, 1}, {(char*)"vspace", &CmdVspace, -1}, {(char*)"vspace*", &CmdVspace, -1}, {(char*)"vskip", &CmdVspace, 0}, {(char*)"smallskip", &CmdVspace, 1}, {(char*)"medskip", &CmdVspace, 2}, {(char*)"bigskip", &CmdVspace, 3}, {(char*)"addvspace", &CmdIgnoreParameter, 1}, {(char*)"addcontentsline", &CmdIgnoreParameter, 3}, {(char*)"addcontents", &CmdIgnoreParameter, 2}, {(char*)"stretch", &CmdIgnoreParameter, 1}, {(char*)"typeaout", &CmdIgnoreParameter, 1}, {(char*)"index", &CmdIndex, 0}, {(char*)"printindex", &CmdPrintIndex, 0}, {(char*)"indexentry", &CmdIgnoreParameter, 2}, {(char*)"glossary", &CmdIgnoreParameter, 1}, {(char*)"glossaryentry", &CmdIgnoreParameter, 2}, {(char*)"typeout", &CmdIgnoreParameter, 1}, {(char*)"Typein", &CmdIgnoreParameter, 11}, {(char*)"includeonly", &CmdIgnoreParameter, 1}, {(char*)"nocite", &CmdNoCite, 1}, {(char*)"stepcounter", &CmdIgnoreParameter, 1}, {(char*)"refstepcounter", &CmdIgnoreParameter, 1}, {(char*)"fnsymbol", &CmdIgnoreParameter, 1}, {(char*)"Alph", &CmdIgnoreParameter, 1}, {(char*)"alph", &CmdIgnoreParameter, 1}, {(char*)"Roman", &CmdIgnoreParameter, 1}, {(char*)"roman", &CmdIgnoreParameter, 1}, {(char*)"arabic", &CmdIgnoreParameter, 1}, {(char*)"newcount", &CmdIgnoreDef, 0}, {(char*)"output", &CmdIgnoreDef, 0}, {(char*)"value", &CmdCounter, 4}, {(char*)"sbox", &CmdIgnoreParameter, 2}, {(char*)"savebox", &CmdIgnoreParameter, 22}, {(char*)"rule", &CmdRule, 0}, {(char*)"raisebox", &CmdIgnoreParameter, 22}, {(char*)"newfont", &CmdIgnoreParameter, 2}, {(char*)"settowidth", &CmdIgnoreParameter, 2}, {(char*)"nopagebreak", &CmdIgnoreParameter, 10}, {(char*)"samepage", &CmdIgnore, 0}, {(char*)"expandafter", &CmdIgnore, 0}, {(char*)"long", &CmdIgnore, 0}, {(char*)"nobreak", &CmdIgnore, 0}, {(char*)"linebreak", &CmdIgnoreParameter, 10}, {(char*)"nolinebreak", &CmdIgnoreParameter, 10}, {(char*)"typein", &CmdIgnoreParameter, 11}, {(char*)"marginpar", &CmdIgnoreParameter, 11}, {(char*)"baselineskip", &Cmd_OptParam_Without_braces, 0}, {(char*)"psfrag", &CmdIgnoreParameter, 2}, {(char*)"lineskip", &Cmd_OptParam_Without_braces, 0}, {(char*)"vsize", &Cmd_OptParam_Without_braces, 0}, {(char*)"setbox", &Cmd_OptParam_Without_braces, 0}, {(char*)"thanks", &CmdFootNote, 3}, {(char*)"bibliographystyle", &CmdIgnoreParameter, 1}, {(char*)"let", &CmdIgnoreLet, 0}, {(char*)"multicolumn", &CmdMultiCol, 0}, {(char*)"ensuremath", &CmdEnsuremath, 0}, {(char*)"frac", &CmdFraction, 0}, {(char*)"dfrac", &CmdFraction, 0}, {(char*)"Frac", &CmdFraction, 0}, {(char*)"sqrt", &CmdRoot, 0}, {(char*)"lim", &CmdLim, 0}, {(char*)"limsup", &CmdLim, 1}, {(char*)"liminf", &CmdLim, 2}, {(char*)"int", &CmdIntegral, 0}, {(char*)"iint", &CmdIntegral, 3}, {(char*)"iiint", &CmdIntegral, 4}, {(char*)"sum", &CmdIntegral, 1}, {(char*)"prod", &CmdIntegral, 2}, {(char*)"left", &CmdLeftRight, 0}, {(char*)"right", &CmdLeftRight, 1}, {(char*)"stackrel", &CmdStackrel, 0}, {(char*)"matrix", &CmdMatrix, 0}, {(char*)"overline", &CmdOverLine, 0}, {(char*)"rightleftharpoons", &CmdArrows, 9}, {(char*)"psset", &CmdPsset, 0}, {(char*)"newpsstyle", &CmdNewPsStyle, 0}, {(char*)"nonumber", &CmdNonumber, 15}, {(char*)"notag", &CmdNonumber, 15}, {(char*)"char", &CmdSymbol, 0}, {(char*)"symbol", &CmdSymbol, 1}, {(char*)"rlap", &CmdLap, 0}, {(char*)"llap", &CmdLap, 1}, {(char*)"not", &CmdNot, 0}, {(char*)"url", &CmdHtml, 13}, {(char*)"urlstyle", &CmdHtml, 16}, {(char*)"htmladdnormallink", &CmdHtml, 8}, {(char*)"htmlref", &CmdHtml, 9}, {(char*)"nobreakspace", &CmdNonBreakSpace, 100}, {(char*)"thinspace", &CmdNonBreakSpace, 50}, {(char*)"abstract", &CmdAbstract, 1}, {(char*)"keywords", &CmdKeywords, 0}, {(char*)"endinput", &CmdEndInput, 0}, {(char*)"color", &CmdTextColor, 0}, {(char*)"textcolor", &CmdTextColor, 1}, {(char*)"tableofcontents", &CmdTableOfContents, 0}, {(char*)"listoffigures", &CmdListOf, 1}, {(char*)"listoftables", &CmdListOf, 2}, {(char*)"numberline", &CmdNumberLine, 0}, {(char*)"contentsline", &CmdContentsLine, 0}, {(char*)"centering", &CmdAlign, 7}, {(char*)"halign", &CmdHAlign, 0}, {(char*)"efloatseparator", &CmdIgnoreParameter, 0}, {(char*)"pagestyle", &CmdIgnoreParameter, 1}, {(char*)"pagenumbering", &CmdIgnoreParameter, 1}, {(char*)"markboth", &CmdIgnoreParameter, 2}, {(char*)"markright", &CmdIgnoreParameter, 1}, {(char*)"newlabel", &CmdNewLabel, 0}, {(char*)"newacro", &CmdAcrodef, 1}, {(char*)"newacroplural", &CmdAcrodef, 2}, {(char*)"harvardcite", &CmdAuxHarvardCite, 0}, {(char*)"bibcite", &CmdBibCite, 0}, {(char*)"", (void(*)(int))((void*)0), 0}};
static CommandArray PreambleCommands[98] = {{(char*)"documentclass", &CmdDocumentStyle, 0}, {(char*)"documentstyle", &CmdDocumentStyle, 0}, {(char*)"usepackage", &CmdUsepackage, 0}, {(char*)"RequirePackage", &CmdUsepackage, 0}, {(char*)"flushbottom", &CmdBottom, 0}, {(char*)"raggedbottom", &CmdBottom, 0}, {(char*)"addtolength", &CmdLength, 3}, {(char*)"setlength", &CmdLength, 2}, {(char*)"newlength", &CmdLength, 1}, {(char*)"newcounter", &CmdCounter, 1}, {(char*)"setcounter", &CmdCounter, 2}, {(char*)"addtocounter", &CmdCounter, 3}, {(char*)"cfoot", &CmdHeadFoot, 1}, {(char*)"rfoot", &CmdHeadFoot, 3}, {(char*)"lfoot", &CmdHeadFoot, 2}, {(char*)"chead", &CmdHeadFoot, 5}, {(char*)"rhead", &CmdHeadFoot, 6}, {(char*)"lhead", &CmdHeadFoot, 4}, {(char*)"fancyfoot", &CmdHeadFoot, 1}, {(char*)"fancyhead", &CmdHeadFoot, 5}, {(char*)"thepage", &CmdThePage, 0}, {(char*)"hyphenation", &CmdHyphenation, 0}, {(char*)"def", &CmdNewDef, 3}, {(char*)"newcommand", &CmdNewDef, 1}, {(char*)"providecommand", &CmdNewDef, 1}, {(char*)"DeclareRobustCommand", &CmdNewDef, 1}, {(char*)"DeclareRobustCommand*", &CmdNewDef, 1}, {(char*)"renewcommand", &CmdNewDef, 2}, {(char*)"newenvironment", &CmdNewEnvironment, 1}, {(char*)"renewenvironment", &CmdNewEnvironment, 2}, {(char*)"newtheorem", &CmdNewTheorem, 0}, {(char*)"renewtheorem", &CmdIgnoreParameter, 12}, {(char*)"pagestyle", &CmdIgnoreParameter, 1}, {(char*)"thispagestyle", &CmdIgnoreParameter, 1}, {(char*)"pagenumbering", &CmdIgnoreParameter, 1}, {(char*)"markboth", &CmdIgnoreParameter, 2}, {(char*)"markright", &CmdIgnoreParameter, 1}, {(char*)"makeindex", &CmdIgnoreParameter, 0}, {(char*)"hfil", &CmdHfill, 0}, {(char*)"hfill", &CmdHfill, 1}, {(char*)"makeglossary", &CmdIgnoreParameter, 0}, {(char*)"listoffiles", &CmdIgnoreParameter, 0}, {(char*)"nofiles", &CmdIgnoreParameter, 0}, {(char*)"makelabels", &CmdIgnoreParameter, 0}, {(char*)"hoffset", &CmdSetTexLength, 1}, {(char*)"voffset", &CmdSetTexLength, 2}, {(char*)"parindent", &CmdSetTexLength, 3}, {(char*)"parskip", &CmdSetTexLength, 4}, {(char*)"baselineskip", &CmdSetTexLength, 5}, {(char*)"topmargin", &CmdSetTexLength, 6}, {(char*)"textheight", &CmdSetTexLength, 7}, {(char*)"headheight", &CmdSetTexLength, 8}, {(char*)"headsep", &CmdSetTexLength, 9}, {(char*)"textwidth", &CmdSetTexLength, 10}, {(char*)"linewidth", &CmdSetTexLength, 13}, {(char*)"oddsidemargin", &CmdSetTexLength, 11}, {(char*)"evensidemargin", &CmdSetTexLength, 12}, {(char*)"footnotetext", &CmdFootNote, 2}, {(char*)"endnotetext", &CmdFootNote, 5}, {(char*)"include", &CmdInclude, 0}, {(char*)"input", &CmdInclude, 1}, {(char*)"nobreakspace", &CmdNonBreakSpace, 100}, {(char*)"signature", &CmdSignature, 0}, {(char*)"hline", &CmdHline, 0}, {(char*)"cline", &CmdHline, 1}, {(char*)"ifx", &CmdIf, 0}, {(char*)"ifpdf", &CmdIf, 0}, {(char*)"theendnotes", &CmdTheEndNotes, 0}, {(char*)"euro", &CmdEuro, 0}, {(char*)"EUR", &CmdEuro, 1}, {(char*)"celsius", &CmdDegreeCelsius, 0}, {(char*)"degreecelsius", &CmdDegreeCelsius, 0}, {(char*)"resizebox", &CmdResizeBox, 0}, {(char*)"resizebox*", &CmdResizeBox, 1}, {(char*)"geometry", &CmdGeometry, 0}, {(char*)"doublespacing", &CmdDoubleSpacing, 0}, {(char*)"verbositylevel", &CmdVerbosityLevel, 0}, {(char*)"iflatextortf", &CmdIflatextortf, 0}, {(char*)"latextortftrue", &CmdIgnore, 1}, {(char*)"latextortffalse", &CmdIgnore, 0}, {(char*)"newif", &CmdNewif, 0}, {(char*)"else", &CmdElse, 0}, {(char*)"fi", &CmdFi, 0}, {(char*)"title", &CmdTitle, 1}, {(char*)"author", &CmdTitle, 2}, {(char*)"and", &CmdAnd, 0}, {(char*)"date", &CmdTitle, 3}, {(char*)"affiliation", &CmdTitle, 5}, {(char*)"abstract", &CmdTitle, 6}, {(char*)"keywords", &CmdKeywords, 0}, {(char*)"acknowledgements", &CmdTitle, 7}, {(char*)"bibliographystyle", &CmdBibliographyStyle, 0}, {(char*)"bibstyle", &CmdBibStyle, 0}, {(char*)"extrasfrench", &CmdIgnoreParameter, 1}, {(char*)"AtEndDocument", &CmdIgnoreParameter, 1}, {(char*)"docnumber", &CmdIgnoreParameter, 1}, {(char*)"graphicspath", &CmdGraphicsPath, 0}, {(char*)"", (void(*)(int))((void*)0), 0}};
static CommandArray ItemizeCommands[2] = {{(char*)"item", &CmdItem, 3}, {(char*)"", (void(*)(int))((void*)0), 0}};
static CommandArray DescriptionCommands[2] = {{(char*)"item", &CmdItem, 5}, {(char*)"", (void(*)(int))((void*)0), 0}};
static CommandArray EnumerateCommands[2] = {{(char*)"item", &CmdItem, 4}, {(char*)"", (void(*)(int))((void*)0), 0}};
static CommandArray InparaenumCommands[2] = {{(char*)"item", &CmdItem, 6}, {(char*)"", (void(*)(int))((void*)0), 0}};
static CommandArray FigureCommands[3] = {{(char*)"caption", &CmdCaption, 0}, {(char*)"center", &CmdAlign, 1}, {(char*)"", (void(*)(int))((void*)0), 0}};
static CommandArray LetterCommands[8] = {{(char*)"opening", &CmdOpening, 0}, {(char*)"closing", &CmdClosing, 0}, {(char*)"address", &CmdAddress, 0}, {(char*)"signature", &CmdSignature, 0}, {(char*)"ps", &CmdPs, 1}, {(char*)"cc", &CmdPs, 2}, {(char*)"encl", &CmdPs, 3}, {(char*)"", (void(*)(int))((void*)0), 0}};
static CommandArray GermanModeCommands[6] = {{(char*)"ck", &GermanPrint, 1}, {(char*)"glqq", &GermanPrint, 2}, {(char*)"glq", &GermanPrint, 3}, {(char*)"grq", &GermanPrint, 4}, {(char*)"grqq", &GermanPrint, 5}, {(char*)"", (void(*)(int))((void*)0), 0}};
static CommandArray CzechModeCommands[2] = {{(char*)"uv", &CmdCzechAbbrev, 0}, {(char*)"", (void(*)(int))((void*)0), 0}};
static CommandArray FrenchModeCommands[32] = {{(char*)"ier", &CmdFrenchAbbrev, 1}, {(char*)"iere", &CmdFrenchAbbrev, 2}, {(char*)"iers", &CmdFrenchAbbrev, 3}, {(char*)"ieres", &CmdFrenchAbbrev, 4}, {(char*)"ieme", &CmdFrenchAbbrev, 5}, {(char*)"iemes", &CmdFrenchAbbrev, 6}, {(char*)"numero", &CmdFrenchAbbrev, 8}, {(char*)"numeros", &CmdFrenchAbbrev, 9}, {(char*)"Numero", &CmdFrenchAbbrev, 10}, {(char*)"Numeros", &CmdFrenchAbbrev, 11}, {(char*)"primo", &CmdFrenchAbbrev, 12}, {(char*)"secundo", &CmdFrenchAbbrev, 13}, {(char*)"tertio", &CmdFrenchAbbrev, 14}, {(char*)"quarto", &CmdFrenchAbbrev, 15}, {(char*)"inferieura", &CmdFrenchAbbrev, 17}, {(char*)"superieura", &CmdFrenchAbbrev, 18}, {(char*)"lq", &CmdFrenchAbbrev, 19}, {(char*)"rq", &CmdFrenchAbbrev, 20}, {(char*)"lqq", &CmdFrenchAbbrev, 21}, {(char*)"rqq", &CmdFrenchAbbrev, 22}, {(char*)"pointvirgule", &CmdFrenchAbbrev, 23}, {(char*)"pointexclamation", &CmdFrenchAbbrev, 24}, {(char*)"pointinterrogation", &CmdFrenchAbbrev, 25}, {(char*)"dittomark", &CmdFrenchAbbrev, 26}, {(char*)"deuxpoints", &CmdFrenchAbbrev, 27}, {(char*)"fup", &CmdFrenchAbbrev, 16}, {(char*)"up", &CmdFrenchAbbrev, 16}, {(char*)"LCS", &CmdFrenchAbbrev, 28}, {(char*)"FCS", &CmdFrenchAbbrev, 29}, {(char*)"og", &CmdFrenchAbbrev, 30}, {(char*)"fg", &CmdFrenchAbbrev, 31}, {(char*)"", (void(*)(int))((void*)0), 0}};
static CommandArray RussianModeCommands[99] = {{(char*)"cyr", &CmdFontEncoding, 27}, {(char*)"CYRYO", &CmdUnicodeChar, 1025}, {(char*)"CYRDJE", &CmdUnicodeChar, 1026}, {(char*)"CYRIE", &CmdUnicodeChar, 1028}, {(char*)"CYRDZE", &CmdUnicodeChar, 1029}, {(char*)"CYRII", &CmdUnicodeChar, 1030}, {(char*)"CYRYI", &CmdUnicodeChar, 1031}, {(char*)"CYRJE", &CmdUnicodeChar, 1032}, {(char*)"CYRLJE", &CmdUnicodeChar, 1033}, {(char*)"CYRNJE", &CmdUnicodeChar, 1034}, {(char*)"CYRTSHE", &CmdUnicodeChar, 1035}, {(char*)"CYRUSHRT", &CmdUnicodeChar, 1038}, {(char*)"CYRDZHE", &CmdUnicodeChar, 1039}, {(char*)"CYRA", &CmdUnicodeChar, 1040}, {(char*)"CYRB", &CmdUnicodeChar, 1041}, {(char*)"CYRV", &CmdUnicodeChar, 1042}, {(char*)"CYRG", &CmdUnicodeChar, 1043}, {(char*)"CYRD", &CmdUnicodeChar, 1044}, {(char*)"CYRE", &CmdUnicodeChar, 1045}, {(char*)"CYRZH", &CmdUnicodeChar, 1046}, {(char*)"CYRZ", &CmdUnicodeChar, 1047}, {(char*)"CYRI", &CmdUnicodeChar, 1048}, {(char*)"CYRISHRT", &CmdUnicodeChar, 1049}, {(char*)"CYRK", &CmdUnicodeChar, 1050}, {(char*)"CYRL", &CmdUnicodeChar, 1051}, {(char*)"CYRM", &CmdUnicodeChar, 1052}, {(char*)"CYRN", &CmdUnicodeChar, 1053}, {(char*)"CYRO", &CmdUnicodeChar, 1054}, {(char*)"CYRP", &CmdUnicodeChar, 1055}, {(char*)"CYRR", &CmdUnicodeChar, 1056}, {(char*)"CYRS", &CmdUnicodeChar, 1057}, {(char*)"CYRT", &CmdUnicodeChar, 1058}, {(char*)"CYRU", &CmdUnicodeChar, 1059}, {(char*)"CYRF", &CmdUnicodeChar, 1060}, {(char*)"CYRH", &CmdUnicodeChar, 1061}, {(char*)"CYRC", &CmdUnicodeChar, 1062}, {(char*)"CYRCH", &CmdUnicodeChar, 1063}, {(char*)"CYRSH", &CmdUnicodeChar, 1064}, {(char*)"CYRSHCH", &CmdUnicodeChar, 1065}, {(char*)"CYRHRDSN", &CmdUnicodeChar, 1066}, {(char*)"CYRERY", &CmdUnicodeChar, 1067}, {(char*)"CYRSFTSN", &CmdUnicodeChar, 1068}, {(char*)"CYREREV", &CmdUnicodeChar, 1069}, {(char*)"CYRYU", &CmdUnicodeChar, 1070}, {(char*)"CYRYA", &CmdUnicodeChar, 1071}, {(char*)"cyra", &CmdUnicodeChar, 1072}, {(char*)"cyrb", &CmdUnicodeChar, 1073}, {(char*)"cyrv", &CmdUnicodeChar, 1074}, {(char*)"cyrg", &CmdUnicodeChar, 1075}, {(char*)"cyrd", &CmdUnicodeChar, 1076}, {(char*)"cyre", &CmdUnicodeChar, 1077}, {(char*)"cyrzh", &CmdUnicodeChar, 1078}, {(char*)"cyrz", &CmdUnicodeChar, 1079}, {(char*)"cyri", &CmdUnicodeChar, 1080}, {(char*)"cyrishrt", &CmdUnicodeChar, 1081}, {(char*)"cyrk", &CmdUnicodeChar, 1082}, {(char*)"cyrl", &CmdUnicodeChar, 1083}, {(char*)"cyrm", &CmdUnicodeChar, 1084}, {(char*)"cyrn", &CmdUnicodeChar, 1085}, {(char*)"cyro", &CmdUnicodeChar, 1086}, {(char*)"cyrp", &CmdUnicodeChar, 1087}, {(char*)"cyrr", &CmdUnicodeChar, 1088}, {(char*)"cyrs", &CmdUnicodeChar, 1089}, {(char*)"cyrt", &CmdUnicodeChar, 1090}, {(char*)"cyru", &CmdUnicodeChar, 1091}, {(char*)"cyrf", &CmdUnicodeChar, 1092}, {(char*)"cyrh", &CmdUnicodeChar, 1093}, {(char*)"cyrc", &CmdUnicodeChar, 1094}, {(char*)"cyrch", &CmdUnicodeChar, 1095}, {(char*)"cyrsh", &CmdUnicodeChar, 1096}, {(char*)"cyrshch", &CmdUnicodeChar, 1097}, {(char*)"cyrhrdsn", &CmdUnicodeChar, 1098}, {(char*)"cyrery", &CmdUnicodeChar, 1099}, {(char*)"cyrsftsn", &CmdUnicodeChar, 1100}, {(char*)"cyrerev", &CmdUnicodeChar, 1101}, {(char*)"cyryu", &CmdUnicodeChar, 1102}, {(char*)"cyrya", &CmdUnicodeChar, 1103}, {(char*)"cyryo", &CmdUnicodeChar, 1105}, {(char*)"cyrdje", &CmdUnicodeChar, 1106}, {(char*)"cyrie", &CmdUnicodeChar, 1108}, {(char*)"cyrdze", &CmdUnicodeChar, 1109}, {(char*)"cyrii", &CmdUnicodeChar, 1110}, {(char*)"cyryi", &CmdUnicodeChar, 1111}, {(char*)"cyrje", &CmdUnicodeChar, 1112}, {(char*)"cyrlje", &CmdUnicodeChar, 1113}, {(char*)"cyrnje", &CmdUnicodeChar, 1114}, {(char*)"cyrtshe", &CmdUnicodeChar, 1115}, {(char*)"cyrushrt", &CmdUnicodeChar, 1118}, {(char*)"cyrdzhe", &CmdUnicodeChar, 1119}, {(char*)"CYRYAT", &CmdUnicodeChar, 1122}, {(char*)"cyryat", &CmdUnicodeChar, 1123}, {(char*)"CYRBYUS", &CmdUnicodeChar, 1130}, {(char*)"cyrbyus", &CmdUnicodeChar, 1131}, {(char*)"CYRFITA", &CmdUnicodeChar, 1138}, {(char*)"cyrfita", &CmdUnicodeChar, 1139}, {(char*)"CYRIZH", &CmdUnicodeChar, 1140}, {(char*)"cyrizh", &CmdUnicodeChar, 1141}, {(char*)"U", &CmdWideBreveChar, 0}, {(char*)"", (void(*)(int))((void*)0), 0}};
static CommandArray params[81] = {{(char*)"center", &CmdAlign, 1}, {(char*)"flushright", &CmdAlign, 2}, {(char*)"flushleft", &CmdAlign, 3}, {(char*)"document", &Environment, 2}, {(char*)"tabbing", &CmdTabbing, 5}, {(char*)"figure", &CmdFigure, 1}, {(char*)"wrapfigure", &CmdFigure, 6}, {(char*)"figure*", &CmdFigure, 5}, {(char*)"picture", &CmdPicture, 0}, {(char*)"minipage", &CmdMinipage, 0}, {(char*)"music", &CmdMusic, 0}, {(char*)"small", &CmdTolerateEnviron, 0}, {(char*)"pspicture", &CmdPsPicture, 0}, {(char*)"psgraph", &CmdPsGraph, 0}, {(char*)"quote", &CmdQuote, 23}, {(char*)"quotation", &CmdQuote, 24}, {(char*)"enumerate", &CmdList, 4}, {(char*)"list", &CmdList, 3}, {(char*)"itemize", &CmdList, 3}, {(char*)"compactitem", &CmdList, 3}, {(char*)"description", &CmdList, 5}, {(char*)"enumerate*", &CmdList, 4}, {(char*)"itemize*", &CmdList, 3}, {(char*)"description*", &CmdList, 5}, {(char*)"basedescipt", &CmdList, 5}, {(char*)"acronym", &CmdBeginAcronym, 0}, {(char*)"asparaenum", &CmdList, 4}, {(char*)"inparaenum", &CmdList, 6}, {(char*)"compactenum", &CmdList, 4}, {(char*)"compactdesc", &CmdList, 5}, {(char*)"compactitem", &CmdList, 3}, {(char*)"verbatim", &CmdVerbatim, 1}, {(char*)"comment", &CmdVerbatim, 4}, {(char*)"verse", &CmdVerse, 0}, {(char*)"tabular", &CmdTabular, 1}, {(char*)"tabular*", &CmdTabular, 2}, {(char*)"longtable", &CmdTabular, 3}, {(char*)"longtable*", &CmdTabular, 4}, {(char*)"array", &CmdArray, 1}, {(char*)"displaymath", &CmdEquation, 13}, {(char*)"equation", &CmdEquation, 10}, {(char*)"equation*", &CmdEquation, 11}, {(char*)"eqnarray*", &CmdEquation, 9}, {(char*)"eqnarray", &CmdEquation, 8}, {(char*)"align*", &CmdEquation, 18}, {(char*)"align", &CmdEquation, 17}, {(char*)"math", &CmdEquation, 12}, {(char*)"multicolumn", &CmdMultiCol, 0}, {(char*)"letter", &CmdLetter, 0}, {(char*)"table", &CmdTable, 2}, {(char*)"table*", &CmdTable, 3}, {(char*)"thebibliography", &CmdThebibliography, 0}, {(char*)"abstract", &CmdAbstract, 2}, {(char*)"acknowledgments", &CmdAcknowledgments, 0}, {(char*)"titlepage", &CmdTitlepage, 0}, {(char*)"em", &CmdEmphasize, 4}, {(char*)"rmfamily", &CmdFontFamily, 4}, {(char*)"sffamily", &CmdFontFamily, 8}, {(char*)"ttfamily", &CmdFontFamily, 12}, {(char*)"bfseries", &CmdFontSeries, 8}, {(char*)"mdseries", &CmdFontSeries, 4}, {(char*)"itshape", &CmdFontShape, 8}, {(char*)"scshape", &CmdFontShape, 12}, {(char*)"slshape", &CmdFontShape, 4}, {(char*)"it", &CmdFontShape, 18}, {(char*)"sc", &CmdFontShape, 19}, {(char*)"sl", &CmdFontShape, 17}, {(char*)"bf", &CmdFontShape, 9}, {(char*)"rm", &CmdFontFamily, 17}, {(char*)"sf", &CmdFontFamily, 18}, {(char*)"tt", &CmdFontFamily, 19}, {(char*)"Verbatim", &CmdVerbatim, 2}, {(char*)"alltt", &CmdVerbatim, 3}, {(char*)"latexonly", &CmdIgnore, 0}, {(char*)"htmlonly", &CmdIgnoreEnviron, 1}, {(char*)"rawhtml", &CmdIgnoreEnviron, 4}, {(char*)"theindex", &CmdIgnoreEnviron, 0}, {(char*)"landscape", &CmdTolerateEnviron, 0}, {(char*)"sloppypar", &CmdTolerateEnviron, 0}, {(char*)"doublespace", &CmdTolerateEnviron, 0}, {(char*)"", (void(*)(int))((void*)0), 0}};
static CommandArray hyperlatexCommands[7] = {{(char*)"link", &CmdLink, 0}, {(char*)"xlink", &CmdLink, 0}, {(char*)"Cite", &CmdLabel, 4}, {(char*)"Ref", &CmdLabel, 2}, {(char*)"Pageref", &CmdLabel, 6}, {(char*)"S", &CmdColsep, 0}, {(char*)"", (void(*)(int))((void*)0), 0}};
static CommandArray hyperrefCommands[7] = {{(char*)"url", &CmdHtml, 18}, {(char*)"href", &CmdHtml, 12}, {(char*)"hypersetup", &CmdIgnoreParameter, 1}, {(char*)"nolinkurl", &CmdHtml, 14}, {(char*)"hyperbaseurl", &CmdHtml, 15}, {(char*)"hyperref", &CmdHtml, 2}, {(char*)"", (void(*)(int))((void*)0), 0}};
static CommandArray apaciteCommands[87] = {{(char*)"BBOP", &CmdApaCite, 0}, {(char*)"BBAA", &CmdApaCite, 1}, {(char*)"BBAB", &CmdApaCite, 2}, {(char*)"BBAY", &CmdApaCite, 3}, {(char*)"BBC", &CmdApaCite, 4}, {(char*)"BBN", &CmdApaCite, 5}, {(char*)"BBCP", &CmdApaCite, 6}, {(char*)"BBOQ", &CmdApaCite, 7}, {(char*)"BBCQ", &CmdApaCite, 8}, {(char*)"BCBT", &CmdApaCite, 9}, {(char*)"BCBL", &CmdApaCite, 10}, {(char*)"BOthers", &CmdApaCite, 11}, {(char*)"BIP", &CmdApaCite, 12}, {(char*)"BAnd", &CmdApaCite, 13}, {(char*)"BED", &CmdApaCite, 14}, {(char*)"BEDS", &CmdApaCite, 15}, {(char*)"BTRANS", &CmdApaCite, 16}, {(char*)"BTRANSS", &CmdApaCite, 17}, {(char*)"BCHAIR", &CmdApaCite, 18}, {(char*)"BCHAIRS", &CmdApaCite, 19}, {(char*)"BVOL", &CmdApaCite, 20}, {(char*)"BVOLS", &CmdApaCite, 21}, {(char*)"BNUM", &CmdApaCite, 22}, {(char*)"BNUMS", &CmdApaCite, 23}, {(char*)"BEd", &CmdApaCite, 24}, {(char*)"BPG", &CmdApaCite, 25}, {(char*)"BPGS", &CmdApaCite, 26}, {(char*)"BTR", &CmdApaCite, 27}, {(char*)"BPhD", &CmdApaCite, 28}, {(char*)"BUPhD", &CmdApaCite, 29}, {(char*)"BMTh", &CmdApaCite, 30}, {(char*)"BUMTh", &CmdApaCite, 31}, {(char*)"BOWP", &CmdApaCite, 32}, {(char*)"BREPR", &CmdApaCite, 33}, {(char*)"BCnt", &CmdApaCite, 34}, {(char*)"BCntIP", &CmdApaCite, 34}, {(char*)"BBA", &CmdApaCite, 35}, {(char*)"AX", &CmdApaCite, 36}, {(char*)"BPBI", &CmdApaCite, 37}, {(char*)"BIn", &CmdApaCite, 38}, {(char*)"APACyear", &CmdApaCite, 201}, {(char*)"APACmetastar", &CmdApaCite, 202}, {(char*)"APACciteatitle", &CmdApaCite, 203}, {(char*)"APACcitebtitle", &CmdApaCite, 204}, {(char*)"APACinsertmetastar", &CmdApaCite, 205}, {(char*)"APACrefYearMonthDay", &CmdApaCite, 206}, {(char*)"APACrefatitle", &CmdApaCite, 207}, {(char*)"APACrefbtitle", &CmdApaCite, 208}, {(char*)"APACjournalVolNumPages", &CmdApaCite, 209}, {(char*)"APACrefYear", &CmdApaCite, 210}, {(char*)"APACaddressPublisher", &CmdApaCite, 211}, {(char*)"PrintBackRefs", &CmdApaCite, 213}, {(char*)"PrintCardinal", &CmdApaCite, 212}, {(char*)"PrintOrdinal", &CmdApaCite, 227}, {(char*)"APACaddressPublisherEqAuth", &CmdApaCite, 214}, {(char*)"APACrefaetitle", &CmdApaCite, 215}, {(char*)"APACrefbetitle", &CmdApaCite, 223}, {(char*)"APACmonth", &CmdApaCite, 216}, {(char*)"APACbVolEdTR", &CmdApaCite, 217}, {(char*)"APACaddressInstitution", &CmdApaCite, 218}, {(char*)"APAChowpublished", &CmdApaCite, 219}, {(char*)"APACorigyearnote", &CmdApaCite, 220}, {(char*)"APACrefnote", &CmdApaCite, 221}, {(char*)"APACbVolEdTRpgs", &CmdApaCite, 225}, {(char*)"APACorigjournalnote", &CmdApaCite, 224}, {(char*)"APACaddressInstitutionEqAuth", &CmdApaCite, 214}, {(char*)"unskip", &CmdApaCite, 226}, {(char*)"Bem", &CmdEmphasize, 3}, {(char*)"BCAY", &CmdBCAY, 0}, {(char*)"citeauthoryear", &CmdBCAY, 0}, {(char*)"fullcite", &CmdCite, 2}, {(char*)"shortcite", &CmdCite, 3}, {(char*)"citeNP", &CmdCite, 4}, {(char*)"fullciteNP", &CmdCite, 5}, {(char*)"shortciteNP", &CmdCite, 6}, {(char*)"citeA", &CmdCite, 7}, {(char*)"fullciteA", &CmdCite, 8}, {(char*)"shortciteA", &CmdCite, 9}, {(char*)"citeauthor", &CmdCite, 10}, {(char*)"fullciteauthor", &CmdCite, 11}, {(char*)"shortciteauthor", &CmdCite, 12}, {(char*)"citeyear", &CmdCite, 13}, {(char*)"citeyearNP", &CmdCite, 14}, {(char*)"shorttitle", &CmdIgnoreParameter, 1}, {(char*)"rightheader", &CmdIgnoreParameter, 1}, {(char*)"leftheader", &CmdIgnoreParameter, 1}, {(char*)"", (void(*)(int))((void*)0), 0}};
static CommandArray natbibCommands[22] = {{(char*)"cite", &CmdNatbibCite, 1}, {(char*)"citet", &CmdNatbibCite, 16}, {(char*)"citet*", &CmdNatbibCite, 17}, {(char*)"citep", &CmdNatbibCite, 18}, {(char*)"citep*", &CmdNatbibCite, 19}, {(char*)"citealt", &CmdNatbibCite, 20}, {(char*)"citealp", &CmdNatbibCite, 21}, {(char*)"citealt*", &CmdNatbibCite, 22}, {(char*)"citealp*", &CmdNatbibCite, 23}, {(char*)"citetext", &CmdNatbibCite, 24}, {(char*)"citeauthor", &CmdNatbibCite, 25}, {(char*)"citeauthor*", &CmdNatbibCite, 26}, {(char*)"citeyear", &CmdNatbibCite, 13}, {(char*)"citeyearpar", &CmdNatbibCite, 27}, {(char*)"Citet", &CmdNatbibCite, 128}, {(char*)"Citep", &CmdNatbibCite, 129}, {(char*)"Citealt", &CmdNatbibCite, 130}, {(char*)"Citealp", &CmdNatbibCite, 131}, {(char*)"Citeauthor", &CmdNatbibCite, 132}, {(char*)"bibpunct", &CmdBibpunct, 0}, {(char*)"natexlab", &CmdNatexlab, 0}, {(char*)"", (void(*)(int))((void*)0), 0}};
static CommandArray harvardCommands[12] = {{(char*)"cite", &CmdHarvardCite, 1}, {(char*)"citeasnoun", &CmdHarvardCite, 28}, {(char*)"possessivecite", &CmdHarvardCite, 29}, {(char*)"citeaffixed", &CmdHarvardCite, 30}, {(char*)"citeyear", &CmdHarvardCite, 13}, {(char*)"citeyear*", &CmdHarvardCite, 31}, {(char*)"citename", &CmdHarvardCite, 35}, {(char*)"harvarditem", &CmdHarvard, 32}, {(char*)"harvardand", &CmdHarvard, 36}, {(char*)"harvardyearleft", &CmdHarvard, 33}, {(char*)"harvardyearright", &CmdHarvard, 34}, {(char*)"", (void(*)(int))((void*)0), 0}};
static CommandArray authordateCommands[3] = {{(char*)"citename", &CmdCiteName, 0}, {(char*)"shortcite", &CmdCite, 3}, {(char*)"", (void(*)(int))((void*)0), 0}};
static CommandArray verbatimCommands[1] = {{(char*)"", (void(*)(int))((void*)0), 0}};
static CommandArray quoteCommands[1] = {{(char*)"", (void(*)(int))((void*)0), 0}};
static CommandArray quotationCommands[1] = {{(char*)"", (void(*)(int))((void*)0), 0}};
static CommandArray verseCommands[1] = {{(char*)"", (void(*)(int))((void*)0), 0}};
static CommandArray genericCommands[1] = {{(char*)"", (void(*)(int))((void*)0), 0}};
static CommandArray bibliographyCommands[1] = {{(char*)"", (void(*)(int))((void*)0), 0}};
static CommandArray ignoreCommands[1] = {{(char*)"", (void(*)(int))((void*)0), 0}};

int CurrentEnvironmentCount(void)
{
    {
        return (iEnvCount);
    }
}

static char* EnvironmentName(CommandArray* code)
{
    char* tmp;
    char* tmp___0;
    char* tmp___1;
    char* tmp___2;
    char* tmp___3;
    char* tmp___4;
    char* tmp___5;
    char* tmp___6;
    char* tmp___7;
    char* tmp___8;
    char* tmp___9;
    char* tmp___10;
    char* tmp___11;
    char* tmp___12;
    char* tmp___13;
    char* tmp___14;
    char* tmp___15;
    char* tmp___16;
    char* tmp___17;
    char* tmp___18;
    char* tmp___19;
    char* tmp___20;
    char* tmp___21;
    char* tmp___22;
    char* tmp___23;
    char* tmp___24;
    {
        if ((unsigned long )code == (unsigned long )(PreambleCommands)){
            {
                tmp = strdup("preamble");
            }
            return (tmp);
        }
        if ((unsigned long )code == (unsigned long )(commands)){
            {
                tmp___0 = strdup("document");
            }
            return (tmp___0);
        }
        if ((unsigned long )code == (unsigned long )(ItemizeCommands)){
            {
                tmp___1 = strdup("itemize");
            }
            return (tmp___1);
        }
        if ((unsigned long )code == (unsigned long )(EnumerateCommands)){
            {
                tmp___2 = strdup("enumerate");
            }
            return (tmp___2);
        }
        if ((unsigned long )code == (unsigned long )(DescriptionCommands)){
            {
                tmp___3 = strdup("description");
            }
            return (tmp___3);
        }
        if ((unsigned long )code == (unsigned long )(InparaenumCommands)){
            {
                tmp___4 = strdup("inparaenum");
            }
            return (tmp___4);
        }
        if ((unsigned long )code == (unsigned long )(LetterCommands)){
            {
                tmp___5 = strdup("letter");
            }
            return (tmp___5);
        }
        if ((unsigned long )code == (unsigned long )(GermanModeCommands)){
            {
                tmp___6 = strdup("german");
            }
            return (tmp___6);
        }
        if ((unsigned long )code == (unsigned long )(FrenchModeCommands)){
            {
                tmp___7 = strdup("french");
            }
            return (tmp___7);
        }
        if ((unsigned long )code == (unsigned long )(RussianModeCommands)){
            {
                tmp___8 = strdup("russian");
            }
            return (tmp___8);
        }
        if ((unsigned long )code == (unsigned long )(CzechModeCommands)){
            {
                tmp___9 = strdup("czech");
            }
            return (tmp___9);
        }
        if ((unsigned long )code == (unsigned long )(FigureCommands)){
            {
                tmp___10 = strdup("figure or wrapfigure");
            }
            return (tmp___10);
        }
        if ((unsigned long )code == (unsigned long )(ignoreCommands)){
            {
                tmp___11 = strdup("unknown environment");
            }
            return (tmp___11);
        }
        if ((unsigned long )code == (unsigned long )(hyperlatexCommands)){
            {
                tmp___12 = strdup("hyperlatex");
            }
            return (tmp___12);
        }
        if ((unsigned long )code == (unsigned long )(apaciteCommands)){
            {
                tmp___13 = strdup("apacite");
            }
            return (tmp___13);
        }
        if ((unsigned long )code == (unsigned long )(natbibCommands)){
            {
                tmp___14 = strdup("natbib");
            }
            return (tmp___14);
        }
        if ((unsigned long )code == (unsigned long )(harvardCommands)){
            {
                tmp___15 = strdup("harvard");
            }
            return (tmp___15);
        }
        if ((unsigned long )code == (unsigned long )(authordateCommands)){
            {
                tmp___16 = strdup("authordate");
            }
            return (tmp___16);
        }
        if ((unsigned long )code == (unsigned long )(verbatimCommands)){
            {
                tmp___17 = strdup("verbatim");
            }
            return (tmp___17);
        }
        if ((unsigned long )code == (unsigned long )(quoteCommands)){
            {
                tmp___18 = strdup("quote");
            }
            return (tmp___18);
        }
        if ((unsigned long )code == (unsigned long )(quotationCommands)){
            {
                tmp___19 = strdup("quotation");
            }
            return (tmp___19);
        }
        if ((unsigned long )code == (unsigned long )(bibliographyCommands)){
            {
                tmp___20 = strdup("bibliography");
            }
            return (tmp___20);
        }
        if ((unsigned long )code == (unsigned long )(verseCommands)){
            {
                tmp___21 = strdup("verse");
            }
            return (tmp___21);
        }
        if ((unsigned long )code == (unsigned long )(genericCommands)){
            {
                tmp___22 = strdup("generic");
            }
            return (tmp___22);
        }
        if ((unsigned long )code == (unsigned long )(acronymCommands)){
            {
                tmp___23 = strdup("acronym");
            }
            return (tmp___23);
        }
        {
            tmp___24 = strdup("unknown");
        }
        return (tmp___24);
    }
}

int CallCommandFunc(char* cCommand)
{
    int iCommand;
    int iEnv;
    int user_def_index;
    char* macro_string;
    int tmp;
    int tmp___0;
    {
        {
            diagnostics(4, (char*)"CallCommandFunc seeking <%s> (%d environments to look through)", cCommand, iEnvCount);
            user_def_index = existsDefinition(cCommand);
        }
        if (user_def_index > -1){
            {
                macro_string = expandDefinition(user_def_index);
                diagnostics(5, (char*)"CallCommandFunc <%s> expanded to <%s>", cCommand, macro_string);
                ConvertString((const char*)macro_string);
                free((void*)macro_string);
            }
            return (1);
        }
        iEnv = iEnvCount - 1;
        {
            while (1){
                while_continue:
                ;
                if (!(iEnv >= 0)){
                    goto while_break;
                }
                iCommand = 0;
                {
                    while (1){
                        while_continue___0:
                        ;
                        {
                            tmp___0 = strcmp((const char*)(Environments[iEnv] + iCommand)->cmd_name, "");
                        }
                        if (!(tmp___0 != 0)){
                            goto while_break___0;
                        }
                        {
                            tmp = strcmp((const char*)(Environments[iEnv] + iCommand)->cmd_name, (const char*)cCommand);
                        }
                        if (tmp == 0){
                            if ((unsigned long )(Environments[iEnv] + iCommand)->func == (unsigned long )((void*)0)){
                                return (0);
                            }
                            if ((unsigned long )(Environments[iEnv] + iCommand)->func == (unsigned long )(&CmdIgnoreParameter)){
                                {
                                    diagnostics(2, (char*)"Unknown command \'\\%s\'", cCommand);
                                }
                            }
                            {
                                diagnostics(5, (char*)"CallCommandFunc Found \'%s\' iEnvCommand=%d number=%d", (Environments[iEnv] + iCommand)->cmd_name, iEnv, iCommand);
                                (*((Environments[iEnv] + iCommand)->func))((Environments[iEnv] + iCommand)->param);
                            }
                            return (1);
                        }
                        iCommand++;
                    }
                    while_break___0:
                    ;
                }
                iEnv--;
            }
            while_break:
            ;
        }
        return (0);
    }
}

void CallParamFunc(char* cCommand, int AddParam)
{
    int i;
    char unknown_environment[100];
    int tmp___0;
    int tmp___1;
    {
        i = 0;
        {
            while (1){
                while_continue:
                ;
                {
                    tmp___1 = strcmp((const char*)params[i].cmd_name, "");
                }
                if (!(tmp___1 != 0)){
                    goto while_break;
                }
                {
                    tmp___0 = strcmp((const char*)params[i].cmd_name, (const char*)cCommand);
                }
                if (tmp___0 == 0){
                    if (!((unsigned long )params[i].func != (unsigned long )((void*)0))){
                        {
                            __assert_fail("params[i].func != NULL", "/home/khheo/project/bingo-ci-experiment/benchmark/latex2rtf-2.1.1/commands.c", 1168U, "CallParamFunc");
                        }
                    }
                    {
                        (*(params[i].func))(params[i].param | AddParam);
                    }
                    return;
                }
                i++;
            }
            while_break:
            ;
        }
        if (AddParam == 16384){
            {
                snprintf((char*)(unknown_environment), (size_t)100, (const char*)"\\%s%s%s", "end{", cCommand, "}");
                Ignore_Environment(cCommand);
                diagnostics(1, (char*)"Unknown environment \\begin{%s} ... \\end{%s}", cCommand, cCommand);
            }
        }
        return;
    }
}

static char* EnvironmentNameByNumber(int n)
{
    char* tmp;
    {
        if (n < 0){
            return ((char*)"");
        }
        {
            tmp = EnvironmentName(Environments[n]);
        }
        return (tmp);
    }
}

void PushEnvironment(int code)
{
    char* diag;
    int tmp;
    {
        {
            g_par_indent_array[iEnvCount] = getLength((char*)"parindent");
            g_left_indent_array[iEnvCount] = getLeftMarginIndent();
            g_right_indent_array[iEnvCount] = getRightMarginIndent();
            tmp = getAlignment();
            g_align_array[iEnvCount] = (char)tmp;
            PushFontSettings();
        }
        {
            if (code == 1){
                goto case_1;
            }
            if (code == 2){
                goto case_2;
            }
            if (code == 3){
                goto case_3;
            }
            if (code == 4){
                goto case_4;
            }
            if (code == 6){
                goto case_6;
            }
            if (code == 8){
                goto case_8;
            }
            if (code == 5){
                goto case_5;
            }
            if (code == 12){
                goto case_12;
            }
            if (code == 13){
                goto case_13;
            }
            if (code == 14){
                goto case_14;
            }
            if (code == 16){
                goto case_16;
            }
            if (code == 11){
                goto case_11;
            }
            if (code == 10){
                goto case_10;
            }
            if (code == 17){
                goto case_17;
            }
            if (code == 18){
                goto case_18;
            }
            if (code == 19){
                goto case_19;
            }
            if (code == 20){
                goto case_20;
            }
            if (code == 22){
                goto case_22;
            }
            if (code == 24){
                goto case_24;
            }
            if (code == 23){
                goto case_23;
            }
            if (code == 21){
                goto case_21;
            }
            if (code == 25){
                goto case_25;
            }
            if (code == 15){
                goto case_15;
            }
            if (code == 26){
                goto case_26;
            }
            if (code == 9){
                goto case_9;
            }
            if (code == 27){
                goto case_27;
            }
            goto switch_default;
            case_1:
            Environments[iEnvCount] = PreambleCommands;
            goto switch_break;
            case_2:
            Environments[iEnvCount] = commands;
            goto switch_break;
            case_3:
            Environments[iEnvCount] = ItemizeCommands;
            goto switch_break;
            case_4:
            Environments[iEnvCount] = EnumerateCommands;
            goto switch_break;
            case_6:
            Environments[iEnvCount] = InparaenumCommands;
            goto switch_break;
            case_8:
            Environments[iEnvCount] = LetterCommands;
            goto switch_break;
            case_5:
            Environments[iEnvCount] = DescriptionCommands;
            goto switch_break;
            case_12:
            Environments[iEnvCount] = GermanModeCommands;
            goto switch_break;
            case_13:
            Environments[iEnvCount] = FrenchModeCommands;
            goto switch_break;
            case_14:
            Environments[iEnvCount] = RussianModeCommands;
            goto switch_break;
            case_16:
            Environments[iEnvCount] = CzechModeCommands;
            goto switch_break;
            case_11:
            Environments[iEnvCount] = FigureCommands;
            goto switch_break;
            case_10:
            Environments[iEnvCount] = hyperlatexCommands;
            goto switch_break;
            case_17:
            Environments[iEnvCount] = apaciteCommands;
            goto switch_break;
            case_18:
            Environments[iEnvCount] = natbibCommands;
            goto switch_break;
            case_19:
            Environments[iEnvCount] = harvardCommands;
            goto switch_break;
            case_20:
            Environments[iEnvCount] = authordateCommands;
            goto switch_break;
            case_22:
            Environments[iEnvCount] = verbatimCommands;
            goto switch_break;
            case_24:
            Environments[iEnvCount] = quotationCommands;
            goto switch_break;
            case_23:
            Environments[iEnvCount] = quoteCommands;
            goto switch_break;
            case_21:
            Environments[iEnvCount] = verseCommands;
            goto switch_break;
            case_25:
            Environments[iEnvCount] = bibliographyCommands;
            goto switch_break;
            case_15:
            Environments[iEnvCount] = genericCommands;
            goto switch_break;
            case_26:
            Environments[iEnvCount] = hyperrefCommands;
            goto switch_break;
            case_9:
            Environments[iEnvCount] = ignoreCommands;
            goto switch_break;
            case_27:
            Environments[iEnvCount] = acronymCommands;
            goto switch_break;
            switch_default:
            {
                diagnostics(0, (char*)"assertion failed at function PushEnvironment");
            }
            switch_break:
            ;
        }
        {
            iEnvCount++;
            diag = EnvironmentNameByNumber(iEnvCount - 1);
            diagnostics(4, (char*)"\\begin{%s} [%d]", diag, iEnvCount - 1);
            free((void*)diag);
        }
        return;
    }
}

void PopEnvironment(void)
{
    char* this_env;
    char* last_env;
    {
        {
            this_env = EnvironmentNameByNumber(iEnvCount - 1);
            last_env = EnvironmentNameByNumber(iEnvCount - 2);
            iEnvCount--;
            Environments[iEnvCount] = (CommandArray*)((void*)0);
            setLength((char*)"parindent", g_par_indent_array[iEnvCount]);
            setLeftMarginIndent(g_left_indent_array[iEnvCount]);
            setRightMarginIndent(g_right_indent_array[iEnvCount]);
            setAlignment((int)g_align_array[iEnvCount]);
            PopFontSettings();
            diagnostics(3, (char*)"\\end{%s} [%d]", this_env, iEnvCount - 1);
            free((void*)this_env);
            free((void*)last_env);
        }
        return;
    }
}

extern int fputc(int __c, FILE* __stream);
int appleUnicode[128] = {196, 197, 199, 201, 209, 214, 220, 225, 224, 226, 228, 227, 229, 231, 233, 232, 234, 235, 237, 236, 238, 239, 241, 243, 242, 244, 246, 245, 250, 249, 251, 252, 8224, 176, 162, 163, 167, 8226, 182, 223, 174, 169, 8482, 180, 168, 8800, 198, 216, 8734, 177, 8804, 8805, 165, 181, 8706, 8721, 8719, 960, 8747, 170, 186, 937, 230, 248, 191, 161, 172, 8730, 402, 8776, 8710, 171, 187, 8230, 160, 192, 195, 213, 338, 339, 8211, 8212, 8220, 8221, 8216, 8217, 247, 9674, 255, 376, 8260, 8364, 8249, 8250, 64257, 64258, 8225, 183, 8218, 8222, 8240, 194, 202, 193, 203, 200, 205, 206, 207, 204, 211, 212, 63743, 210, 218, 219, 217, 305, 710, 732, 175, 728, 729, 730, 184, 733, 731, 711};
int appleCEUnicode[128] = {196, 256, 257, 201, 260, 214, 220, 225, 261, 268, 228, 269, 262, 263, 233, 377, 378, 270, 237, 271, 274, 275, 278, 243, 279, 244, 246, 245, 250, 282, 283, 252, 8224, 176, 280, 163, 167, 8226, 182, 223, 174, 169, 8482, 281, 168, 8800, 291, 302, 303, 298, 8804, 8805, 299, 310, 8706, 8721, 322, 315, 316, 317, 318, 313, 314, 325, 326, 323, 172, 8730, 324, 327, 8710, 171, 187, 8230, 160, 328, 336, 213, 337, 332, 8211, 8212, 8220, 8221, 8216, 8217, 247, 9674, 333, 340, 341, 344, 8249, 8250, 345, 342, 343, 352, 8218, 8222, 353, 346, 347, 193, 356, 357, 205, 381, 382, 362, 211, 212, 363, 366, 218, 367, 368, 369, 370, 371, 221, 253, 311, 379, 321, 380, 290, 711};
int appleCyrrilicUnicode[128] = {1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 8224, 176, 1168, 163, 167, 8226, 182, 1030, 174, 169, 8482, 1026, 1106, 8800, 1027, 1107, 8734, 177, 8804, 8805, 1110, 181, 1169, 1032, 1028, 1108, 1031, 1111, 1033, 1113, 1034, 1114, 1112, 1029, 172, 8730, 402, 8776, 8710, 171, 187, 8230, 160, 1035, 1115, 1036, 1116, 1109, 8211, 8212, 8220, 8221, 8216, 8217, 247, 8222, 1038, 1118, 1039, 1119, 8470, 1025, 1105, 1103, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 8364};
int cp437Unicode[128] = {199, 252, 233, 226, 228, 224, 229, 231, 234, 235, 232, 239, 238, 236, 196, 197, 201, 230, 198, 244, 246, 242, 251, 249, 255, 214, 220, 162, 163, 165, 8359, 402, 225, 237, 243, 250, 241, 209, 170, 186, 191, 8976, 172, 189, 188, 161, 171, 187, 9617, 9618, 9619, 9474, 9508, 9569, 9570, 9558, 9557, 9571, 9553, 9559, 9565, 9564, 9563, 9488, 9492, 9524, 9516, 9500, 9472, 9532, 9566, 9567, 9562, 9556, 9577, 9574, 9568, 9552, 9580, 9575, 9576, 9572, 9573, 9561, 9560, 9554, 9555, 9579, 9578, 9496, 9484, 9608, 9604, 9612, 9616, 9600, 945, 223, 915, 960, 931, 963, 181, 964, 934, 920, 937, 948, 8734, 966, 949, 8745, 8801, 177, 8805, 8804, 8992, 8993, 247, 8776, 176, 8729, 183, 8730, 8319, 178, 9632, 160};
int cp850Unicode[128] = {199, 252, 233, 226, 228, 224, 229, 231, 234, 235, 232, 239, 238, 236, 196, 197, 201, 230, 198, 244, 246, 242, 251, 249, 255, 214, 220, 248, 163, 216, 215, 402, 225, 237, 243, 250, 241, 209, 170, 186, 191, 174, 172, 189, 188, 161, 171, 187, 9617, 9618, 9619, 9474, 9508, 193, 194, 192, 169, 9571, 9553, 9559, 9565, 162, 165, 9488, 9492, 9524, 9516, 9500, 9472, 9532, 227, 195, 9562, 9556, 9577, 9574, 9568, 9552, 9580, 164, 240, 208, 202, 203, 200, 305, 205, 206, 207, 9496, 9484, 9608, 9604, 166, 204, 9600, 211, 223, 212, 210, 245, 213, 181, 254, 222, 218, 219, 217, 253, 221, 175, 180, 173, 177, 8215, 190, 182, 167, 247, 184, 176, 168, 183, 185, 179, 178, 9632, 160};
int cp852Unicode[128] = {199, 252, 233, 226, 228, 367, 263, 231, 322, 235, 336, 337, 238, 377, 196, 262, 201, 313, 314, 244, 246, 317, 318, 346, 347, 214, 220, 356, 357, 321, 215, 269, 225, 237, 243, 250, 260, 261, 381, 382, 280, 281, 172, 378, 268, 351, 171, 187, 9617, 9618, 9619, 9474, 9508, 193, 194, 282, 350, 9571, 9553, 9559, 9565, 379, 380, 9488, 9492, 9524, 9516, 9500, 9472, 9532, 258, 259, 9562, 9556, 9577, 9574, 9568, 9552, 9580, 164, 273, 272, 270, 203, 271, 327, 205, 206, 283, 9496, 9484, 9608, 9604, 354, 366, 9600, 211, 223, 212, 323, 324, 328, 352, 353, 340, 218, 341, 368, 253, 221, 355, 180, 173, 733, 731, 711, 728, 167, 247, 184, 176, 168, 729, 369, 344, 345, 9632, 160};
int cp855Unicode[128] = {1106, 1026, 1107, 1027, 1105, 1025, 1108, 1028, 1109, 1029, 1110, 1030, 1111, 1031, 1112, 1032, 1113, 1033, 1114, 1034, 1115, 1035, 1116, 1036, 1118, 1038, 1119, 1039, 1102, 1070, 1098, 1066, 1072, 1040, 1073, 1041, 1094, 1062, 1076, 1044, 1077, 1045, 1092, 1060, 1075, 1043, 171, 187, 9617, 9618, 9619, 9474, 9508, 1093, 1061, 1080, 1048, 9571, 9553, 9559, 9565, 1081, 1049, 9488, 9492, 9524, 9516, 9500, 9472, 9532, 1082, 1050, 9562, 9556, 9577, 9574, 9568, 9552, 9580, 164, 1083, 1051, 1084, 1052, 1085, 1053, 1086, 1054, 1087, 9496, 9484, 9608, 9604, 1055, 1103, 9600, 1071, 1088, 1056, 1089, 1057, 1090, 1058, 1091, 1059, 1078, 1046, 1074, 1042, 1100, 1068, 8470, 173, 1099, 1067, 1079, 1047, 1096, 1064, 1101, 1069, 1097, 1065, 1095, 1063, 167, 9632, 160};
int cp857Unicode[128] = {8364, 32, 32, 32, 32, 8230, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 8216, 8217, 8220, 8221, 8226, 8211, 8212, 32, 32, 32, 32, 32, 32, 32, 32, 160, 3585, 3586, 3587, 3588, 3589, 3590, 3591, 3592, 3593, 3594, 3595, 3596, 3597, 3598, 3599, 3600, 3601, 3602, 3603, 3604, 3605, 3606, 3607, 3608, 3609, 3610, 3611, 3612, 3613, 3614, 3615, 3616, 3617, 3618, 3619, 3620, 3621, 3622, 3623, 3624, 3625, 3626, 3627, 3628, 3629, 3630, 3631, 3632, 3633, 3634, 3635, 3636, 3637, 3638, 3639, 3640, 3641, 3642, 32, 32, 32, 32, 3647, 3648, 3649, 3650, 3651, 3652, 3653, 3654, 3655, 3656, 3657, 3658, 3659, 3660, 3661, 3662, 3663, 3664, 3665, 3666, 3667, 3668, 3669, 3670, 3671, 3672, 3673, 3674, 3675, 32, 32, 32, 32};
int cp865Unicode[128] = {199, 252, 233, 226, 228, 224, 229, 231, 234, 235, 232, 239, 238, 236, 196, 197, 201, 230, 198, 244, 246, 242, 251, 249, 255, 214, 220, 248, 163, 216, 8359, 402, 225, 237, 243, 250, 241, 209, 170, 186, 191, 8976, 172, 189, 188, 161, 171, 164, 9617, 9618, 9619, 9474, 9508, 9569, 9570, 9558, 9557, 9571, 9553, 9559, 9565, 9564, 9563, 9488, 9492, 9524, 9516, 9500, 9472, 9532, 9566, 9567, 9562, 9556, 9577, 9574, 9568, 9552, 9580, 9575, 9576, 9572, 9573, 9561, 9560, 9554, 9555, 9579, 9578, 9496, 9484, 9608, 9604, 9612, 9616, 9600, 945, 223, 915, 960, 931, 963, 181, 964, 934, 920, 937, 948, 8734, 966, 949, 8745, 8801, 177, 8805, 8804, 8992, 8993, 247, 8776, 176, 8729, 183, 8730, 8319, 178, 9632, 160};
int cp866Unicode[128] = {1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 9617, 9618, 9619, 9474, 9508, 9569, 9570, 9558, 9557, 9571, 9553, 9559, 9565, 9564, 9563, 9488, 9492, 9524, 9516, 9500, 9472, 9532, 9566, 9567, 9562, 9556, 9577, 9574, 9568, 9552, 9580, 9575, 9576, 9572, 9573, 9561, 9560, 9554, 9555, 9579, 9578, 9496, 9484, 9608, 9604, 9612, 9616, 9600, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103, 1025, 1105, 1028, 1108, 1031, 1111, 1038, 1118, 176, 8729, 183, 8730, 8470, 164, 9632, 160};
int cp1250Unicode[128] = {8364, 32, 8218, 32, 8222, 8230, 8224, 8225, 32, 8240, 352, 8249, 346, 356, 381, 377, 32, 8216, 8217, 8220, 8221, 8226, 8211, 8212, 32, 8482, 353, 8250, 347, 357, 382, 378, 160, 711, 728, 321, 164, 260, 166, 167, 168, 169, 350, 171, 172, 173, 174, 379, 176, 177, 731, 322, 180, 181, 182, 183, 184, 261, 351, 187, 317, 733, 318, 380, 340, 193, 194, 258, 196, 313, 262, 199, 268, 201, 280, 203, 282, 205, 206, 270, 272, 323, 327, 211, 212, 336, 214, 215, 344, 366, 218, 368, 220, 221, 354, 223, 341, 225, 226, 259, 228, 314, 263, 231, 269, 233, 281, 235, 283, 237, 238, 271, 273, 324, 328, 243, 244, 337, 246, 247, 345, 367, 250, 369, 252, 253, 355, 729};
int cp1251Unicode[128] = {1026, 1027, 8218, 1107, 8222, 8230, 8224, 8225, 8364, 8240, 1033, 8249, 1034, 1036, 1035, 1039, 1106, 8216, 8217, 8220, 8221, 8226, 8211, 8212, 32, 8482, 1113, 8250, 1114, 1116, 1115, 1119, 160, 1038, 1118, 1032, 164, 1168, 166, 167, 1025, 169, 1028, 171, 172, 173, 174, 1031, 176, 177, 1030, 1110, 1169, 181, 182, 183, 1105, 8470, 1108, 187, 1112, 1029, 1109, 1111, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103};
int cp1252Unicode[128] = {8364, 32, 8218, 402, 8222, 8230, 8224, 8225, 710, 8240, 352, 8249, 338, 32, 381, 32, 32, 8216, 8217, 8220, 8221, 8226, 8211, 8212, 732, 8482, 353, 8250, 339, 32, 382, 376, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255};
int decmultiUnicode[128] = {32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 161, 162, 163, 32, 165, 32, 167, 164, 169, 170, 171, 32, 32, 32, 32, 176, 177, 178, 179, 32, 181, 182, 183, 32, 185, 186, 187, 188, 189, 32, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 32, 209, 210, 211, 212, 213, 214, 338, 216, 217, 218, 219, 220, 376, 32, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 32, 241, 242, 243, 244, 245, 246, 339, 248, 249, 250, 251, 252, 255, 32, 32};
int koi8rUnicode[128] = {9472, 9474, 9484, 9488, 9492, 9496, 9500, 9508, 9516, 9524, 9532, 9600, 9604, 9608, 9612, 9616, 9617, 9618, 9619, 8992, 9632, 8729, 8730, 8776, 8804, 8805, 160, 8993, 176, 178, 183, 247, 9552, 9553, 9554, 1105, 9555, 9556, 9557, 9558, 9559, 9560, 9561, 9562, 9563, 9564, 9565, 9566, 9567, 9568, 9569, 1025, 9570, 9571, 9572, 9573, 9574, 9575, 9576, 9577, 9578, 9579, 9580, 169, 1102, 1072, 1073, 1094, 1076, 1077, 1092, 1075, 1093, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1103, 1088, 1089, 1090, 1091, 1078, 1074, 1100, 1099, 1079, 1096, 1101, 1097, 1095, 1098, 1070, 1040, 1041, 1062, 1044, 1045, 1060, 1043, 1061, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1071, 1056, 1057, 1058, 1059, 1046, 1042, 1068, 1067, 1047, 1064, 1069, 1065, 1063, 1066};
int koi8uUnicode[128] = {9472, 9474, 9484, 9488, 9492, 9496, 9500, 9508, 9516, 9524, 9532, 9600, 9604, 9608, 9612, 9616, 9617, 9618, 9619, 8992, 9632, 8729, 8730, 8776, 8804, 8805, 160, 8993, 176, 178, 183, 247, 9552, 9553, 9554, 1105, 1108, 9556, 1110, 1111, 9559, 9560, 9561, 9562, 9563, 1169, 9565, 9566, 9567, 9568, 9569, 1025, 1028, 9571, 1030, 1031, 9574, 9575, 9576, 9577, 9578, 1168, 9580, 169, 1102, 1072, 1073, 1094, 1076, 1077, 1092, 1075, 1093, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1103, 1088, 1089, 1090, 1091, 1078, 1074, 1100, 1099, 1079, 1096, 1101, 1097, 1095, 1098, 1070, 1040, 1041, 1062, 1044, 1045, 1060, 1043, 1061, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1071, 1056, 1057, 1058, 1059, 1046, 1042, 1068, 1067, 1047, 1064, 1069, 1065, 1063, 1066};
int latin2Unicode[128] = {128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 260, 728, 321, 164, 317, 346, 167, 168, 352, 350, 356, 377, 173, 381, 379, 176, 261, 731, 322, 180, 318, 347, 711, 184, 353, 351, 357, 378, 733, 382, 380, 340, 193, 194, 258, 196, 313, 262, 199, 268, 201, 280, 203, 282, 205, 206, 270, 272, 323, 327, 211, 212, 336, 214, 215, 344, 366, 218, 368, 220, 221, 354, 223, 341, 225, 226, 259, 228, 314, 263, 231, 269, 233, 281, 235, 283, 237, 238, 271, 273, 324, 328, 243, 244, 337, 246, 247, 345, 367, 250, 369, 252, 253, 355, 729};
int latin3Unicode[128] = {128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 294, 728, 163, 164, 32, 292, 167, 168, 304, 350, 286, 308, 173, 32, 379, 176, 295, 178, 179, 180, 181, 293, 183, 184, 305, 351, 287, 309, 189, 32, 380, 192, 193, 194, 32, 196, 266, 264, 199, 200, 201, 202, 203, 204, 205, 206, 207, 32, 209, 210, 211, 212, 288, 214, 215, 284, 217, 218, 219, 220, 364, 348, 223, 224, 225, 32, 226, 228, 267, 265, 231, 232, 233, 234, 235, 236, 237, 238, 239, 32, 241, 242, 243, 244, 289, 246, 247, 285, 249, 250, 251, 252, 365, 349, 729};
int latin4Unicode[128] = {128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 260, 312, 342, 164, 296, 315, 167, 168, 352, 274, 290, 358, 173, 381, 175, 176, 261, 731, 343, 180, 297, 316, 711, 184, 353, 275, 291, 359, 330, 382, 331, 256, 193, 194, 195, 196, 197, 198, 302, 268, 201, 280, 203, 278, 205, 206, 298, 272, 325, 332, 310, 212, 213, 214, 215, 216, 370, 218, 219, 220, 360, 362, 223, 257, 225, 226, 227, 228, 229, 230, 303, 269, 233, 281, 235, 279, 237, 238, 299, 273, 326, 333, 311, 244, 245, 246, 247, 248, 371, 250, 251, 252, 361, 363, 729};
int latin5Unicode[128] = {128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 286, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 304, 350, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 287, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 305, 351, 255};
int latin9Unicode[128] = {128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 8364, 165, 352, 167, 353, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 381, 181, 182, 183, 382, 185, 186, 187, 338, 339, 376, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255};
int latin10Unicode[128] = {128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 260, 261, 321, 8364, 8222, 352, 167, 353, 169, 536, 171, 377, 173, 378, 379, 176, 177, 268, 322, 381, 8221, 182, 183, 382, 269, 537, 187, 338, 339, 376, 380, 192, 193, 194, 258, 196, 262, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 272, 323, 210, 211, 212, 336, 214, 346, 368, 217, 218, 219, 220, 280, 538, 223, 224, 225, 226, 259, 228, 263, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 273, 324, 242, 243, 244, 337, 246, 347, 369, 249, 250, 251, 252, 281, 539, 255};
int nextUnicode[128] = {160, 192, 193, 194, 195, 196, 197, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 217, 218, 219, 220, 221, 222, 181, 215, 247, 169, 161, 162, 163, 8260, 165, 402, 167, 164, 8217, 8220, 171, 8249, 8250, 64257, 64258, 174, 8211, 8224, 8225, 183, 166, 182, 8226, 8218, 8222, 8221, 187, 8230, 8240, 172, 191, 185, 715, 180, 710, 732, 175, 728, 729, 168, 178, 730, 184, 179, 733, 731, 711, 8212, 177, 188, 189, 190, 224, 225, 226, 227, 228, 229, 231, 232, 233, 234, 235, 236, 198, 237, 170, 238, 239, 240, 241, 321, 216, 338, 186, 242, 243, 244, 245, 246, 230, 249, 250, 251, 305, 252, 253, 322, 248, 339, 223, 254, 255, 65533, 65533};
int cmrUnicode[128] = {915, 916, 920, 923, 926, 928, 931, 933, 934, 936, 937, 64256, 64257, 64258, 64259, 64260, 305, 63743, 768, 769, 780, 774, 773, 778, 807, 223, 230, 339, 248, 198, 338, 216, 823, 33, 8208, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 161, 61, 191, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 8220, 93, 770, 775, 8216, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 8211, 8212, 779, 771, 776};
int cmttUnicode[128] = {915, 916, 920, 923, 926, 928, 931, 933, 934, 936, 937, 8593, 8595, 63742, 161, 191, 305, 63743, 768, 769, 780, 774, 773, 778, 807, 223, 230, 339, 248, 198, 338, 216, 9250, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 770, 818, 8216, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 771, 776};
int ot2Unicode[128] = {1034, 1033, 1039, 1069, 1030, 1028, 1026, 1035, 1114, 1113, 1119, 1101, 1110, 1108, 1106, 1115, 1070, 1046, 1049, 1025, 1140, 1138, 1029, 1071, 1102, 1078, 1081, 1105, 1141, 1139, 1109, 1103, 168, 33, 8221, 1122, 63188, 37, 180, 8217, 40, 41, 42, 1123, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 171, 305, 187, 63, 728, 1040, 1041, 1062, 1044, 1045, 1060, 1043, 1061, 1048, 1032, 1050, 1051, 1052, 1053, 1054, 1055, 1063, 1056, 1057, 1058, 1059, 1042, 1065, 1064, 1067, 1047, 91, 8220, 93, 1068, 1066, 8216, 1072, 1073, 1094, 1076, 1077, 1092, 1075, 1093, 1080, 1112, 1082, 1083, 1084, 1085, 1086, 1087, 1095, 1088, 1089, 1090, 1091, 1074, 1097, 1096, 1099, 1079, 8211, 8212, 8470, 1100, 1098};
int t2aUnicode[256] = {96, 180, 710, 732, 168, 733, 730, 711, 728, 175, 729, 184, 731, 1216, 9001, 9002, 8220, 8221, 63189, 63190, 63188, 8211, 8212, 65279, 8320, 305, 567, 64256, 64257, 64258, 64259, 64260, 32, 33, 34, 35, 36, 37, 38, 8217, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 8216, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 45, 1168, 1170, 1026, 1035, 1210, 1174, 1176, 1033, 1031, 1178, 1184, 1180, 1236, 1186, 1188, 1029, 1256, 1194, 1038, 1198, 1200, 1202, 1039, 1208, 1206, 1028, 1240, 1034, 1025, 8470, 164, 167, 1169, 1171, 1106, 1115, 1211, 1175, 1177, 1113, 1111, 1179, 1185, 1181, 1237, 1187, 1189, 1109, 1257, 1195, 1118, 1199, 1201, 1203, 1119, 1209, 1207, 1108, 1241, 1114, 1105, 8222, 171, 187, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103};
int t2bUnicode[256] = {96, 180, 710, 732, 168, 733, 730, 711, 728, 175, 729, 184, 731, 1216, 9001, 9002, 8220, 8221, 63189, 63190, 63188, 8211, 8212, 65279, 8320, 305, 567, 64256, 64257, 64258, 64259, 64260, 32, 33, 34, 35, 36, 37, 38, 8217, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 8216, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 45, 1274, 1170, 1270, 1172, 1210, 1174, 916, 1248, 1033, 1178, 1221, 1219, 1298, 1186, 1188, 1223, 1256, 1057, 1038, 1198, 1278, 1202, 1276, 1227, 1206, 1034, 1240, 917, 1025, 8470, 164, 167, 1275, 1171, 1271, 1173, 1211, 1175, 948, 1249, 1113, 1179, 1222, 1220, 1308, 1187, 1189, 1224, 1257, 1089, 1118, 1199, 1279, 1203, 1277, 1228, 1207, 1114, 1241, 949, 1105, 8222, 171, 187, 1040, 1041, 1042, 1043, 1044, 1045, 1046, 1047, 1048, 1049, 1050, 1051, 1052, 1053, 1054, 1055, 1056, 1057, 1058, 1059, 1060, 1061, 1062, 1063, 1064, 1065, 1066, 1067, 1068, 1069, 1070, 1071, 1072, 1073, 1074, 1075, 1076, 1077, 1078, 1079, 1080, 1081, 1082, 1083, 1084, 1085, 1086, 1087, 1088, 1089, 1090, 1091, 1092, 1093, 1094, 1095, 1096, 1097, 1098, 1099, 1100, 1101, 1102, 1103};

void CmdOT2Transliteration(int cThis)
{
    int cNext;
    int cThird;
    char tmp;
    char tmp___0;
    char tmp___1;
    char tmp___2;
    char tmp___3;
    char tmp___4;
    char tmp___5;
    char tmp___6;
    char tmp___7;
    char tmp___8;
    char tmp___9;
    char tmp___10;
    char tmp___11;
    char tmp___12;
    char tmp___13;
    char tmp___14;
    char tmp___15;
    char tmp___16;
    char tmp___17;
    char tmp___18;
    char tmp___19;
    char tmp___20;
    {
        {
            if (cThis == 100){
                goto case_100;
            }
            if (cThis == 122){
                goto case_122;
            }
            if (cThis == 108){
                goto case_108;
            }
            if (cThis == 110){
                goto case_110;
            }
            if (cThis == 107){
                goto case_107;
            }
            if (cThis == 116){
                goto case_116;
            }
            if (cThis == 99){
                goto case_99;
            }
            if (cThis == 115){
                goto case_115;
            }
            if (cThis == 121){
                goto case_121;
            }
            if (cThis == 68){
                goto case_68;
            }
            if (cThis == 90){
                goto case_90;
            }
            if (cThis == 76){
                goto case_76;
            }
            if (cThis == 78){
                goto case_78;
            }
            if (cThis == 75){
                goto case_75;
            }
            if (cThis == 84){
                goto case_84;
            }
            if (cThis == 67){
                goto case_67;
            }
            if (cThis == 83){
                goto case_83;
            }
            if (cThis == 89){
                goto case_89;
            }
            goto switch_default;
            case_100:
            {
                tmp = getTexChar();
                cNext = (int)tmp;
            }
            if (cNext == 106){
                {
                    CmdUnicodeChar(1106);
                }
            }else{
                {
                    ungetTexChar((char)cNext);
                    CmdUnicodeChar(ot2Unicode[cThis]);
                }
            }
            goto switch_break;
            case_122:
            {
                tmp___0 = getTexChar();
                cNext = (int)tmp___0;
            }
            if (cNext == 104){
                {
                    CmdUnicodeChar(1078);
                }
            }else{
                {
                    ungetTexChar((char)cNext);
                    CmdUnicodeChar(ot2Unicode[cThis]);
                }
            }
            goto switch_break;
            case_108:
            {
                tmp___1 = getTexChar();
                cNext = (int)tmp___1;
            }
            if (cNext == 106){
                {
                    CmdUnicodeChar(1113);
                }
            }else{
                {
                    ungetTexChar((char)cNext);
                    CmdUnicodeChar(ot2Unicode[cThis]);
                }
            }
            goto switch_break;
            case_110:
            {
                tmp___2 = getTexChar();
                cNext = (int)tmp___2;
            }
            if (cNext == 106){
                {
                    CmdUnicodeChar(1114);
                }
            }else{
                {
                    ungetTexChar((char)cNext);
                    CmdUnicodeChar(ot2Unicode[cThis]);
                }
            }
            goto switch_break;
            case_107:
            {
                tmp___3 = getTexChar();
                cNext = (int)tmp___3;
            }
            if (cNext == 104){
                {
                    CmdUnicodeChar(1093);
                }
            }else{
                {
                    ungetTexChar((char)cNext);
                    CmdUnicodeChar(ot2Unicode[cThis]);
                }
            }
            goto switch_break;
            case_116:
            {
                tmp___4 = getTexChar();
                cNext = (int)tmp___4;
            }
            if (cNext == 115){
                {
                    CmdUnicodeChar(1094);
                }
            }else{
                {
                    ungetTexChar((char)cNext);
                    CmdUnicodeChar(ot2Unicode[cThis]);
                }
            }
            goto switch_break;
            case_99:
            {
                tmp___5 = getTexChar();
                cNext = (int)tmp___5;
            }
            if (cNext == 104){
                {
                    CmdUnicodeChar(1095);
                }
            }else{
                {
                    ungetTexChar((char)cNext);
                    CmdUnicodeChar(ot2Unicode[cThis]);
                }
            }
            goto switch_break;
            case_115:
            {
                tmp___6 = getTexChar();
                cNext = (int)tmp___6;
            }
            if (cNext != 104){
                {
                    CmdUnicodeChar(ot2Unicode[cThis]);
                    ungetTexChar((char)cNext);
                }
                goto switch_break;
            }
            {
                tmp___7 = getTexChar();
                cThird = (int)tmp___7;
            }
            if (cThird != 99){
                {
                    CmdUnicodeChar(1096);
                    ungetTexChar((char)cThird);
                }
                goto switch_break;
            }
            {
                tmp___8 = getTexChar();
                cNext = (int)tmp___8;
            }
            if (cNext != 104){
                {
                    CmdUnicodeChar(1096);
                    CmdUnicodeChar(ot2Unicode[cThird]);
                    ungetTexChar((char)cNext);
                }
                goto switch_break;
            }
            {
                CmdUnicodeChar(1097);
            }
            goto switch_break;
            case_121:
            {
                tmp___9 = getTexChar();
                cNext = (int)tmp___9;
            }
            if (cNext == 97){
                {
                    CmdUnicodeChar(1103);
                    ungetTexChar((char)cNext);
                }
                goto switch_break;
            }
            if (cNext == 117){
                {
                    CmdUnicodeChar(1102);
                    ungetTexChar((char)cNext);
                }
                goto switch_break;
            }
            {
                CmdUnicodeChar(ot2Unicode[cThis]);
                ungetTexChar((char)cNext);
            }
            goto switch_break;
            case_68:
            {
                tmp___10 = getTexChar();
                cNext = (int)tmp___10;
            }
            if (cNext == 106){
                {
                    CmdUnicodeChar(1026);
                }
            }else
                if (cNext == 74){
                    {
                        CmdUnicodeChar(1026);
                    }
                }else{
                    {
                        ungetTexChar((char)cNext);
                        CmdUnicodeChar(ot2Unicode[cThis]);
                    }
                }

            goto switch_break;
            case_90:
            {
                tmp___11 = getTexChar();
                cNext = (int)tmp___11;
            }
            if (cNext == 104){
                {
                    CmdUnicodeChar(1046);
                }
            }else
                if (cNext == 72){
                    {
                        CmdUnicodeChar(1046);
                    }
                }else{
                    {
                        ungetTexChar((char)cNext);
                        CmdUnicodeChar(ot2Unicode[cThis]);
                    }
                }

            goto switch_break;
            case_76:
            {
                tmp___12 = getTexChar();
                cNext = (int)tmp___12;
            }
            if (cNext == 106){
                {
                    CmdUnicodeChar(1033);
                }
            }else
                if (cNext == 74){
                    {
                        CmdUnicodeChar(1033);
                    }
                }else{
                    {
                        ungetTexChar((char)cNext);
                        CmdUnicodeChar(ot2Unicode[cThis]);
                    }
                }

            goto switch_break;
            case_78:
            {
                tmp___13 = getTexChar();
                cNext = (int)tmp___13;
            }
            if (cNext == 106){
                {
                    CmdUnicodeChar(1034);
                }
            }else
                if (cNext == 74){
                    {
                        CmdUnicodeChar(1034);
                    }
                }else{
                    {
                        ungetTexChar((char)cNext);
                        CmdUnicodeChar(ot2Unicode[cThis]);
                    }
                }

            goto switch_break;
            case_75:
            {
                tmp___14 = getTexChar();
                cNext = (int)tmp___14;
            }
            if (cNext == 104){
                {
                    CmdUnicodeChar(1061);
                }
            }else
                if (cNext == 72){
                    {
                        CmdUnicodeChar(1061);
                    }
                }else{
                    {
                        ungetTexChar((char)cNext);
                        CmdUnicodeChar(ot2Unicode[cThis]);
                    }
                }

            goto switch_break;
            case_84:
            {
                tmp___15 = getTexChar();
                cNext = (int)tmp___15;
            }
            if (cNext == 115){
                {
                    CmdUnicodeChar(1062);
                }
            }else
                if (cNext == 83){
                    {
                        CmdUnicodeChar(1062);
                    }
                }else{
                    {
                        ungetTexChar((char)cNext);
                        CmdUnicodeChar(ot2Unicode[cThis]);
                    }
                }

            goto switch_break;
            case_67:
            {
                tmp___16 = getTexChar();
                cNext = (int)tmp___16;
            }
            if (cNext == 104){
                {
                    CmdUnicodeChar(1063);
                }
            }else
                if (cNext == 72){
                    {
                        CmdUnicodeChar(1063);
                    }
                }else{
                    {
                        ungetTexChar((char)cNext);
                        CmdUnicodeChar(ot2Unicode[cThis]);
                    }
                }

            goto switch_break;
            case_83:
            {
                tmp___17 = getTexChar();
                cNext = (int)tmp___17;
            }
            if (cNext != 104){
                if (cNext != 72){
                    {
                        CmdUnicodeChar(ot2Unicode[cThis]);
                        ungetTexChar((char)cNext);
                    }
                    goto switch_break;
                }
            }
            {
                tmp___18 = getTexChar();
                cThird = (int)tmp___18;
            }
            if (cThird != 99){
                if (cThird != 99){
                    {
                        CmdUnicodeChar(1064);
                        ungetTexChar((char)cThird);
                    }
                    goto switch_break;
                }
            }
            {
                tmp___19 = getTexChar();
                cNext = (int)tmp___19;
            }
            if (cNext != 104){
                if (cNext != 72){
                    {
                        CmdUnicodeChar(1064);
                        CmdUnicodeChar(ot2Unicode[cThird]);
                        ungetTexChar((char)cNext);
                    }
                    goto switch_break;
                }
            }
            {
                CmdUnicodeChar(1065);
            }
            goto switch_break;
            case_89:
            {
                tmp___20 = getTexChar();
                cNext = (int)tmp___20;
            }
            if (cNext == 97){
                {
                    CmdUnicodeChar(1071);
                    ungetTexChar((char)cNext);
                }
                goto switch_break;
            }else
                if (cNext == 65){
                    {
                        CmdUnicodeChar(1071);
                        ungetTexChar((char)cNext);
                    }
                    goto switch_break;
                }

            if (cNext == 117){
                {
                    CmdUnicodeChar(1070);
                    ungetTexChar((char)cNext);
                }
                goto switch_break;
            }else
                if (cNext == 85){
                    {
                        CmdUnicodeChar(1070);
                        ungetTexChar((char)cNext);
                    }
                    goto switch_break;
                }

            {
                CmdUnicodeChar(ot2Unicode[cThis]);
                ungetTexChar((char)cNext);
            }
            goto switch_break;
            switch_default:
            {
                CmdUnicodeChar(ot2Unicode[cThis]);
            }
            goto switch_break;
            switch_break:
            ;
        }
        return;
    }
}

void CmdChar(int code)
{
    char c;
    int tmp;
    int tmp___0;
    {
        {
            tmp = CurrentFontFamily();
            tmp___0 = TexFontNumber("Typewriter");
        }
        if (tmp == tmp___0){
            {
                CmdUnicodeChar(cmttUnicode[code]);
            }
        }else{
            {
                CmdUnicodeChar(cmrUnicode[code]);
            }
        }
        {
            c = getNonBlank();
            ungetTexChar(c);
        }
        return;
    }
}

void WriteEightBitChar(unsigned char cThis, FILE* f)
{
    int eightbit_index;
    int tmp;
    int tmp___0;
    int tmp___1;
    int tmp___2;
    int tmp___3;
    int tmp___4;
    int tmp___5;
    int tmp___6;
    int tmp___7;
    int tmp___8;
    int tmp___9;
    int tmp___10;
    int tmp___11;
    int tmp___12;
    int tmp___13;
    int tmp___14;
    int tmp___15;
    int tmp___16;
    int tmp___17;
    int tmp___18;
    int tmp___19;
    int tmp___20;
    int tmp___21;
    int tmp___22;
    {
        if ((int)cThis <= 127){
            {
                fputc((int)cThis, f);
            }
            return;
        }
        {
            eightbit_index = (int)cThis - 128;
            tmp = CurrentFontEncoding();
            diagnostics(6, (char*)"  WriteEightBitChar \'%c\' char=%3d index=%d encoding=%2d", (int)cThis, (unsigned int)cThis, eightbit_index, tmp);
            tmp___22 = CurrentFontEncoding();
        }
        if (tmp___22 == 28){
            {
                fprintRTF((char*)"\\\'%2X", (int)cThis);
            }
        }else{
            {
                tmp___21 = CurrentFontEncoding();
            }
            if (tmp___21 == 11){
                {
                    CmdUnicodeChar(cp1251Unicode[eightbit_index]);
                }
            }else{
                {
                    tmp___20 = CurrentFontEncoding();
                }
                if (tmp___20 == 14){
                    {
                        CmdUnicodeChar(appleUnicode[eightbit_index]);
                    }
                }else{
                    {
                        tmp___19 = CurrentFontEncoding();
                    }
                    if (tmp___19 == 3){
                        {
                            CmdUnicodeChar(cp437Unicode[eightbit_index]);
                        }
                    }else{
                        {
                            tmp___18 = CurrentFontEncoding();
                        }
                        if (tmp___18 == 4){
                            {
                                CmdUnicodeChar(cp850Unicode[eightbit_index]);
                            }
                        }else{
                            {
                                tmp___17 = CurrentFontEncoding();
                            }
                            if (tmp___17 == 5){
                                {
                                    CmdUnicodeChar(cp852Unicode[eightbit_index]);
                                }
                            }else{
                                {
                                    tmp___16 = CurrentFontEncoding();
                                }
                                if (tmp___16 == 6){
                                    {
                                        CmdUnicodeChar(cp855Unicode[eightbit_index]);
                                    }
                                }else{
                                    {
                                        tmp___15 = CurrentFontEncoding();
                                    }
                                    if (tmp___15 == 8){
                                        {
                                            CmdUnicodeChar(cp865Unicode[eightbit_index]);
                                        }
                                    }else{
                                        {
                                            tmp___14 = CurrentFontEncoding();
                                        }
                                        if (tmp___14 == 9){
                                            {
                                                CmdUnicodeChar(cp866Unicode[eightbit_index]);
                                            }
                                        }else{
                                            {
                                                tmp___13 = CurrentFontEncoding();
                                            }
                                            if (tmp___13 == 10){
                                                {
                                                    CmdUnicodeChar(cp1250Unicode[eightbit_index]);
                                                }
                                            }else{
                                                {
                                                    tmp___12 = CurrentFontEncoding();
                                                }
                                                if (tmp___12 == 12){
                                                    {
                                                        CmdUnicodeChar(cp1252Unicode[eightbit_index]);
                                                    }
                                                }else{
                                                    {
                                                        tmp___11 = CurrentFontEncoding();
                                                    }
                                                    if (tmp___11 == 20){
                                                        {
                                                            CmdUnicodeChar(latin2Unicode[eightbit_index]);
                                                        }
                                                    }else{
                                                        {
                                                            tmp___10 = CurrentFontEncoding();
                                                        }
                                                        if (tmp___10 == 21){
                                                            {
                                                                CmdUnicodeChar(latin3Unicode[eightbit_index]);
                                                            }
                                                        }else{
                                                            {
                                                                tmp___9 = CurrentFontEncoding();
                                                            }
                                                            if (tmp___9 == 22){
                                                                {
                                                                    CmdUnicodeChar(latin4Unicode[eightbit_index]);
                                                                }
                                                            }else{
                                                                {
                                                                    tmp___8 = CurrentFontEncoding();
                                                                }
                                                                if (tmp___8 == 23){
                                                                    {
                                                                        CmdUnicodeChar(latin5Unicode[eightbit_index]);
                                                                    }
                                                                }else{
                                                                    {
                                                                        tmp___7 = CurrentFontEncoding();
                                                                    }
                                                                    if (tmp___7 == 24){
                                                                        {
                                                                            CmdUnicodeChar(latin9Unicode[eightbit_index]);
                                                                        }
                                                                    }else{
                                                                        {
                                                                            tmp___6 = CurrentFontEncoding();
                                                                        }
                                                                        if (tmp___6 == 25){
                                                                            {
                                                                                CmdUnicodeChar(latin10Unicode[eightbit_index]);
                                                                            }
                                                                        }else{
                                                                            {
                                                                                tmp___5 = CurrentFontEncoding();
                                                                            }
                                                                            if (tmp___5 == 26){
                                                                                {
                                                                                    CmdUnicodeChar(nextUnicode[eightbit_index]);
                                                                                }
                                                                            }else{
                                                                                {
                                                                                    tmp___4 = CurrentFontEncoding();
                                                                                }
                                                                                if (tmp___4 == 18){
                                                                                    {
                                                                                        CmdUnicodeChar(koi8rUnicode[eightbit_index]);
                                                                                    }
                                                                                }else{
                                                                                    {
                                                                                        tmp___3 = CurrentFontEncoding();
                                                                                    }
                                                                                    if (tmp___3 == 19){
                                                                                        {
                                                                                            CmdUnicodeChar(koi8uUnicode[eightbit_index]);
                                                                                        }
                                                                                    }else{
                                                                                        {
                                                                                            tmp___2 = CurrentFontEncoding();
                                                                                        }
                                                                                        if (tmp___2 == 17){
                                                                                            {
                                                                                                CmdUnicodeChar(decmultiUnicode[eightbit_index]);
                                                                                            }
                                                                                        }else{
                                                                                            {
                                                                                                tmp___1 = CurrentFontEncoding();
                                                                                            }
                                                                                            if (tmp___1 == 15){
                                                                                                {
                                                                                                    CmdUnicodeChar(appleCEUnicode[eightbit_index]);
                                                                                                }
                                                                                            }else{
                                                                                                {
                                                                                                    tmp___0 = CurrentFontEncoding();
                                                                                                }
                                                                                                if (tmp___0 == 16){
                                                                                                    {
                                                                                                        CmdUnicodeChar(appleCyrrilicUnicode[eightbit_index]);
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        return;
    }
}

void WriteCFGFontNumber(char** cfg_stream)
{
    int n;
    char* font_name;
    char* star;
    size_t tmp;
    {
        n = -1;
        (*cfg_stream)++;
        if ((int)*(*cfg_stream) == 42){
            {
                fprintRTF((char*)"*");
            }
            return;
        }
        {
            font_name = strdup((const char*)*cfg_stream);
            star = strchr((const char*)font_name, '*');
        }
        if (star){
            {
                *star = (char)'\000';
                n = TexFontNumber((const char*)font_name);
            }
            if (n < 0){
                {
                    diagnostics(0, (char*)"Unknown font <%s>\nFound in cfg line <%s>", font_name, cfg_stream);
                }
            }
            {
                tmp = strlen((const char*)font_name);
                *cfg_stream += tmp;
                fprintRTF((char*)"%d", n);
            }
        }
        {
            free((void*)font_name);
        }
        return;
    }
}

int TryDirectConvert(char* command)
{
    char* buffpoint;
    char* RtfCommand;
    char* TexCommand;
    {
        {
            TexCommand = strdup_together("\\", (const char*)command);
            RtfCommand = SearchCfgRtf((const char*)TexCommand, 0);
        }
        if ((unsigned long )RtfCommand == (unsigned long )((void*)0)){
            {
                free((void*)TexCommand);
            }
            return (0);
        }
        {
            buffpoint = RtfCommand;
            diagnostics(4, (char*)"Directly converting %s to %s", TexCommand, RtfCommand);
        }
        {
            while (1){
                while_continue:
                ;
                if (!((int)*(buffpoint + 0) != 0)){
                    goto while_break;
                }
                if ((int)*(buffpoint + 0) == 42){
                    {
                        WriteCFGFontNumber(&buffpoint);
                    }
                }else{
                    {
                        fprintRTF((char*)"%c", (int)*buffpoint);
                    }
                }
                buffpoint++;
            }
            while_break:
            ;
        }
        {
            free((void*)TexCommand);
        }
        return (1);
    }
}

int DefaultFontShape(void);
int DefaultFontSeries(void);
int DefaultFontEncoding(void);
static RtfFontInfoType RtfFontInfo[301];
static int FontInfoDepth = 0;

int RtfFontNumber(const char* Fname)
{
    ConfigEntryT** config_handle;
    char* font_type;
    char* font_name;
    int font_id;
    int tmp;
    int tmp___0;
    {
        {
            diagnostics(6, (char*)"seeking=%s", Fname);
            config_handle = CfgStartIterate();
        }
        {
            while (1){
                while_continue:
                ;
                {
                    config_handle = CfgNext(1, config_handle);
                }
                if (!((unsigned long )config_handle != (unsigned long )((void*)0))){
                    goto while_break;
                }
                {
                    font_type = (char*)(*config_handle)->TexCommand;
                    font_name = (char*)(*config_handle)->RtfCommand;
                    font_id = (*config_handle)->original_id;
                    diagnostics(6, (char*)"RTF font %d has name=\'%s\' of type=\'%s\'", font_id, font_name, font_type);
                    tmp = strcmp((const char*)font_name, Fname);
                }
                if (tmp == 0){
                    return (font_id);
                }
            }
            while_break:
            ;
        }
        {
            tmp___0 = TexFontNumber("Roman");
        }
        return (tmp___0);
    }
}

int TexFontNumber(const char* Fname)
{
    ConfigEntryT** p;
    int number;
    int tmp;
    int tmp___0;
    int tmp___1;
    int tmp___2;
    {
        {
            number = 0;
            tmp___0 = strcmp(Fname, "CurrentFontSize");
        }
        if (tmp___0 == 0){
            {
                tmp = CurrentFontSize();
            }
            return (tmp);
        }
        {
            tmp___2 = strcmp(Fname, "DefaultFontSize");
        }
        if (tmp___2 == 0){
            {
                tmp___1 = DefaultFontSize();
            }
            return (tmp___1);
        }
        {
            p = SearchCfgEntry(Fname, 1);
        }
        if (p){
            number = (*p)->original_id;
        }
        {
            diagnostics(6, (char*)"TexFontNumber for \'%s\' is %d", Fname, number);
        }
        return (number);
    }
}

void CmdFontFamily(int code)
{
    char* s;
    int num;
    int true_code;
    {
        {
            true_code = code & -16385;
            diagnostics(6, (char*)"CmdFontFamily (before) depth=%d, family=%d, size=%d, shape=%d, series=%d", FontInfoDepth, RtfFontInfo[FontInfoDepth].family, RtfFontInfo[FontInfoDepth].size, RtfFontInfo[FontInfoDepth].shape, RtfFontInfo[FontInfoDepth].series);
        }
        if (!(code & 16384)){
            if (true_code == 16){
                return;
            }else
                if (true_code == 12){
                    return;
                }else
                    if (true_code == 8){
                        return;
                    }else
                        if (true_code == 4){
                            return;
                        }else
                            if (true_code == 19){
                                return;
                            }else
                                if (true_code == 18){
                                    return;
                                }else
                                    if (true_code == 17){
                                        return;
                                    }
        }
        {
            if (true_code == 18){
                goto case_18;
            }
            if (true_code == 8){
                goto case_18;
            }
            if (true_code == 7){
                goto case_18;
            }
            if (true_code == 6){
                goto case_18;
            }
            if (true_code == 5){
                goto case_18;
            }
            if (true_code == 19){
                goto case_19;
            }
            if (true_code == 12){
                goto case_19;
            }
            if (true_code == 11){
                goto case_19;
            }
            if (true_code == 10){
                goto case_19;
            }
            if (true_code == 9){
                goto case_19;
            }
            if (true_code == 16){
                goto case_16;
            }
            if (true_code == 15){
                goto case_16;
            }
            if (true_code == 14){
                goto case_16;
            }
            if (true_code == 13){
                goto case_16;
            }
            goto switch_default;
            case_18:
            case_8:
            case_7:
            case_6:
            case_5:
            {
                num = TexFontNumber("Sans Serif");
            }
            goto switch_break;
            case_19:
            case_12:
            case_11:
            case_10:
            case_9:
            {
                num = TexFontNumber("Typewriter");
            }
            goto switch_break;
            case_16:
            case_15:
            case_14:
            case_13:
            {
                num = TexFontNumber("Calligraphic");
            }
            goto switch_break;
            switch_default:
            {
                num = TexFontNumber("Roman");
            }
            goto switch_break;
            switch_break:
            ;
        }
        {
            if (true_code == 16){
                goto case_16___0;
            }
            if (true_code == 12){
                goto case_16___0;
            }
            if (true_code == 8){
                goto case_16___0;
            }
            if (true_code == 4){
                goto case_16___0;
            }
            if (true_code == 13){
                goto case_16___0;
            }
            if (true_code == 9){
                goto case_16___0;
            }
            if (true_code == 5){
                goto case_16___0;
            }
            if (true_code == 1){
                goto case_16___0;
            }
            if (true_code == 19){
                goto case_19___0;
            }
            if (true_code == 18){
                goto case_19___0;
            }
            if (true_code == 17){
                goto case_19___0;
            }
            if (true_code == 10){
                goto case_19___0;
            }
            if (true_code == 6){
                goto case_19___0;
            }
            if (true_code == 2){
                goto case_19___0;
            }
            if (true_code == 15){
                goto case_15___0;
            }
            if (true_code == 11){
                goto case_15___0;
            }
            if (true_code == 7){
                goto case_15___0;
            }
            if (true_code == 3){
                goto case_15___0;
            }
            goto switch_break___0;
            case_16___0:
            case_12___0:
            case_8___0:
            case_4:
            case_13___0:
            case_9___0:
            case_5___0:
            case_1:
            {
                fprintRTF((char*)"\\f%d ", num);
            }
            goto switch_break___0;
            case_19___0:
            case_18___0:
            case_17:
            case_10___0:
            case_6___0:
            case_2:
            {
                fprintRTF((char*)"\\i0\\scaps0\\b0\\f%d ", num);
            }
            goto switch_break___0;
            case_15___0:
            case_11___0:
            case_7___0:
            case_3:
            {
                fprintRTF((char*)"{\\f%d ", num);
                s = getBraceParam();
                ConvertString((const char*)s);
                free((void*)s);
                fprintRTF((char*)"}");
            }
            goto switch_break___0;
            switch_break___0:
            ;
        }
        {
            diagnostics(6, (char*)"CmdFontFamily (after) depth=%d, family=%d, size=%d, shape=%d, series=%d", FontInfoDepth, RtfFontInfo[FontInfoDepth].family, RtfFontInfo[FontInfoDepth].size, RtfFontInfo[FontInfoDepth].shape, RtfFontInfo[FontInfoDepth].series);
        }
        return;
    }
}

void CmdFontShape(int code)
{
    int true_code;
    char* s;
    {
        {
            true_code = code & -16385;
            diagnostics(5, (char*)"CmdFontShape (before) depth=%d, family=%d, size=%d, shape=%d, series=%d", FontInfoDepth, RtfFontInfo[FontInfoDepth].family, RtfFontInfo[FontInfoDepth].size, RtfFontInfo[FontInfoDepth].shape, RtfFontInfo[FontInfoDepth].series);
        }
        if (!(code & 16384)){
            if (true_code == 16){
                return;
            }else
                if (true_code == 8){
                    return;
                }else
                    if (true_code == 4){
                        return;
                    }else
                        if (true_code == 12){
                            return;
                        }else
                            if (true_code == 18){
                                return;
                            }else
                                if (true_code == 17){
                                    return;
                                }else
                                    if (true_code == 19){
                                        return;
                                    }
        }
        {
            if (true_code == 16){
                goto case_16;
            }
            if (true_code == 13){
                goto case_16;
            }
            if (true_code == 14){
                goto case_14;
            }
            if (true_code == 15){
                goto case_15;
            }
            if (true_code == 5){
                goto case_5;
            }
            if (true_code == 1){
                goto case_5;
            }
            if (true_code == 6){
                goto case_6;
            }
            if (true_code == 2){
                goto case_6;
            }
            if (true_code == 7){
                goto case_7;
            }
            if (true_code == 3){
                goto case_7;
            }
            if (true_code == 8){
                goto case_8;
            }
            if (true_code == 4){
                goto case_8;
            }
            if (true_code == 18){
                goto case_18;
            }
            if (true_code == 17){
                goto case_18;
            }
            if (true_code == 12){
                goto case_12;
            }
            if (true_code == 9){
                goto case_12;
            }
            if (true_code == 19){
                goto case_19;
            }
            if (true_code == 10){
                goto case_19;
            }
            if (true_code == 11){
                goto case_11;
            }
            goto switch_break;
            case_16:
            case_13:
            {
                fprintRTF((char*)"\\i0\\scaps0 ");
            }
            goto switch_break;
            case_14:
            {
                fprintRTF((char*)"\\i0\\scaps0\\b0 ");
            }
            goto switch_break;
            case_15:
            {
                fprintRTF((char*)"{\\i0\\b0\\scaps0 ");
            }
            goto switch_break;
            case_5:
            case_1:
            {
                fprintRTF((char*)"\\scaps0\\i ");
            }
            goto switch_break;
            case_6:
            case_2:
            {
                fprintRTF((char*)"\\scaps0\\b0\\i ");
            }
            goto switch_break;
            case_7:
            case_3:
            {
                fprintRTF((char*)"{\\i ");
            }
            goto switch_break;
            case_8:
            case_4:
            {
                fprintRTF((char*)"\\scaps0\\i ");
            }
            goto switch_break;
            case_18:
            case_17:
            {
                fprintRTF((char*)"\\scaps0\\b0\\i ");
            }
            goto switch_break;
            case_12:
            case_9:
            {
                fprintRTF((char*)"\\scaps ");
            }
            goto switch_break;
            case_19:
            case_10:
            {
                fprintRTF((char*)"\\i0\\b0\\scaps ");
            }
            goto switch_break;
            case_11:
            {
                fprintRTF((char*)"{\\scaps ");
            }
            goto switch_break;
            switch_break:
            ;
        }
        if (true_code == 15){
            {
                s = getBraceParam();
                ConvertString((const char*)s);
                fprintRTF((char*)"}");
                free((void*)s);
            }
        }else
            if (true_code == 7){
                {
                    s = getBraceParam();
                    ConvertString((const char*)s);
                    fprintRTF((char*)"}");
                    free((void*)s);
                }
            }else
                if (true_code == 3){
                    {
                        s = getBraceParam();
                        ConvertString((const char*)s);
                        fprintRTF((char*)"}");
                        free((void*)s);
                    }
                }else
                    if (true_code == 11){
                        {
                            s = getBraceParam();
                            ConvertString((const char*)s);
                            fprintRTF((char*)"}");
                            free((void*)s);
                        }
                    }

        {
            diagnostics(5, (char*)"CmdFontShape (after) depth=%d, family=%d, size=%d, shape=%d, series=%d", FontInfoDepth, RtfFontInfo[FontInfoDepth].family, RtfFontInfo[FontInfoDepth].size, RtfFontInfo[FontInfoDepth].shape, RtfFontInfo[FontInfoDepth].series);
        }
        return;
    }
}

void CmdFontSeries(int code)
{
    int true_code;
    int tmp;
    char* s;
    {
        {
            true_code = code & -16385;
            diagnostics(5, (char*)"CmdFontSeries (before) depth=%d, family=%d, size=%d, shape=%d, series=%d", FontInfoDepth, RtfFontInfo[FontInfoDepth].family, RtfFontInfo[FontInfoDepth].size, RtfFontInfo[FontInfoDepth].shape, RtfFontInfo[FontInfoDepth].series);
        }
        if (true_code == 4){
            goto _L;
        }else
            if (true_code == 8){
                goto _L;
            }else
                if (true_code == 9){
                    _L:
                    if (!(code & 16384)){
                        return;
                    }
                }

        {
            tmp = getTexMode();
        }
        if (tmp == 6){
            {
                changeTexMode(2);
            }
        }
        {
            if (code == 1){
                goto case_1;
            }
            if (code == 4){
                goto case_1;
            }
            if (code == 2){
                goto case_2;
            }
            if (code == 3){
                goto case_3;
            }
            if (code == 8){
                goto case_8;
            }
            if (code == 5){
                goto case_8;
            }
            if (code == 9){
                goto case_9;
            }
            if (code == 6){
                goto case_9;
            }
            if (code == 7){
                goto case_7;
            }
            goto switch_break;
            case_1:
            case_4:
            {
                fprintRTF((char*)"\\b0 ");
            }
            goto switch_break;
            case_2:
            {
                fprintRTF((char*)"\\i0\\scaps0\\b0 ");
            }
            goto switch_break;
            case_3:
            {
                fprintRTF((char*)"{\\b0 ");
            }
            goto switch_break;
            case_8:
            case_5:
            {
                fprintRTF((char*)"\\b ");
            }
            goto switch_break;
            case_9:
            case_6:
            {
                fprintRTF((char*)"\\i0\\scaps0\\b ");
            }
            goto switch_break;
            case_7:
            {
                fprintRTF((char*)"{\\b ");
            }
            goto switch_break;
            switch_break:
            ;
        }
        if (true_code == 7){
            {
                s = getBraceParam();
                ConvertString((const char*)s);
                fprintRTF((char*)"}");
                free((void*)s);
            }
        }else
            if (true_code == 3){
                {
                    s = getBraceParam();
                    ConvertString((const char*)s);
                    fprintRTF((char*)"}");
                    free((void*)s);
                }
            }

        {
            diagnostics(5, (char*)"CmdFontShape (after) depth=%d, family=%d, size=%d, shape=%d, series=%d", FontInfoDepth, RtfFontInfo[FontInfoDepth].family, RtfFontInfo[FontInfoDepth].size, RtfFontInfo[FontInfoDepth].shape, RtfFontInfo[FontInfoDepth].series);
        }
        return;
    }
}

void CmdFontSize(int code)
{
    int scaled_size;
    int tmp;
    int tmp___0;
    int tmp___1;
    int tmp___2;
    {
        {
            diagnostics(5, (char*)"CmdFontSize (before) depth=%d, family=%d, size=%d, shape=%d, series=%d", FontInfoDepth, RtfFontInfo[FontInfoDepth].family, RtfFontInfo[FontInfoDepth].size, RtfFontInfo[FontInfoDepth].shape, RtfFontInfo[FontInfoDepth].series);
            tmp = getTexMode();
        }
        if (tmp == 6){
            {
                changeTexMode(2);
            }
        }
        if (code == -1){
            {
                tmp___0 = CurrentFontSize();
                scaled_size = (int)((double)tmp___0 / 1.2 + 0.5);
            }
        }else
            if (code == -2){
                {
                    tmp___1 = CurrentFontSize();
                    scaled_size = (int)((double)tmp___1 * 1.2 + 0.5);
                }
            }else{
                {
                    tmp___2 = DefaultFontSize();
                    scaled_size = (int)((double)(code * tmp___2) / 20.0 + 0.5);
                }
            }

        {
            fprintRTF((char*)"\\fs%d ", scaled_size);
            diagnostics(5, (char*)"CmdFontSize (after) depth=%d, family=%d, size=%d, shape=%d, series=%d", FontInfoDepth, RtfFontInfo[FontInfoDepth].family, RtfFontInfo[FontInfoDepth].size, RtfFontInfo[FontInfoDepth].shape, RtfFontInfo[FontInfoDepth].series);
        }
        return;
    }
}

void CmdEmphasize(int code)
{
    int true_code;
    int tmp;
    int tmp___0;
    int tmp___1;
    {
        {
            true_code = code & -16385;
            diagnostics(5, (char*)"CmdEmphasize (before) depth=%d, family=%d, size=%d, shape=%d, series=%d", FontInfoDepth, RtfFontInfo[FontInfoDepth].family, RtfFontInfo[FontInfoDepth].size, RtfFontInfo[FontInfoDepth].shape, RtfFontInfo[FontInfoDepth].series);
            tmp = getTexMode();
        }
        if (tmp == 6){
            {
                changeTexMode(2);
            }
        }
        if (true_code == 4){
            if (!(code & 16384)){
                return;
            }
        }
        if (true_code == 3){
            {
                tmp___0 = CurrentFontShape();
            }
            if (tmp___0 == 13){
                {
                    CmdFontShape(7);
                }
            }else{
                {
                    CmdFontShape(15);
                }
            }
        }else{
            {
                tmp___1 = CurrentFontShape();
            }
            if (tmp___1 == 13){
                {
                    fprintRTF((char*)"\\i ");
                }
            }else{
                {
                    fprintRTF((char*)"\\i0 ");
                }
            }
        }
        {
            diagnostics(5, (char*)"CmdEmphasize (after) depth=%d, family=%d, size=%d, shape=%d, series=%d", FontInfoDepth, RtfFontInfo[FontInfoDepth].family, RtfFontInfo[FontInfoDepth].size, RtfFontInfo[FontInfoDepth].shape, RtfFontInfo[FontInfoDepth].series);
        }
        return;
    }
}

void CmdUnderline(int code)
{
    char* s;
    int tmp;
    {
        {
            diagnostics(5, (char*)"Entering CmdUnderline");
            tmp = getTexMode();
        }
        if (tmp == 6){
            {
                changeTexMode(2);
            }
        }
        {
            fprintRTF((char*)"{\\ul ");
            s = getBraceParam();
            ConvertString((const char*)s);
            free((void*)s);
            fprintRTF((char*)"}");
            diagnostics(5, (char*)"Exiting CmdUnderline");
        }
        return;
    }
}

void CmdTextNormal(int code)
{
    int true_code;
    int tmp;
    int tmp___0;
    int tmp___1;
    int tmp___2;
    int tmp___3;
    int tmp___4;
    int tmp___5;
    int tmp___6;
    int tmp___7;
    int tmp___8;
    int tmp___9;
    int tmp___10;
    int tmp___11;
    char* s;
    {
        {
            true_code = code & -16385;
            diagnostics(5, (char*)"CmdTextNormal (before) depth=%d, family=%d, size=%d, shape=%d, series=%d", FontInfoDepth, RtfFontInfo[FontInfoDepth].family, RtfFontInfo[FontInfoDepth].size, RtfFontInfo[FontInfoDepth].shape, RtfFontInfo[FontInfoDepth].series);
        }
        if (true_code == 4){
            if (!(code & 16384)){
                return;
            }
        }
        {
            tmp = getTexMode();
        }
        if (tmp == 6){
            {
                changeTexMode(2);
            }
        }
        if (code == 3){
            {
                fprintRTF((char*)"{");
            }
        }
        {
            tmp___1 = CurrentFontShape();
            tmp___2 = DefaultFontShape();
        }
        if (tmp___1 != tmp___2){
            {
                tmp___0 = DefaultFontShape();
                CmdFontShape(tmp___0);
            }
        }
        {
            tmp___4 = CurrentFontSeries();
            tmp___5 = DefaultFontSeries();
        }
        if (tmp___4 != tmp___5){
            {
                tmp___3 = DefaultFontSeries();
                CmdFontSeries(tmp___3);
            }
        }
        {
            tmp___7 = CurrentFontSize();
            tmp___8 = DefaultFontSize();
        }
        if (tmp___7 != tmp___8){
            {
                tmp___6 = DefaultFontSize();
                CmdFontSize(tmp___6);
            }
        }
        {
            tmp___10 = CurrentFontFamily();
            tmp___11 = DefaultFontFamily();
        }
        if (tmp___10 != tmp___11){
            {
                tmp___9 = DefaultFontFamily();
                CmdFontFamily(tmp___9);
            }
        }
        if (code == 3){
            {
                s = getBraceParam();
                ConvertString((const char*)s);
                free((void*)s);
                fprintRTF((char*)"}");
            }
        }
        {
            diagnostics(5, (char*)"CmdTextNormal (after) depth=%d, family=%d, size=%d, shape=%d, series=%d", FontInfoDepth, RtfFontInfo[FontInfoDepth].family, RtfFontInfo[FontInfoDepth].size, RtfFontInfo[FontInfoDepth].shape, RtfFontInfo[FontInfoDepth].series);
        }
        return;
    }
}

static int strstart(const unsigned char* text, const char* str)
{
    {
        {
            while (1){
                while_continue:
                ;
                if (*str){
                    if (!((const int)*str == (const int)*text)){
                        goto while_break;
                    }
                }else{
                    goto while_break;
                }
                str++;
                text++;
            }
            while_break:
            ;
        }
        if (*str){
            return (0);
        }else{
            return (1);
        }
    }
}

static int strstartnum(const unsigned char* text, const char* str, int* num)
{
    const unsigned char* numptr;
    int tmp;
    size_t tmp___0;
    const unsigned short **tmp___1;
    {
        {
            *num = 0;
            tmp = strstart(text, str);
        }
        if (!tmp){
            return (0);
        }
        {
            tmp___0 = strlen(str);
            text += tmp___0;
            numptr = text;
        }
        {
            while (1){
                while_continue:
                ;
                {
                    tmp___1 = __ctype_b_loc();
                }
                if (!((const int)*(*tmp___1 + (int)*numptr) & 2048)){
                    goto while_break;
                }
                *num = *num * 10 + (int)((const int)*numptr - 48);
                numptr++;
            }
            while_break:
            ;
        }
        if ((unsigned long )numptr == (unsigned long )text){
            return (0);
        }else{
            return (1);
        }
    }
}

void InitializeDocumentFont(int family, int size, int shape, int series, int encoding)
{
    {
        if (size >= 0){
            RtfFontInfo[0].size = size;
        }
        if (family >= 0){
            RtfFontInfo[0].family = family;
        }
        if (shape >= 0){
            RtfFontInfo[0].shape = shape;
        }
        if (series >= 0){
            RtfFontInfo[0].series = series;
        }
        if (encoding >= 0){
            RtfFontInfo[0].encoding = encoding;
        }
        {
            diagnostics(5, (char*)"InitializeDocumentFont family=%d, size=%d, shape=%d, series=%d", RtfFontInfo[0].family, RtfFontInfo[0].size, RtfFontInfo[0].shape, RtfFontInfo[0].series);
        }
        return;
    }
}

int DefaultFontFamily(void)
{
    {
        {
            diagnostics(5, (char*)"DefaultFontFamily -- family=%d", RtfFontInfo[0].family);
        }
        return (RtfFontInfo[0].family);
    }
}

int DefaultFontSize(void)
{
    {
        {
            diagnostics(5, (char*)"DefaultFontSize -- size=%d", RtfFontInfo[0].size);
        }
        return (RtfFontInfo[0].size);
    }
}

int DefaultFontShape(void)
{
    {
        {
            diagnostics(5, (char*)"DefaultFontShape -- shape=%d", RtfFontInfo[0].shape);
        }
        return (RtfFontInfo[0].shape);
    }
}

int DefaultFontSeries(void)
{
    {
        {
            diagnostics(5, (char*)"DefaultFontSeries -- series=%d", RtfFontInfo[0].series);
        }
        return (RtfFontInfo[0].series);
    }
}

int DefaultFontEncoding(void)
{
    {
        {
            diagnostics(5, (char*)"DefaultFontSeries -- series=%d", RtfFontInfo[0].encoding);
        }
        return (RtfFontInfo[0].encoding);
    }
}

int CurrentFontFamily(void)
{
    {
        {
            diagnostics(5, (char*)"CurrentFontFamily -- family=%d", RtfFontInfo[FontInfoDepth].family);
        }
        return (RtfFontInfo[FontInfoDepth].family);
    }
}

int CurrentFontShape(void)
{
    {
        {
            diagnostics(5, (char*)"CurrentFontShape -- shape=%d", RtfFontInfo[FontInfoDepth].shape);
        }
        return (RtfFontInfo[FontInfoDepth].shape);
    }
}

int CurrentFontSize(void)
{
    {
        {
            diagnostics(5, (char*)"CurrentFontSize -- size=%d", RtfFontInfo[FontInfoDepth].size);
        }
        return (RtfFontInfo[FontInfoDepth].size);
    }
}

int CurrentFontSeries(void)
{
    {
        {
            diagnostics(5, (char*)"CurrentFontSeries -- series=%d", RtfFontInfo[FontInfoDepth].series);
        }
        return (RtfFontInfo[FontInfoDepth].series);
    }
}

int CurrentFontEncoding(void)
{
    {
        {
            diagnostics(5, (char*)"CurrentFontSeries -- encoding=%d", RtfFontInfo[FontInfoDepth].encoding);
        }
        return (RtfFontInfo[FontInfoDepth].encoding);
    }
}

void CmdFontEncoding(int code)
{
    {
        {
            RtfFontInfo[FontInfoDepth].encoding = code;
            diagnostics(5, (char*)"CurrentFontSeries -- encoding=%d", RtfFontInfo[FontInfoDepth].encoding);
        }
        return;
    }
}

void PushFontSettings(void)
{
    {
        if (FontInfoDepth == 301){
            {
                diagnostics(0, (char*)"FontInfoDepth too large, cannot PushFontSettings()!");
            }
        }
        {
            RtfFontInfo[FontInfoDepth + 1].size = RtfFontInfo[FontInfoDepth].size;
            RtfFontInfo[FontInfoDepth + 1].family = RtfFontInfo[FontInfoDepth].family;
            RtfFontInfo[FontInfoDepth + 1].shape = RtfFontInfo[FontInfoDepth].shape;
            RtfFontInfo[FontInfoDepth + 1].series = RtfFontInfo[FontInfoDepth].series;
            RtfFontInfo[FontInfoDepth + 1].encoding = RtfFontInfo[FontInfoDepth].encoding;
            FontInfoDepth++;
            diagnostics(6, (char*)"PushFontSettings depth=%2d, family=%2d, size=%2d, shape=%2d, series=%2d, encoding=%2d", FontInfoDepth, RtfFontInfo[FontInfoDepth].family, RtfFontInfo[FontInfoDepth].size, RtfFontInfo[FontInfoDepth].shape, RtfFontInfo[FontInfoDepth].series, RtfFontInfo[FontInfoDepth].encoding);
        }
        return;
    }
}

void PopFontSettings(void)
{
    {
        if (FontInfoDepth == 0){
            {
                diagnostics(1, (char*)"FontInfoDepth = 0, cannot PopFontSettings()!");
            }
        }
        {
            FontInfoDepth--;
            diagnostics(6, (char*)"PopFontSettings  depth=%2d, family=%2d, size=%2d, shape=%2d, series=%2d, encoding=%2d", FontInfoDepth, RtfFontInfo[FontInfoDepth].family, RtfFontInfo[FontInfoDepth].size, RtfFontInfo[FontInfoDepth].shape, RtfFontInfo[FontInfoDepth].series, RtfFontInfo[FontInfoDepth].encoding);
        }
        return;
    }
}

void MonitorFontChanges(const unsigned char* text)
{
    int n;
    int mode;
    int tmp;
    int mode___0;
    int tmp___0;
    int tmp___1;
    int tmp___2;
    int tmp___3;
    int tmp___4;
    int tmp___5;
    int tmp___6;
    int tmp___7;
    int tmp___8;
    int tmp___9;
    int tmp___10;
    int tmp___11;
    int tmp___12;
    {
        {
            diagnostics(6, (char*)"\nMonitorFont %10s\n", text);
            diagnostics(6, (char*)"MonitorFont before depth=%d, family=%d, size=%d, shape=%d, series=%d", FontInfoDepth, RtfFontInfo[FontInfoDepth].family, RtfFontInfo[FontInfoDepth].size, RtfFontInfo[FontInfoDepth].shape, RtfFontInfo[FontInfoDepth].series);
            tmp___12 = strstart(text, "\\b0");
        }
        if (tmp___12){
            RtfFontInfo[FontInfoDepth].series = 1;
        }else{
            {
                tmp___10 = strstart(text, "\\b ");
            }
            if (tmp___10){
                RtfFontInfo[FontInfoDepth].series = 5;
            }else{
                {
                    tmp___11 = strstart(text, "\\b\\");
                }
                if (tmp___11){
                    RtfFontInfo[FontInfoDepth].series = 5;
                }else{
                    {
                        tmp___9 = strstart(text, "\\i0");
                    }
                    if (tmp___9){
                        {
                            tmp = getTexMode();
                            mode = tmp;
                        }
                        if (mode == 4){
                            RtfFontInfo[FontInfoDepth].shape = 17;
                        }else
                            if (mode == 5){
                                RtfFontInfo[FontInfoDepth].shape = 17;
                            }else{
                                RtfFontInfo[FontInfoDepth].shape = 13;
                            }
                    }else{
                        {
                            tmp___7 = strstart(text, "\\i ");
                        }
                        if (tmp___7){
                            RtfFontInfo[FontInfoDepth].shape = 5;
                        }else{
                            {
                                tmp___8 = strstart(text, "\\i\\");
                            }
                            if (tmp___8){
                                RtfFontInfo[FontInfoDepth].shape = 5;
                            }else{
                                {
                                    tmp___6 = strstart(text, "\\scaps0");
                                }
                                if (tmp___6){
                                    {
                                        tmp___0 = getTexMode();
                                        mode___0 = tmp___0;
                                    }
                                    if (mode___0 == 4){
                                        RtfFontInfo[FontInfoDepth].shape = 17;
                                    }else
                                        if (mode___0 == 5){
                                            RtfFontInfo[FontInfoDepth].shape = 17;
                                        }else{
                                            RtfFontInfo[FontInfoDepth].shape = 13;
                                        }
                                }else{
                                    {
                                        tmp___4 = strstart(text, "\\scaps ");
                                    }
                                    if (tmp___4){
                                        RtfFontInfo[FontInfoDepth].shape = 9;
                                    }else{
                                        {
                                            tmp___5 = strstart(text, "\\scaps\\");
                                        }
                                        if (tmp___5){
                                            RtfFontInfo[FontInfoDepth].shape = 9;
                                        }else{
                                            {
                                                tmp___3 = strstartnum(text, "\\fs", &n);
                                            }
                                            if (tmp___3){
                                                RtfFontInfo[FontInfoDepth].size = n;
                                            }else{
                                                {
                                                    tmp___2 = strstartnum(text, "\\f", &n);
                                                }
                                                if (tmp___2){
                                                    RtfFontInfo[FontInfoDepth].family = n;
                                                }else{
                                                    {
                                                        tmp___1 = strstart(text, "\\plain");
                                                    }
                                                    if (tmp___1){
                                                        RtfFontInfo[FontInfoDepth].size = RtfFontInfo[0].size;
                                                        RtfFontInfo[FontInfoDepth].family = RtfFontInfo[0].family;
                                                        RtfFontInfo[FontInfoDepth].shape = RtfFontInfo[0].shape;
                                                        RtfFontInfo[FontInfoDepth].series = RtfFontInfo[0].series;
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        {
            diagnostics(6, (char*)"MonitorFont after depth=%d, family=%d, size=%d, shape=%d, series=%d", FontInfoDepth, RtfFontInfo[FontInfoDepth].family, RtfFontInfo[FontInfoDepth].size, RtfFontInfo[FontInfoDepth].shape, RtfFontInfo[FontInfoDepth].series);
        }
        return;
    }
}

