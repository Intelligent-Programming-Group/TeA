.type M <: unsigned
.type V <: unsigned
.type H <: unsigned
.type F <: unsigned
.type I <: unsigned
.type Z <: unsigned
.type P <: unsigned
.type E <: unsigned
.type C <: unsigned
.type OP <: unsigned
.type U <: unsigned
.type UP <: unsigned
.type T <: unsigned

.decl ci_pt(v:V, h:H)
.input ci_pt
.decl ci_hpt(h:H, o:H)
.input ci_hpt
.decl ci_fpt(h:H, f:F, o:H)
.input ci_fpt

//.decl primV(v:V)
//.input primV
.decl primH(h:H)
.input primH

.decl inputV(p:P, v:V)
.decl inputH(p:P, h:H)

.decl ci_IM(i:I, m:M)
.input ci_IM
.decl ci_reachableM(m:M)
.input ci_reachableM
.decl ci_MH(m:M, h:H)
.input ci_MH
.decl ci_non_MH(m:M, h:H)
.input ci_non_MH
.decl MV(m:M, v:V)
.input MV
.decl MI(m:M, i:I)
.input MI

.decl MPentry(m:M,p:P)
.input MPentry
.decl MPexit(m:M,p:P)
.input MPexit
.decl PPdirect(p:P,q:P)
.input PPdirect
.decl PPtrue(p:P,q:P,v:V)
.input PPtrue
.decl PPfalse(p:P,q:P,v:V)
.input PPfalse

.decl LoadPtr(y:V, x:V)
.input LoadPtr
.decl StorePtr(y:V, x:V)
.input StorePtr

.decl P_strong_update(p:P, h:H)
.input P_strong_update
.decl P_weak_update(p:P, h:H)
.input P_weak_update
.decl P_no_update(p:P, h:H)
.input P_no_update

// actually useless, in c, gep always returns a pointer
//.decl LoadFld(y:V, x:V, f:F)
//.input LoadFld
//.decl StoreFld(y:V, f:F, x:V)
//.input StoreFld

.decl LoadArr(y:V, x:V, i:V)
.input LoadArr
.decl StoreArr(y:V, i:V, x:V)
.input StoreArr

.decl IinvkArg(i:I, n:Z, x:V)
.input IinvkArg
.decl IinvkRet(i:I, y:V)
.input IinvkRet
.decl MmethArg(m:M, n:Z, x:V)
.input MmethArg
.decl MmethRet(m:M, y:V)
.input MmethRet

.decl Pinvk(p:P, i:I)
.input Pinvk

.decl Pstore(p:P, v:V)
.input Pstore
.decl Pload(p:P, v:V)
.input Pload

.decl Palloc(p:P, v:V)
.input Palloc
.decl Pnoop(p:P)
.input Pnoop

.decl Peval(p:P, v:V, e:E)
.input Peval
.decl Econst(e:V, c:C)
.input Econst
.decl Eunary(e:V, o:OP, v:V)
.input Eunary
.decl Ebinop(e:V, o:OP, v1:V, v2:V)
.input Ebinop
.decl Eprimcast(v:V,t:T,u:V)
.input Eprimcast
.decl Eptrcast(v:V,t:T,u:V)
.input Eptrcast
.decl Esizeof(v:V,u:V)
.input Esizeof
.decl PtrOP(op:OP)
.input PtrOP
.decl NotPtrOP(op:OP)
.input NotPtrOP

.decl ConstU(e:C, c:U)
.input ConstU
.decl evalUnaryU(o:OP, c0:U, c:U)
.input evalUnaryU
.decl evalBinopU(o:OP, c1:U, c2:U, c:U)
.input evalBinopU
.decl evalPlusU(o1:U,o2:U,res:U)
.input evalPlusU
.decl evalMultU(o1:U,o2:U,res:U)
.input evalMultU
.decl Uempty(c:U)
.input Uempty
.decl Uzero(c:U)
.input Uzero
.decl Unonzero(c:U)
.input Unonzero
.decl Uunknown(c:U)
.input Uunknown

.decl MallocMem(p:V,content:H)
.input MallocMem
.decl FixArrayShape(content:H,t:T,c:C)
.input FixArrayShape
.decl VarArrayShape(content:H,t:T,v:V)
.input VarArrayShape
.decl HeapArrayContent(arr:H,content:H)
.input HeapArrayContent

.decl PredUnknown(v:V)
.input PredUnknown
.decl PredL(v:V, p:UP, h1:H, c2:U)
.input PredL
.decl PredR(v:V, p:UP, c1:U, h2:H)
.input PredR
.decl Pred2(v:V, p:UP, h1:H, h2:H)
.input Pred2
.decl MaySat(p:UP, c1:U, c2:U)
.input MaySat
.decl MayUnsat(p:UP, c1:U, c2:U)
.input MayUnsat
.decl nofilter(v:V, h:H)
.input nofilter

.decl ci_postPHval(p:P, h:H, c:U)
.decl ci_PHval(p:P, h:H, c:U)
.output ci_PHval
.decl ci_gHval(h:H, c:U)
.output ci_gHval
.decl ci_Vval(v:V, c:U)
.output ci_Vval
//.decl ci_Fval(h:H, f:F, c:U)
//.output ci_Fval

.decl ci_postPHoffset(p:P, h:H, content:H, type:T, offset:U)
.decl ci_PHoffset(p:P, h:H, content:H, type:T, offset:U)
.output ci_PHoffset
.decl ci_gHoffset(h:H, content:H, type:T, offset:U)
.output ci_gHoffset
.decl ci_Voffset(v:V,content:H,type:T,offset:U)
.output ci_Voffset

//.decl ExtMeth(m:M)
//.input ExtMeth
// change this marker to meth-related
.decl argInput(m:M, z:Z)
.input argInput
.decl retInput(m:M)
.input retInput
.decl Uinput(c:U)
.input Uinput

.decl GlobalAllocMem(v:V,h:H)
.input GlobalAllocMem
.decl AllocMem(v:V,h:H)
.input AllocMem
.decl HeapStructField(h:H,f:F,o:H)
.input HeapStructField

.decl MP(m:M, p:P)
.input MP
.decl LocalMH(m:M, h:H)
.input LocalMH
.decl NonLocalMH(m:M, h:H)
.input NonLocalMH

.decl ci_reachableV(v:V)

ci_reachableV(v) :- ci_reachableM(m), MV(m,v).

ci_Vval(v,u) :- ci_reachableV(v), Econst(v, c), ConstU(c, u).
ci_Vval(v,u) :- ci_reachableV(v), Eunary(v, o, v0), ci_Vval(v0, u0), evalUnaryU(o, u0, u).
ci_Vval(v,u) :- ci_reachableV(v), Ebinop(v, o, v1, v2), ci_Vval(v1, u1), ci_Vval(v2, u2), evalBinopU(o, u1, u2, u).
ci_Vval(v,u) :- ci_reachableV(v), Eprimcast(v, _, v0), ci_Vval(v0, u).
ci_Vval(v,u) :- ci_reachableV(v), Eprimcast(v, _, v0), ci_pt(v0, _), Uunknown(u). // casting from ptr to scalar goes to unknown
ci_Vval(u,c) :- Pload(p,u), LoadPtr(u,v), ci_pt(v,h), ci_PHval(p,h,c).
ci_Vval(u,c) :- Pload(p,u), LoadPtr(u,v), ci_pt(v,h), ci_gHval(h,c), MP(m,p), NonLocalMH(m,h).
ci_Vval(v,c) :- ci_reachableV(v), Esizeof(v,p), ci_pt(p,content), VarArrayShape(content,_,x), ci_Vval(x,c).
ci_Vval(v,c) :- ci_reachableV(v), Esizeof(v,p), ci_pt(p,content), FixArrayShape(content,_,b), ConstU(b,c).

ci_PHval(q,h,c) :- PPdirect(p,q), ci_postPHval(p,h,c).
ci_PHval(q,h,c) :- PPtrue(p,q,v), ci_postPHval(p,h,c), PredUnknown(v).
ci_PHval(q,h,c) :- PPfalse(p,q,v), ci_postPHval(p,h,c), PredUnknown(v).
ci_PHval(q,h,c) :- PPtrue(p,q,v), ci_postPHval(p,h,c), nofilter(v,h).
ci_PHval(q,h,c) :- PPfalse(p,q,v), ci_postPHval(p,h,c), nofilter(v,h).
ci_PHval(q,h1,c1) :- PPtrue(p,q,v), PredL(v,pred,h1,c2), ci_postPHval(p,h1,c1), MaySat(pred,c1,c2).
ci_PHval(q,h1,c1) :- PPfalse(p,q,v), PredL(v,pred,h1,c2), ci_postPHval(p,h1,c1), MayUnsat(pred,c1,c2).
ci_PHval(q,h2,c2) :- PPtrue(p,q,v), PredR(v,pred,c1,h2), ci_postPHval(p,h2,c2), MaySat(pred,c1,c2).
ci_PHval(q,h2,c2) :- PPfalse(p,q,v), PredR(v,pred,c1,h2), ci_postPHval(p,h2,c2), MayUnsat(pred,c1,c2).
ci_PHval(q,h1,c1), ci_PHval(q,h2,c2) :- PPtrue(p,q,v), Pred2(v,pred,h1,h2), ci_postPHval(p,h1,c1), ci_postPHval(p,h2,c2), MaySat(pred,c1,c2).
ci_PHval(q,h1,c1), ci_PHval(q,h2,c2) :- PPfalse(p,q,v), Pred2(v,pred,h1,h2), ci_postPHval(p,h1,c1), ci_postPHval(p,h2,c2), MayUnsat(pred,c1,c2).
ci_PHval(q,h1,c1) :- PPtrue(p,q,v), Pred2(v,pred,h1,h2), ci_postPHval(p,h1,c1), ci_gHval(h2,c2), MP(m,p), NonLocalMH(m,h2), MaySat(pred,c1,c2).
ci_PHval(q,h1,c1) :- PPfalse(p,q,v), Pred2(v,pred,h1,h2), ci_postPHval(p,h1,c1), ci_gHval(h2,c2), MP(m,p), NonLocalMH(m,h2), MayUnsat(pred,c1,c2).
ci_PHval(q,h2,c2) :- PPtrue(p,q,v), Pred2(v,pred,h1,h2), ci_gHval(h1,c1), MP(m,p), NonLocalMH(m,h1), ci_postPHval(p,h2,c2), MaySat(pred,c1,c2).
ci_PHval(q,h2,c2) :- PPfalse(p,q,v), Pred2(v,pred,h1,h2), ci_gHval(h1,c1), MP(m,p), NonLocalMH(m,h1), ci_postPHval(p,h2,c2), MayUnsat(pred,c1,c2).

ci_gHval(h,c) :- Pstore(p,v), StorePtr(u,v), ci_pt(u,h), ci_Vval(v,c), MP(m,p), NonLocalMH(m,h).
ci_postPHval(p,h,c) :- Pstore(p,v), StorePtr(u,v), ci_pt(u,h), ci_Vval(v,c), MP(m,p), LocalMH(m,h), P_strong_update(p,h).
ci_postPHval(p,h,c) :- Pstore(p,v), StorePtr(u,v), ci_pt(u,h), ci_Vval(v,c), MP(m,p), LocalMH(m,h), P_weak_update(p,h).
ci_postPHval(p,h,c) :- Pstore(p,_), ci_PHval(p,h,c), P_weak_update(p,h).
ci_postPHval(p,h,c) :- Pstore(p,_), ci_PHval(p,h,c), P_no_update(p,h).
ci_postPHval(p,h,c) :- Peval(p,_,_), ci_PHval(p,h,c).
ci_postPHval(p,h,c) :- Pload(p,_), ci_PHval(p,h,c).
ci_postPHval(p,h,c) :- Palloc(p,_), ci_PHval(p,h,c).
ci_postPHval(p,h,c) :- Pnoop(p), ci_PHval(p,h,c).

ci_Vval(u,c) :- ci_IM(i,m), IinvkArg(i,z,v), MmethArg(m,z,u), ci_Vval(v,c).
ci_Vval(v,c) :- ci_IM(i,m), IinvkRet(i,v), MmethRet(m,u), ci_Vval(u,c).
// suppose all memobj are un-initialized
ci_PHval(p,h,c) :- MPentry(m,p), ci_MH(m,h), primH(h), LocalMH(m,h), Uempty(c).
ci_gHval(h,c) :- primH(h), Uempty(c).
// implicit arguments/returns are passed by pointers
ci_gHval(h,c) :- ci_PHval(p,h,c), Pinvk(p,i), ci_IM(i,m), ci_MH(m,h).
ci_postPHval(p,h,c) :- ci_gHval(h,c), ci_PHval(p,h,_), Pinvk(p,i), ci_IM(i,m), ci_MH(m,h).
ci_postPHval(p,h,c) :- ci_PHval(p,h,c), Pinvk(p,i), ci_IM(i,m), ci_non_MH(m,h).
//ci_postPHval(p,h,c) :- Pinvk(p,i), ci_PHval(p,h,c), ci_IM(i,m), ExtMeth(m). // treat all external methods as pure, i.e. no heaps are touched

inputV(p,u) :- Pinvk(p,i), ci_IM(i,m), IinvkArg(i,z,u), argInput(m,z).
inputV(p,v) :- Pinvk(p,i), ci_IM(i,m), IinvkRet(i,v), retInput(m).
inputH(p,h) :- inputV(p,v), ci_pt(v,h).
inputH(p,o) :- inputH(p,h), ci_hpt(h,o).
inputH(p,o) :- inputH(p,h), ci_fpt(h,_,o).
inputH(p,o) :- inputH(p,h), HeapArrayContent(h,o).

ci_Vval(v,c) :- inputV(_,v), Uinput(c).
ci_postPHval(p,h,c) :- inputH(p,h), primH(h), MP(m,p), LocalMH(m,h), Uinput(c).
ci_gHval(h,c) :- inputH(p,h), primH(h), MP(m,p), NonLocalMH(m,h), Uinput(c).

// computing array content offsets
// 1: dereferencing an array object gets its first element
ci_Voffset(p,content,t,c) :- LoadPtr(p,base), ci_pt(base,arr), HeapArrayContent(arr,content), FixArrayShape(content,t,_), Uzero(c).
ci_Voffset(p,content,t,c) :- LoadPtr(p,base), ci_pt(base,arr), HeapArrayContent(arr,content), VarArrayShape(content,t,_), Uzero(c).
// 2: malloc-ed ptr points to its first element
ci_Voffset(p,content,t,c) :- MallocMem(p,content), VarArrayShape(content,t,_), Uzero(c).
// 3: casting pointers
ci_Voffset(p,content,t,c) :- Eptrcast(p,t,q), ci_Voffset(q,content,_,c), Uzero(c).
// casting middle elements goes to unknown
ci_Voffset(p,content,t,u) :- Eptrcast(p,t,q), ci_Voffset(q,content,_,c), Unonzero(c), Uunknown(u).
// casting from primitive vals goes to unknown
ci_Voffset(p,content,t,u) :- Eptrcast(p,t,q), ci_Vval(q,_), ci_pt(p,content), Uunknown(u).
// 4: gep propagates offsets
ci_Voffset(p,content,t,c) :- LoadArr(p,q,i), ci_Vval(i,c1), ci_Voffset(q,content,t,c2), evalPlusU(c1,c2,c).
// 4.1: computations as well
ci_Voffset(v,content,t,u) :- ci_reachableM(m), MV(m, v), Eunary(v, o, v0), ci_Voffset(v0, content, t, u0), evalUnaryU(o, u0, u), PtrOP(o).
ci_Voffset(v,content,t,u) :- ci_reachableM(m), MV(m, v), Ebinop(v, o, v1, v2), ci_Voffset(v1, content, t, u1), ci_Vval(v2, u2), evalBinopU(o, u1, u2, u), PtrOP(o).
ci_Voffset(v,content,t,u) :- ci_reachableM(m), MV(m, v), Ebinop(v, o, v1, v2), ci_Vval(v1, u1), ci_Voffset(v2, content, t, u2), evalBinopU(o, u1, u2, u), PtrOP(o).
// 5: store and fetch from heaps (no need to refine field-pt, as it may not points to array contents)
ci_Voffset(u,content,t,c) :- Pload(p,u), LoadPtr(u,v), ci_pt(v,h), ci_PHoffset(p,h,content,t,c).
ci_Voffset(u,content,t,c) :- Pload(p,u), LoadPtr(u,v), ci_pt(v,h), ci_gHoffset(h,content,t,c), MP(m,p), NonLocalMH(m,h).
ci_PHoffset(q,h,content,t,c) :- PPdirect(p,q), ci_postPHoffset(p,h,content,t,c).
ci_PHoffset(q,h,content,t,c) :- PPtrue(p,q,_), ci_postPHoffset(p,h,content,t,c).
ci_PHoffset(q,h,content,t,c) :- PPfalse(p,q,_), ci_postPHoffset(p,h,content,t,c).

ci_gHoffset(h,content,t,c) :- Pstore(p,v), StorePtr(u,v), ci_pt(u,h), ci_Voffset(v,content,t,c), MP(m,p), NonLocalMH(m,h).
ci_postPHoffset(p,h,content,t,c) :- Pstore(p,v), StorePtr(u,v), ci_pt(u,h), ci_Voffset(v,content,t,c), MP(m,p), LocalMH(m,h), P_strong_update(p,h).
ci_postPHoffset(p,h,content,t,c) :- Pstore(p,v), StorePtr(u,v), ci_pt(u,h), ci_Voffset(v,content,t,c), MP(m,p), LocalMH(m,h), P_weak_update(p,h).
ci_postPHoffset(p,h,content,t,c) :- Pstore(p,_), ci_PHoffset(p,h,content,t,c), P_weak_update(p,h).
ci_postPHoffset(p,h,content,t,c) :- Pstore(p,_), ci_PHoffset(p,h,content,t,c), P_no_update(p,h).
ci_postPHoffset(p,h,content,t,c) :- Peval(p,_,_), ci_PHoffset(p,h,content,t,c).
ci_postPHoffset(p,h,content,t,c) :- Pload(p,_), ci_PHoffset(p,h,content,t,c).
ci_postPHoffset(p,h,content,t,c) :- Palloc(p,_), ci_PHoffset(p,h,content,t,c).
ci_postPHoffset(p,h,content,t,c) :- Pnoop(p), ci_PHoffset(p,h,content,t,c).

ci_Voffset(u,content,t,c) :- ci_IM(i,m), IinvkArg(i,z,v), MmethArg(m,z,u), ci_Voffset(v,content,t,c).
ci_Voffset(v,content,t,c) :- ci_IM(i,m), IinvkRet(i,v), MmethRet(m,u), ci_Voffset(u,content,t,c).
// implicit arguments/returns are passed by pointers
ci_gHoffset(h,content,t,c) :- ci_PHoffset(p,h,content,t,c), Pinvk(p,i), ci_IM(i,m), ci_MH(m,h).
ci_postPHoffset(p,h,content,t,c) :- ci_gHoffset(h,content,t,c), ci_PHoffset(p,h,_,_,_), Pinvk(p,i), ci_IM(i,m), ci_MH(m,h).
ci_postPHoffset(p,h,content,t,c) :- ci_PHoffset(p,h,content,t,c), Pinvk(p,i), ci_IM(i,m), ci_non_MH(m,h).
//ci_postPHoffset(p,h,content,t,c) :- Pinvk(p,i), ci_PHoffset(p,h,content,t,c), ci_IM(i,m), ExtMeth(m). // treat all external methods as pure, i.e. no heaps are touched