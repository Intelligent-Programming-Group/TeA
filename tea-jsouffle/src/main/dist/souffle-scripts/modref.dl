.type M <: unsigned
.type P <: unsigned
.type V <: unsigned
.type C <: unsigned
.type Z <: unsigned
.type A <: unsigned

.decl ci_IM(i:P, m:M)
.input ci_IM

.decl MP(m:M, p:P)
.input MP
.decl PP(p:P, q:P)
.input PP
.decl refine_pt(i:V, h:A)
.input refine_pt
.decl refine_hpt(h:A, o:A)
.input refine_hpt
.decl APfield(a:A, f:Z, fld:A)
.input APfield

.decl variable_global(v:V)
.input variable_global

.decl instruction_load_ptr(p:P, ptr:V)
.input instruction_load_ptr
.decl instruction_store_addr(p:P, addr:V)
.input instruction_store_addr

.decl Peval(p:P,v:V)
.input Peval
.decl Palloca(p:P,v:V)
.input Palloca
.decl Pstore(p:P,v:V)
.input Pstore
.decl Pload(p:P,v:V)
.input Pload
.decl Pinvk(p:P)
.input Pinvk
.decl Passign(p:P,v:V)
.input Passign
.decl Pnoop(p:P)
.input Pnoop

.decl ExtMeth(m:M)
.input ExtMeth
.decl argInput(m:M, i:Z)
.input argInput
.decl retInput(m:M)
.input retInput
.decl IinvkArg(p:P, i:Z, v:V)
.input IinvkArg
.decl IinvkRet(p:P, v:V)
.input IinvkRet
.decl MmethArg(m:M, i:Z, v:V)
.input MmethArg
.decl instruction_ret(p:P)
.input instruction_ret
.decl instruction_ret_var(p:P, v:V)
.input instruction_ret_var

.decl MPentry(m:M, p:P)
.input MPentry

.decl load_may_use(p:P, h:A)
.output load_may_use
.decl store_may_def(p:P, h:A)
.output store_may_def
.decl iarg_may_use(p:P, i:Z, h:A)
.output iarg_may_use
.decl iarg_may_def(p:P, i:Z, h:A)
.output iarg_may_def
.decl iret_may_use(p:P, h:A)
.output iret_may_use
.decl iret_may_def(p:P, h:A)
.output iret_may_def

.decl live_on_entry(m:M, i:Z, h:A)
.output live_on_entry
.decl ret_may_use(p:P, h:A)
.output ret_may_use

.decl global_obj(h:A)
.output global_obj

.decl M_may_def(m:M, h:A)
.output M_may_def
.decl M_may_use(m:M, h:A)
.output M_may_use
.decl DUedge(from:P, to:P) // Note: reachable relations among all defs and uses, no aliasing considered
.output DUedge

.decl memcpyFunc(m:M) // special handling for memcpy / memset like functions
.input memcpyFunc
.decl memmoveFunc(m:M)
.input memmoveFunc
.decl memsetFunc(m:M)
.input memsetFunc
.decl Z0(i0:Z)
.input Z0

global_obj(h) :- variable_global(v), refine_pt(v, h).
global_obj(o) :- global_obj(h), refine_hpt(h, o).
global_obj(fld) :- global_obj(a), APfield(a, _, fld).

live_on_entry(m, i, h) :- MmethArg(m, i, v), refine_pt(v, h).
live_on_entry(m, i, o) :- live_on_entry(m, i, h), refine_hpt(h, o).
live_on_entry(m, i, fld) :- live_on_entry(m, i, a), APfield(a, _, fld).

M_may_def(m, h) :- store_may_def(p, h), MP(m, p).
M_may_use(m, h) :- load_may_use(p, h), MP(m, p).
M_may_def(m, h) :- iret_may_def(p, h), MP(m, p).
M_may_use(m, h) :- iret_may_use(p, h), MP(m, p).
M_may_def(m, h) :- iarg_may_use(p, _, h), MP(m, p).
M_may_use(m, h) :- iarg_may_use(p, _, h), MP(m, p).

M_may_use(m, h) :- live_on_entry(m, _, h).
M_may_use(m, h) :- ret_may_use(p, h), MP(m, p).

store_may_def(p, h) :- instruction_store_addr(p, v), refine_pt(v, h).
load_may_use(p, h) :- instruction_load_ptr(p, v), refine_pt(v, h).

.decl iret_access(p:P, h:A)
.decl iarg_access(p:P, i:Z, h:A)
iret_access(p, h) :- IinvkRet(p, v), refine_pt(v, h).
iret_access(p, o) :- iret_access(p, h), refine_hpt(h, o).
iret_access(p, fld) :- iret_access(p, a), APfield(a, _, fld).
iarg_access(p, i, h) :- IinvkArg(p, i, v), refine_pt(v, h).
iarg_access(p, i, o) :- iarg_access(p, i, h), refine_hpt(h, o).
iarg_access(p, i, fld) :- iarg_access(p, i, a), APfield(a, _, fld).

// Note: global objects are implicitely returned
iret_may_use(p, h) :- M_may_use(callee, h), ci_IM(p, callee), global_obj(h).
iret_may_def(p, h) :- M_may_def(callee, h), ci_IM(p, callee), global_obj(h).
iret_may_use(p, h) :- M_may_use(callee, h), ci_IM(p, callee), iret_access(p, h).
iret_may_def(p, h) :- M_may_def(callee, h), ci_IM(p, callee), iret_access(p, h).
iarg_may_use(p, i, h) :- M_may_use(callee, h), ci_IM(p, callee), iarg_access(p, i, h).
iarg_may_def(p, i, h) :- M_may_def(callee, h), ci_IM(p, callee), iarg_access(p, i, h).

iret_may_use(p,h) :- iret_access(p, h), ci_IM(p, callee), ExtMeth(callee).
iret_may_def(p,h) :- iret_access(p, h), ci_IM(p, callee), retInput(callee).
iarg_may_use(p, i, h) :- iarg_access(p, i, h), ci_IM(p, callee), ExtMeth(callee).
iarg_may_def(p, i, h) :- iarg_access(p, i, h), ci_IM(p, callee), argInput(callee, i).

.decl mem_modify(p:P, h:A) 
mem_modify(p,h) :- ci_IM(p, callee), memsetFunc(callee), Z0(i), IinvkArg(p, i, v), refine_pt(v, h).
mem_modify(p,h) :- ci_IM(p, callee), memcpyFunc(callee), Z0(i), IinvkArg(p, i, v), refine_pt(v, h).
mem_modify(p,h) :- ci_IM(p, callee), memmoveFunc(callee), Z0(i), IinvkArg(p, i, v), refine_pt(v, h).
mem_modify(p,fld) :- mem_modify(p,a), APfield(a, _, fld).
iret_may_def(p, h) :- mem_modify(p, h).


ret_may_use(p,h) :- live_on_entry(m, _, h), MP(m, p), instruction_ret(p).
// Note: global objects are added into returned objects as well
ret_may_use(p,h) :- M_may_use(m, h), global_obj(h), MP(m, p), instruction_ret(p).
ret_may_use(p,h) :- M_may_def(m, h), global_obj(h), MP(m, p), instruction_ret(p).
.decl ret_access(p:P, h:A)
ret_access(p, h) :- instruction_ret_var(p, v), refine_pt(v, h).
ret_access(p, o) :- ret_access(p, h), refine_hpt(h, o).
ret_access(p, fld) :- ret_access(p, a), APfield(a, _, fld).
ret_may_use(p, h) :- ret_access(p, h).

// .decl def_track(def:P, to:P)
// def_track(def, to) :- Pstore(def, _), PP(def, to).
// def_track(def, to) :- Pinvk(def), PP(def, to).
// def_track(def, next) :- def_track(def, to), Peval(to, _), PP(to, next).
// def_track(def, next) :- def_track(def, to), Pnoop(to), PP(to, next).
// def_track(def, next) :- def_track(def, to), Palloca(to, _), PP(to, next).
// def_track(def, next) :- def_track(def, to), Passign(to, _), PP(to, next).
// def_def_edge(def, to) :- def_track(def, to), Pstore(to, _).
// def_use_edge(def, to) :- def_track(def, to), Pload(to, _).
// def_def_edge(def, to), def_use_edge(def, to) :- def_track(def, to), Pinvk(to).
// .decl use_track(def:P, to:P)
// use_track(use, to) :- Pload(use, _), PP(use, to).
// use_track(use, to) :- Pinvk(use), PP(use, to).
// use_track(use, next) :- use_track(use, to), Peval(to, _), PP(to, next).
// use_track(use, next) :- use_track(use, to), Pnoop(to), PP(to, next).
// use_track(use, next) :- use_track(use, to), Palloca(to, _), PP(to, next).
// use_track(use, next) :- use_track(use, to), Passign(to, _), PP(to, next).
// use_def_edge(use, to) :- use_track(use, to), Pstore(to, _).
// use_use_edge(use, to) :- use_track(use, to), Pload(to, _).
// use_def_edge(use, to), use_use_edge(use, to) :- use_track(use, to), Pinvk(to).
.decl DUtrack(from:P, to:P)
DUtrack(entry, to) :- MPentry(_, entry), PP(entry, to).
DUtrack(def, to) :- Pstore(def, _), PP(def, to).
DUtrack(use, to) :- Pload(use, _), PP(use, to).
DUtrack(invk, to) :- Pinvk(invk), PP(invk, to).
DUtrack(from, next) :- DUtrack(from, to), Peval(to, _), PP(to, next).
DUtrack(from, next) :- DUtrack(from, to), Pnoop(to), PP(to, next).
DUtrack(from, next) :- DUtrack(from, to), Palloca(to, _), PP(to, next).
DUtrack(from, next) :- DUtrack(from, to), Passign(to, _), PP(to, next).
DUedge(from, to) :- DUtrack(from, to), Pstore(to, _).
DUedge(from, to) :- DUtrack(from, to), Pload(to, _).
DUedge(from, to) :- DUtrack(from, to), Pinvk(to).

DUedge(from, to) :- DUtrack(from, to), instruction_ret(to).