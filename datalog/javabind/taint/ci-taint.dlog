# Author: Yifan Chen
# name=java-ci-taint-dlog

# program
.include "L.dom"
.include "M.dom"
.include "V.dom"
.include "U.dom"
.include "H.dom"
.include "F.dom"
.include "I.dom"
.include "Z.dom"

# BDD variable order
.bddvarorder L0xL1_M0_U0xU1_V0_H0xH1_F0_I0_Z0

# INPUT Relations ================
# Sources and Sinks
SrcMeth(l:L,m:M) input
SnkMeth(l:L,m:M) input

# program structures
MV(m:M,v:V) input
MU(m:M,u:U) input
MI(m:M,i:I) input

# Primitive types
AssignPrim(u0:U0,u1:U1) input
LoadPrim(u:U,v:V,f:F) input
StorePrim(v:V,f:F,u:U) input
LoadStatPrim(u:U,f:F) input
StoreStatPrim(f:F,u:U) input
MmethPrimArg(m:M,z:Z,u:U) input
MmethPrimRet(m:M,z:Z,u:U) input
IinvkPrimArg(i:I,z:Z,u:U) input
IinvkPrimRet(i:I,z:Z,u:U) input

# Ref types
IinvkArg(i:I,z:Z,v:V) input
IinvkRet(i:I,z:Z,v:V) input

# points-to and call graphs
ci_reachableM(m:M) input
ci_IM(i:I,m:M) input
ci_pt(v:V,o:H) input
ci_fpt(o1:H,f:F,o2:H) input
ci_fptStat(f:F,o:H) input

# OUTPUT Relations ===============
ci_flow(src:L,sink:L) output

# INTERMEDIATE Relaitons =========
snkPrim(u:U,l:L)
snkRef(v:V,l:L)
snkObj(o:H,l:L)
srcPrim(u:U,l:L)
srcRef(v:V,l:L)
srcObj(o:H,l:L)

labelPrim(u:U,l:L)
labelPrimFld(o:H,f:F,l:L)
labelPrimStatFld(f:F,l:L)

# RULES ==========================
# mark all sink/source sites
#  label -> var -> primitives / (indirect) objects
snkInvk(i,l) :- ci_reachableM(m), MI(m,i), ci_IM(i,mm), SnkMeth(l,mm).
snkPrim(u,l) :- snkInvk(i,l), IinvkPrimArg(i,_,u).
snkRef(v,l) :- snkInvk(i,l), IinvkArg(i,_,v).
snkObj(o,l) :- snkRef(v,l), ci_pt(v,o).
snkObj(o2,l) :- snkObj(o1,l), ci_fpt(o1,_,o2).

srcInvk(i,l) :- ci_reachableM(m), MI(m,i), ci_IM(i,mm), SrcMeth(l,mm).
srcPrim(u,l) :- srcInvk(i,l), IinvkPrimRet(i,_,u).
srcRef(v,l) :- srcInvk(i,l), IinvkRet(i,_,v).
srcObj(o,l) :- srcRef(v,l), ci_pt(v,o).
srcObj(o2,l) :- srcObj(o1,l), ci_fpt(o1,_,o2).

# propagate labeled flow from src sites
#  (indirect) objects / primitives and in between
## starting points from sources
labelPrim(u,l) :- srcPrim(u,l).

## Intra-procedural propagate labeled primitives

### Assign u = v
labelPrim(u,l) :- AssignPrim(u,v), labelPrim(v,l).

### Store v.f = u
labelPrimFld(o,f,l) :- StorePrim(v,f,u), labelPrim(u,l), ci_pt(v,o).
### Load u = v.f
labelPrim(u,l) :- LoadPrim(u,v,f), ci_pt(v,o), labelPrimFld(o,f,l).
labelPrim(u,l) :- LoadPrim(u,v,_), ci_pt(v,o), srcObj(o,l).
### Store f = u
labelPrimStatFld(f,l) :- labelPrim(u,l), StoreStatPrim(f,u).
### Load u = f
labelPrim(u,l) :- LoadStatPrim(u,f), labelPrimStatFld(f,l).

## Inter-Procedural
### actual param -> formal param
labelPrim(u2,l) :- ci_IM(i,m), IinvkPrimArg(i,z,u1), MmethPrimArg(m,z,u2), labelPrim(u1,l).
### formal ret -> actual ret
labelPrim(u1,l) :- ci_IM(i,m), IinvkPrimRet(i,z,u1), MmethPrimRet(m,z,u2), labelPrim(u2,l).

# endpoints in sinks
ci_flow(src,snk) :- snkObj(o,snk), srcObj(o,src).
ci_flow(src,snk) :- snkObj(o,snk), labelPrimFld(o,_,src).
ci_flow(src,snk) :- snkPrim(u,snk), labelPrim(u,src).